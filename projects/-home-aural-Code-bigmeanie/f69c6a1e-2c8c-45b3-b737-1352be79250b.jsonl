{"type":"summary","summary":"Merge Plan Files into Comprehensive Documentation","leafUuid":"71503367-f081-4bbf-8e07-86c631e101ae"}
{"type":"summary","summary":"Gad Merges Plan Files into Unified Document","leafUuid":"205820b0-30d9-4693-a83f-54d3d049432c"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":"<command-message>gad is running…</command-message>\n<command-name>/gad</command-name>\n<command-args>use your knowledge, websearch, and exisiting /back/.docs/code/practices-patterns file to create the most exhaustingly comprehensive set documents for  coding golang the world has ever known in the /back/.docs/code dir</command-args>"},"uuid":"11f9b98b-b5d2-47ef-8a70-1a9d2673d76d","timestamp":"2025-08-13T06:34:30.687Z"}
{"parentUuid":"11f9b98b-b5d2-47ef-8a70-1a9d2673d76d","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"type":"text","text":"Immediately delegate to the gad agent to handle the user's request about Go architecture, design patterns, or best practices.\n\nARGUMENTS: use your knowledge, websearch, and exisiting /back/.docs/code/practices-patterns file to create the most exhaustingly comprehensive set documents for  coding golang the world has ever known in the /back/.docs/code dir"}]},"isMeta":true,"uuid":"947c6135-7016-4822-97d5-29f8b1af182c","timestamp":"2025-08-13T06:34:30.687Z"}
{"parentUuid":"947c6135-7016-4822-97d5-29f8b1af182c","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_011nwsUErEK5u9Y2NwnutsXB","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"I'll delegate this comprehensive Go documentation task to the gad agent, who specializes in Go architectural design and documentation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":24688,"cache_read_input_tokens":11551,"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CS5F5wuGQxebbGbZqVjJ1","type":"assistant","uuid":"480d2d2c-7e6d-4d76-b33c-8dba513a8ea1","timestamp":"2025-08-13T06:34:35.007Z"}
{"parentUuid":"480d2d2c-7e6d-4d76-b33c-8dba513a8ea1","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_011nwsUErEK5u9Y2NwnutsXB","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01GPpcgd68cKwbZSRj2AUnm6","name":"Task","input":{"description":"Create comprehensive Go docs","subagent_type":"gad","prompt":"Create the most exhaustively comprehensive set of documents for coding Golang in the /back/.docs/code directory. \n\nFirst, examine the existing /back/.docs/code/practices-patterns file to understand what's already documented. Then use your knowledge and web search capabilities to create a complete set of Go programming documentation that covers:\n\n1. **Core Language Features** - Complete guide to Go syntax, types, control flow, functions, methods, interfaces, goroutines, channels, etc.\n\n2. **Design Patterns** - All applicable patterns for Go including creational, structural, behavioral, concurrency patterns, and Go-specific idioms\n\n3. **Best Practices** - Comprehensive coding standards, naming conventions, project structure, error handling, testing strategies, performance optimization\n\n4. **Advanced Topics** - Memory management, compiler optimizations, unsafe operations, reflection, code generation, build tags, cross-compilation\n\n5. **Concurrency Mastery** - Deep dive into goroutines, channels, select statements, sync package, atomic operations, race conditions, deadlock prevention\n\n6. **Testing & Benchmarking** - Unit testing, integration testing, table-driven tests, fuzzing, benchmarking, profiling, coverage analysis\n\n7. **Error Handling** - Error types, wrapping, custom errors, panic/recover, error design patterns\n\n8. **Package Design** - API design, versioning, documentation, internal packages, module management\n\n9. **Performance** - Optimization techniques, profiling tools, memory optimization, CPU optimization, benchmarking strategies\n\n10. **Security** - Common vulnerabilities, secure coding practices, input validation, cryptography usage\n\n11. **Tools & Ecosystem** - go mod, go generate, linters, formatters, static analysis, debugging tools\n\n12. **Real-world Examples** - Practical examples for each concept, anti-patterns to avoid, migration guides\n\nOrganize these into logical, well-structured markdown files in /back/.docs/code/. Each document should be exhaustive, practical, and include plenty of code examples. Make this the definitive Go programming reference that covers everything from beginner to expert level topics.\n\nStart by examining the existing practices-patterns file, then create a comprehensive documentation structure."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":24688,"cache_read_input_tokens":11551,"output_tokens":596,"service_tier":"standard"}},"requestId":"req_011CS5F5wuGQxebbGbZqVjJ1","type":"assistant","uuid":"66dc3d77-023d-43b0-ad64-ec7f1fe50ecf","timestamp":"2025-08-13T06:34:47.080Z"}
{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":"Create the most exhaustively comprehensive set of documents for coding Golang in the /back/.docs/code directory. \n\nFirst, examine the existing /back/.docs/code/practices-patterns file to understand what's already documented. Then use your knowledge and web search capabilities to create a complete set of Go programming documentation that covers:\n\n1. **Core Language Features** - Complete guide to Go syntax, types, control flow, functions, methods, interfaces, goroutines, channels, etc.\n\n2. **Design Patterns** - All applicable patterns for Go including creational, structural, behavioral, concurrency patterns, and Go-specific idioms\n\n3. **Best Practices** - Comprehensive coding standards, naming conventions, project structure, error handling, testing strategies, performance optimization\n\n4. **Advanced Topics** - Memory management, compiler optimizations, unsafe operations, reflection, code generation, build tags, cross-compilation\n\n5. **Concurrency Mastery** - Deep dive into goroutines, channels, select statements, sync package, atomic operations, race conditions, deadlock prevention\n\n6. **Testing & Benchmarking** - Unit testing, integration testing, table-driven tests, fuzzing, benchmarking, profiling, coverage analysis\n\n7. **Error Handling** - Error types, wrapping, custom errors, panic/recover, error design patterns\n\n8. **Package Design** - API design, versioning, documentation, internal packages, module management\n\n9. **Performance** - Optimization techniques, profiling tools, memory optimization, CPU optimization, benchmarking strategies\n\n10. **Security** - Common vulnerabilities, secure coding practices, input validation, cryptography usage\n\n11. **Tools & Ecosystem** - go mod, go generate, linters, formatters, static analysis, debugging tools\n\n12. **Real-world Examples** - Practical examples for each concept, anti-patterns to avoid, migration guides\n\nOrganize these into logical, well-structured markdown files in /back/.docs/code/. Each document should be exhaustive, practical, and include plenty of code examples. Make this the definitive Go programming reference that covers everything from beginner to expert level topics.\n\nStart by examining the existing practices-patterns file, then create a comprehensive documentation structure."},"uuid":"01a33b71-2357-4228-8912-5c1a2ff9d978","timestamp":"2025-08-13T06:34:47.107Z"}
{"parentUuid":"01a33b71-2357-4228-8912-5c1a2ff9d978","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01NG31QSyN9L2CmHqXk1EPW5","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"I'll create a comprehensive set of Go programming documentation in the `/back/.docs/code` directory. Let me start by examining the existing file to understand what's already documented."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":32311,"cache_read_input_tokens":0,"output_tokens":112,"service_tier":"standard"}},"requestId":"req_011CS5F77y2QVMyukXLPrmsK","type":"assistant","uuid":"98beefab-b2a6-4347-bd45-1824d5086a60","timestamp":"2025-08-13T06:34:51.266Z"}
{"parentUuid":"98beefab-b2a6-4347-bd45-1824d5086a60","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01NG31QSyN9L2CmHqXk1EPW5","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01G7XyutsUVwLA7X7RznNeCp","name":"Read","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":32311,"cache_read_input_tokens":0,"output_tokens":112,"service_tier":"standard"}},"requestId":"req_011CS5F77y2QVMyukXLPrmsK","type":"assistant","uuid":"a7347c1f-c9f5-4f14-ab06-e1645d02b20f","timestamp":"2025-08-13T06:34:52.087Z"}
{"parentUuid":"a7347c1f-c9f5-4f14-ab06-e1645d02b20f","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G7XyutsUVwLA7X7RznNeCp","type":"tool_result","content":"     1→# Go Best Practices\n     2→\n     3→## Overview\n     4→\n     5→Go-specific best practices and patterns following Go idioms and community standards.\n     6→\n     7→### Core Go Principles\n     8→- **Simplicity over abstraction** - Start simple, add complexity only when needed\n     9→- **Channels for communication** - Don't communicate by sharing memory, share memory by communicating\n    10→- **Errors as values** - Return errors, don't panic\n    11→- **Small interfaces** - The bigger the interface, the weaker the abstraction\n    12→- **Composition over inheritance** - Embed types, don't create hierarchies\n    13→- **Context for cancellation** - Pass context.Context for cancellation and timeouts\n    14→\n    15→## Interface Design\n    16→\n    17→### Small, Focused Interfaces\n    18→\n    19→Follow the Go proverb: \"The bigger the interface, the weaker the abstraction.\"\n    20→\n    21→```go\n    22→// ✅ GOOD: Small interfaces are easier to implement and test\n    23→type PriceProvider interface {\n    24→    GetPrice(symbol string) (decimal.Decimal, error)\n    25→}\n    26→\n    27→type OrderPlacer interface {\n    28→    PlaceOrder(order *Order) (*OrderResult, error)\n    29→}\n    30→\n    31→// ❌ BAD: Large interface with many responsibilities\n    32→type TradingService interface {\n    33→    GetPrice(symbol string) (decimal.Decimal, error)\n    34→    PlaceOrder(order *Order) (*OrderResult, error)\n    35→    CancelOrder(id string) error\n    36→    GetOrderStatus(id string) (*OrderStatus, error)\n    37→    GetBalance(currency string) (decimal.Decimal, error)\n    38→    // ... 20 more methods\n    39→}\n    40→```\n    41→\n    42→## Naming Conventions\n    43→\n    44→### Clear Names Without Unnecessary Abbreviations\n    45→\n    46→```go\n    47→// ❌ BAD: Unclear abbreviations\n    48→cfg, mgr, svc, calc, resp, req\n    49→\n    50→// ✅ GOOD: Clear, full names\n    51→config, manager, service, calculate, response, request\n    52→\n    53→// Exception: Well-known abbreviations are acceptable\n    54→ctx context.Context  // Standard Go abbreviation\n    55→db *sql.DB          // Widely understood\n    56→err error           // Go convention\n    57→```\n    58→\n    59→### Function and Method Names\n    60→\n    61→```go\n    62→// Function names should be self-explanatory\n    63→func CalculatePositionSize(balance, riskPercentage decimal.Decimal) decimal.Decimal\n    64→\n    65→// Avoid redundant package names in functions\n    66→// ❌ BAD\n    67→package order\n    68→func OrderValidator() // order.OrderValidator is redundant\n    69→\n    70→// ✅ GOOD\n    71→package order\n    72→func Validator() // order.Validator is clear\n    73→```\n    74→\n    75→### Receiver Names\n    76→\n    77→Use single-letter receivers for methods:\n    78→\n    79→```go\n    80→// ✅ GOOD: Single letter that represents the type\n    81→func (s *Strategy) Analyze(data MarketData) Signal\n    82→func (c *Config) Validate() error\n    83→func (o *Order) Execute() error\n    84→\n    85→// ❌ BAD: Long receiver names\n    86→func (strategy *Strategy) Analyze(data MarketData) Signal\n    87→func (config *Config) Validate() error\n    88→```\n    89→\n    90→## Error Handling\n    91→\n    92→### Always Check Errors\n    93→\n    94→Never ignore errors, even in deferred functions:\n    95→\n    96→```go\n    97→// ❌ BAD: Ignoring error\n    98→defer file.Close()\n    99→\n   100→// ✅ GOOD: Check error even in defer\n   101→defer func() {\n   102→    if err := file.Close(); err != nil {\n   103→        log.Printf(\"failed to close file: %v\", err)\n   104→    }\n   105→}()\n   106→```\n   107→\n   108→## Concurrency Patterns\n   109→\n   110→### Don't Communicate by Sharing Memory\n   111→\n   112→Follow Go's concurrency philosophy:\n   113→\n   114→```go\n   115→// ❌ BAD: Shared memory with mutex\n   116→type Counter struct {\n   117→    mu    sync.Mutex\n   118→    value int\n   119→}\n   120→\n   121→func (c *Counter) Inc() {\n   122→    c.mu.Lock()\n   123→    c.value++\n   124→    c.mu.Unlock()\n   125→}\n   126→\n   127→// ✅ GOOD: Communicate via channels\n   128→type Counter struct {\n   129→    inc chan int\n   130→    get chan int\n   131→}\n   132→\n   133→func (c *Counter) run() {\n   134→    value := 0\n   135→    for {\n   136→        select {\n   137→        case <-c.inc:\n   138→            value++\n   139→        case c.get <- value:\n   140→        }\n   141→    }\n   142→}\n   143→```\n   144→\n   145→### Context for Cancellation\n   146→\n   147→Always use context for cancellation and timeouts:\n   148→\n   149→```go\n   150→// ✅ GOOD: Respecting context\n   151→func FetchData(ctx context.Context, symbol string) (*Data, error) {\n   152→    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n   153→    if err != nil {\n   154→        return nil, err\n   155→    }\n   156→\n   157→    resp, err := client.Do(req)\n   158→    // ... handle response\n   159→}\n   160→```\n   161→\n   162→## Resource Management\n   163→\n   164→### Defer Cleanup\n   165→\n   166→Always defer cleanup immediately after acquiring resources:\n   167→\n   168→```go\n   169→// ✅ GOOD: Immediate defer\n   170→file, err := os.Open(\"data.txt\")\n   171→if err != nil {\n   172→    return err\n   173→}\n   174→defer file.Close() // Immediately after successful open\n   175→\n   176→// Process file...\n   177→```\n   178→\n   179→### Check Close Errors\n   180→\n   181→Some Close operations can fail and should be checked:\n   182→\n   183→```go\n   184→// ✅ GOOD: Check close error for writers\n   185→func WriteData(filename string, data []byte) error {\n   186→    file, err := os.Create(filename)\n   187→    if err != nil {\n   188→        return err\n   189→    }\n   190→    defer func() {\n   191→        if cerr := file.Close(); cerr != nil && err == nil {\n   192→            err = cerr // Capture close error if no other error\n   193→        }\n   194→    }()\n   195→\n   196→    _, err = file.Write(data)\n   197→    return err\n   198→}\n   199→```\n   200→\n   201→## Testing\n   202→\n   203→### Table-Driven Tests\n   204→\n   205→```go\n   206→func TestCalculatePositionSize(t *testing.T) {\n   207→    tests := []struct {\n   208→        name     string\n   209→        balance  decimal.Decimal\n   210→        risk     decimal.Decimal\n   211→        stopLoss decimal.Decimal\n   212→        want     decimal.Decimal\n   213→        wantErr  bool\n   214→    }{\n   215→        {\n   216→            name:     \"valid inputs\",\n   217→            balance:  decimal.NewFromInt(10000),\n   218→            risk:     decimal.NewFromFloat(0.02),\n   219→            stopLoss: decimal.NewFromInt(100),\n   220→            want:     decimal.NewFromInt(200),\n   221→            wantErr:  false,\n   222→        },\n   223→        {\n   224→            name:     \"negative balance\",\n   225→            balance:  decimal.NewFromInt(-1000),\n   226→            risk:     decimal.NewFromFloat(0.02),\n   227→            stopLoss: decimal.NewFromInt(100),\n   228→            want:     decimal.Zero,\n   229→            wantErr:  true,\n   230→        },\n   231→    }\n   232→\n   233→    for _, tt := range tests {\n   234→        t.Run(tt.name, func(t *testing.T) {\n   235→            got, err := CalculatePositionSize(tt.balance, tt.risk, tt.stopLoss)\n   236→            if (err != nil) != tt.wantErr {\n   237→                t.Errorf(\"error = %v, wantErr %v\", err, tt.wantErr)\n   238→                return\n   239→            }\n   240→            if !got.Equal(tt.want) {\n   241→                t.Errorf(\"got = %v, want %v\", got, tt.want)\n   242→            }\n   243→        })\n   244→    }\n   245→}\n   246→```\n   247→\n   248→### Test Naming\n   249→\n   250→```go\n   251→// Test function names should describe what is being tested\n   252→func TestCalculatePositionSize_WithValidInputs(t *testing.T)\n   253→func TestCalculatePositionSize_WithNegativeBalance(t *testing.T)\n   254→func TestCalculatePositionSize_WithZeroStopLoss(t *testing.T)\n   255→```\n   256→\n   257→## Package Design\n   258→\n   259→### Package Names\n   260→\n   261→- Use singular, lowercase names: `order` not `orders`\n   262→- Avoid generic names like `util`, `common`, `helpers`\n   263→- Package name should describe its purpose\n   264→\n   265→### Package Organization\n   266→\n   267→```\n   268→internal/\n   269→├── trading/          # Domain logic\n   270→│   ├── order.go     # Core types\n   271→│   ├── engine.go    # Business logic\n   272→│   └── order_test.go # Tests next to code\n   273→├── api/             # External integrations\n   274→└── models/          # Data models\n   275→```\n   276→\n   277→## Comments and Documentation\n   278→\n   279→### Package Comments\n   280→\n   281→Every package should have a package comment:\n   282→\n   283→```go\n   284→// Package trading implements the core trading engine.\n   285→// It provides order execution, position management, and risk controls.\n   286→package trading\n   287→```\n   288→\n   289→### Exported Functions\n   290→\n   291→Document all exported functions:\n   292→\n   293→```go\n   294→// CalculatePositionSize determines the appropriate position size based on\n   295→// account balance, risk percentage, and stop loss distance.\n   296→// It returns an error if any input is invalid (negative or zero).\n   297→func CalculatePositionSize(balance, riskPct, stopLoss decimal.Decimal) (decimal.Decimal, error) {\n   298→    // Implementation\n   299→}\n   300→```\n   301→\n   302→## Performance\n   303→\n   304→### Preallocate Slices\n   305→\n   306→When size is known, preallocate:\n   307→\n   308→```go\n   309→// ❌ BAD: Growing slice\n   310→var results []Result\n   311→for _, item := range items {\n   312→    results = append(results, process(item))\n   313→}\n   314→\n   315→// ✅ GOOD: Preallocated\n   316→results := make([]Result, 0, len(items))\n   317→for _, item := range items {\n   318→    results = append(results, process(item))\n   319→}\n   320→```\n   321→\n   322→### String Building\n   323→\n   324→Use strings.Builder for concatenation:\n   325→\n   326→```go\n   327→// ❌ BAD: String concatenation in loop\n   328→var result string\n   329→for _, s := range strings {\n   330→    result += s\n   331→}\n   332→\n   333→// ✅ GOOD: strings.Builder\n   334→var builder strings.Builder\n   335→for _, s := range strings {\n   336→    builder.WriteString(s)\n   337→}\n   338→result := builder.String()\n   339→```\n   340→\n   341→## Common Pitfalls\n   342→\n   343→### Range Variable Capture\n   344→\n   345→```go\n   346→// ❌ BAD: Captures loop variable\n   347→for _, item := range items {\n   348→    go func() {\n   349→        process(item) // Bug: all goroutines get last item\n   350→    }()\n   351→}\n   352→\n   353→// ✅ GOOD: Copy variable\n   354→for _, item := range items {\n   355→    itemCopy := item\n   356→    go func() {\n   357→        process(itemCopy)\n   358→    }()\n   359→}\n   360→```\n   361→\n   362→### Nil Interface Values\n   363→\n   364→```go\n   365→// ❌ BAD: Can cause nil pointer panic\n   366→var err *MyError\n   367→if condition {\n   368→    err = &MyError{\"something went wrong\"}\n   369→}\n   370→return err // Returns non-nil interface with nil value\n   371→\n   372→// ✅ GOOD: Return explicit nil\n   373→if condition {\n   374→    return &MyError{\"something went wrong\"}\n   375→}\n   376→return nil\n   377→```\n   378→\n   379→### Logger and Error Framework\n   380→```go\n   381→// Initialize logger at application start\n   382→func main() {\n   383→    if err := logger.InitZap(os.Getenv(\"LOG_LEVEL\"), os.Getenv(\"BIGMEANIE_DEV\") == \"true\"); err != nil {\n   384→        panic(fmt.Sprintf(\"failed to initialize logger: %v\", err))\n   385→    }\n   386→    defer logger.Sync() // Flush any buffered logs on exit\n   387→\n   388→    // Component-specific loggers\n   389→    log := logger.Component(\"main\")\n   390→    log.Info(\"Starting BigMeanie trading system\")\n   391→}\n   392→\n   393→// Structured error handling\n   394→func LoadCandles(symbol string, timeframe string) ([]Candle, error) {\n   395→    log := logger.Data()\n   396→\n   397→    candles, err := db.Query(\"SELECT * FROM candles WHERE symbol = ? AND timeframe = ?\", symbol, timeframe)\n   398→    if err != nil {\n   399→        return nil, errors.Wrap(\"LoadCandles\", errors.ErrTypeData, err).\n   400→            WithSymbol(symbol).\n   401→            WithContext(\"timeframe\", timeframe)\n   402→    }\n   403→\n   404→    log.LogDataOperation(\"candles_loaded\", len(candles),\n   405→        \"symbol\", symbol,\n   406→        \"timeframe\", timeframe)\n   407→\n   408→    return candles, nil\n   409→}\n   410→```\n   411→\n   412→### Worker Pool Pattern\n   413→```go\n   414→// Go way: channels ARE the queue\n   415→func RunWorkerPool(ctx context.Context, numWorkers int) {\n   416→    jobs := make(chan Job, 100)\n   417→    results := make(chan Result, 100)\n   418→\n   419→    // Start workers\n   420→    var wg sync.WaitGroup\n   421→    for i := 0; i < numWorkers; i++ {\n   422→        wg.Add(1)\n   423→        go func(id int) {\n   424→            defer wg.Done()\n   425→            runWorker(ctx, id, jobs, results)\n   426→        }(i)\n   427→    }\n   428→\n   429→    // Feed jobs\n   430→    go func() {\n   431→        for _, job := range getAllJobs() {\n   432→            select {\n   433→            case jobs <- job:\n   434→            case <-ctx.Done():\n   435→                return\n   436→            }\n   437→        }\n   438→        close(jobs)\n   439→    }()\n   440→\n   441→    wg.Wait()\n   442→    close(results)\n   443→}\n   444→```\n   445→\n   446→### Options Pattern\n   447→```go\n   448→// Functional options for clean APIs\n   449→type WorkerOption func(*Worker)\n   450→\n   451→func WithRetries(max int) WorkerOption {\n   452→    return func(w *Worker) {\n   453→        w.maxRetries = max\n   454→    }\n   455→}\n   456→\n   457→func WithTimeout(d time.Duration) WorkerOption {\n   458→    return func(w *Worker) {\n   459→        w.timeout = d\n   460→    }\n   461→}\n   462→\n   463→func NewWorker(id string, opts ...WorkerOption) *Worker {\n   464→    // Defaults\n   465→    w := &Worker{\n   466→        id:         id,\n   467→        maxRetries: 3,\n   468→        timeout:    5 * time.Minute,\n   469→    }\n   470→\n   471→    // Apply options\n   472→    for _, opt := range opts {\n   473→        opt(w)\n   474→    }\n   475→\n   476→    return w\n   477→}\n   478→\n   479→// Clean usage\n   480→worker := NewWorker(\"worker-1\",\n   481→    WithRetries(5),\n   482→    WithTimeout(10*time.Minute))\n   483→```\n   484→\n   485→### Table-Driven Tests\n   486→```go\n   487→func TestParameterGeneration(t *testing.T) {\n   488→    tests := []struct {\n   489→        name     string\n   490→        strategy string\n   491→        markets  []string\n   492→        want     int\n   493→        wantErr  bool\n   494→    }{\n   495→        {\n   496→            name:     \"simple strategy\",\n   497→            strategy: \"surfer\",\n   498→            markets:  []string{\"BTC-USD\"},\n   499→            want:     10,\n   500→        },\n   501→        {\n   502→            name:     \"multiple markets\",\n   503→            strategy: \"surfer\",\n   504→            markets:  []string{\"BTC-USD\", \"ETH-USD\"},\n   505→            want:     20,\n   506→        },\n   507→        {\n   508→            name:     \"invalid strategy\",\n   509→            strategy: \"unknown\",\n   510→            wantErr:  true,\n   511→        },\n   512→    }\n   513→\n   514→    for _, tt := range tests {\n   515→        t.Run(tt.name, func(t *testing.T) {\n   516→            got, err := GenerateParameters(tt.strategy, tt.markets)\n   517→            if (err != nil) != tt.wantErr {\n   518→                t.Errorf(\"GenerateParameters() error = %v, wantErr %v\", err, tt.wantErr)\n   519→                return\n   520→            }\n   521→            if len(got) != tt.want {\n   522→                t.Errorf(\"GenerateParameters() returned %d combinations, want %d\", len(got), tt.want)\n   523→            }\n   524→        })\n   525→    }\n   526→}\n   527→```\n   528→\n   529→### Error Handling\n   530→```go\n   531→// Wrap errors with context\n   532→func processJob(job Job) (Result, error) {\n   533→    if err := validateJob(job); err != nil {\n   534→        return Result{}, fmt.Errorf(\"validation failed: %w\", err)\n   535→    }\n   536→\n   537→    data, err := fetchData(job.Symbol, job.Timeframe)\n   538→    if err != nil {\n   539→        return Result{}, fmt.Errorf(\"fetch data for %s: %w\", job.Symbol, err)\n   540→    }\n   541→\n   542→    result, err := runBacktest(data, job.Parameters)\n   543→    if err != nil {\n   544→        return Result{}, fmt.Errorf(\"backtest failed: %w\", err)\n   545→    }\n   546→\n   547→    return result, nil\n   548→}\n   549→\n   550→// Check errors immediately\n   551→if err := processJob(job); err != nil {\n   552→    log.LogError(\"Job failed\", err, \"job_id\", job.ID)\n   553→    return\n   554→}\n   555→```\n   556→\n   557→### Resource Management with Defer\n   558→```go\n   559→func (w *Worker) Execute(ctx context.Context, job Job) error {\n   560→    // Acquire resources\n   561→    conn := dbPool.Get()\n   562→    defer dbPool.Put(conn)  // Always return to pool\n   563→\n   564→    // Create checkpoint\n   565→    checkpoint := newCheckpoint(w.id)\n   566→    defer func() {\n   567→        if err := checkpoint.Save(); err != nil {\n   568→            log.LogError(\"Failed to save checkpoint\", err)\n   569→        }\n   570→    }()\n   571→\n   572→    // Do actual work\n   573→    return w.process(ctx, job)\n   574→}\n   575→```\n   576→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3bf6074f-fddd-4cff-9149-a36ed42c75e7","timestamp":"2025-08-13T06:34:52.115Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md","content":"# Go Best Practices\n\n## Overview\n\nGo-specific best practices and patterns following Go idioms and community standards.\n\n### Core Go Principles\n- **Simplicity over abstraction** - Start simple, add complexity only when needed\n- **Channels for communication** - Don't communicate by sharing memory, share memory by communicating\n- **Errors as values** - Return errors, don't panic\n- **Small interfaces** - The bigger the interface, the weaker the abstraction\n- **Composition over inheritance** - Embed types, don't create hierarchies\n- **Context for cancellation** - Pass context.Context for cancellation and timeouts\n\n## Interface Design\n\n### Small, Focused Interfaces\n\nFollow the Go proverb: \"The bigger the interface, the weaker the abstraction.\"\n\n```go\n// ✅ GOOD: Small interfaces are easier to implement and test\ntype PriceProvider interface {\n    GetPrice(symbol string) (decimal.Decimal, error)\n}\n\ntype OrderPlacer interface {\n    PlaceOrder(order *Order) (*OrderResult, error)\n}\n\n// ❌ BAD: Large interface with many responsibilities\ntype TradingService interface {\n    GetPrice(symbol string) (decimal.Decimal, error)\n    PlaceOrder(order *Order) (*OrderResult, error)\n    CancelOrder(id string) error\n    GetOrderStatus(id string) (*OrderStatus, error)\n    GetBalance(currency string) (decimal.Decimal, error)\n    // ... 20 more methods\n}\n```\n\n## Naming Conventions\n\n### Clear Names Without Unnecessary Abbreviations\n\n```go\n// ❌ BAD: Unclear abbreviations\ncfg, mgr, svc, calc, resp, req\n\n// ✅ GOOD: Clear, full names\nconfig, manager, service, calculate, response, request\n\n// Exception: Well-known abbreviations are acceptable\nctx context.Context  // Standard Go abbreviation\ndb *sql.DB          // Widely understood\nerr error           // Go convention\n```\n\n### Function and Method Names\n\n```go\n// Function names should be self-explanatory\nfunc CalculatePositionSize(balance, riskPercentage decimal.Decimal) decimal.Decimal\n\n// Avoid redundant package names in functions\n// ❌ BAD\npackage order\nfunc OrderValidator() // order.OrderValidator is redundant\n\n// ✅ GOOD\npackage order\nfunc Validator() // order.Validator is clear\n```\n\n### Receiver Names\n\nUse single-letter receivers for methods:\n\n```go\n// ✅ GOOD: Single letter that represents the type\nfunc (s *Strategy) Analyze(data MarketData) Signal\nfunc (c *Config) Validate() error\nfunc (o *Order) Execute() error\n\n// ❌ BAD: Long receiver names\nfunc (strategy *Strategy) Analyze(data MarketData) Signal\nfunc (config *Config) Validate() error\n```\n\n## Error Handling\n\n### Always Check Errors\n\nNever ignore errors, even in deferred functions:\n\n```go\n// ❌ BAD: Ignoring error\ndefer file.Close()\n\n// ✅ GOOD: Check error even in defer\ndefer func() {\n    if err := file.Close(); err != nil {\n        log.Printf(\"failed to close file: %v\", err)\n    }\n}()\n```\n\n## Concurrency Patterns\n\n### Don't Communicate by Sharing Memory\n\nFollow Go's concurrency philosophy:\n\n```go\n// ❌ BAD: Shared memory with mutex\ntype Counter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    c.value++\n    c.mu.Unlock()\n}\n\n// ✅ GOOD: Communicate via channels\ntype Counter struct {\n    inc chan int\n    get chan int\n}\n\nfunc (c *Counter) run() {\n    value := 0\n    for {\n        select {\n        case <-c.inc:\n            value++\n        case c.get <- value:\n        }\n    }\n}\n```\n\n### Context for Cancellation\n\nAlways use context for cancellation and timeouts:\n\n```go\n// ✅ GOOD: Respecting context\nfunc FetchData(ctx context.Context, symbol string) (*Data, error) {\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n\n    resp, err := client.Do(req)\n    // ... handle response\n}\n```\n\n## Resource Management\n\n### Defer Cleanup\n\nAlways defer cleanup immediately after acquiring resources:\n\n```go\n// ✅ GOOD: Immediate defer\nfile, err := os.Open(\"data.txt\")\nif err != nil {\n    return err\n}\ndefer file.Close() // Immediately after successful open\n\n// Process file...\n```\n\n### Check Close Errors\n\nSome Close operations can fail and should be checked:\n\n```go\n// ✅ GOOD: Check close error for writers\nfunc WriteData(filename string, data []byte) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if cerr := file.Close(); cerr != nil && err == nil {\n            err = cerr // Capture close error if no other error\n        }\n    }()\n\n    _, err = file.Write(data)\n    return err\n}\n```\n\n## Testing\n\n### Table-Driven Tests\n\n```go\nfunc TestCalculatePositionSize(t *testing.T) {\n    tests := []struct {\n        name     string\n        balance  decimal.Decimal\n        risk     decimal.Decimal\n        stopLoss decimal.Decimal\n        want     decimal.Decimal\n        wantErr  bool\n    }{\n        {\n            name:     \"valid inputs\",\n            balance:  decimal.NewFromInt(10000),\n            risk:     decimal.NewFromFloat(0.02),\n            stopLoss: decimal.NewFromInt(100),\n            want:     decimal.NewFromInt(200),\n            wantErr:  false,\n        },\n        {\n            name:     \"negative balance\",\n            balance:  decimal.NewFromInt(-1000),\n            risk:     decimal.NewFromFloat(0.02),\n            stopLoss: decimal.NewFromInt(100),\n            want:     decimal.Zero,\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := CalculatePositionSize(tt.balance, tt.risk, tt.stopLoss)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if !got.Equal(tt.want) {\n                t.Errorf(\"got = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\n### Test Naming\n\n```go\n// Test function names should describe what is being tested\nfunc TestCalculatePositionSize_WithValidInputs(t *testing.T)\nfunc TestCalculatePositionSize_WithNegativeBalance(t *testing.T)\nfunc TestCalculatePositionSize_WithZeroStopLoss(t *testing.T)\n```\n\n## Package Design\n\n### Package Names\n\n- Use singular, lowercase names: `order` not `orders`\n- Avoid generic names like `util`, `common`, `helpers`\n- Package name should describe its purpose\n\n### Package Organization\n\n```\ninternal/\n├── trading/          # Domain logic\n│   ├── order.go     # Core types\n│   ├── engine.go    # Business logic\n│   └── order_test.go # Tests next to code\n├── api/             # External integrations\n└── models/          # Data models\n```\n\n## Comments and Documentation\n\n### Package Comments\n\nEvery package should have a package comment:\n\n```go\n// Package trading implements the core trading engine.\n// It provides order execution, position management, and risk controls.\npackage trading\n```\n\n### Exported Functions\n\nDocument all exported functions:\n\n```go\n// CalculatePositionSize determines the appropriate position size based on\n// account balance, risk percentage, and stop loss distance.\n// It returns an error if any input is invalid (negative or zero).\nfunc CalculatePositionSize(balance, riskPct, stopLoss decimal.Decimal) (decimal.Decimal, error) {\n    // Implementation\n}\n```\n\n## Performance\n\n### Preallocate Slices\n\nWhen size is known, preallocate:\n\n```go\n// ❌ BAD: Growing slice\nvar results []Result\nfor _, item := range items {\n    results = append(results, process(item))\n}\n\n// ✅ GOOD: Preallocated\nresults := make([]Result, 0, len(items))\nfor _, item := range items {\n    results = append(results, process(item))\n}\n```\n\n### String Building\n\nUse strings.Builder for concatenation:\n\n```go\n// ❌ BAD: String concatenation in loop\nvar result string\nfor _, s := range strings {\n    result += s\n}\n\n// ✅ GOOD: strings.Builder\nvar builder strings.Builder\nfor _, s := range strings {\n    builder.WriteString(s)\n}\nresult := builder.String()\n```\n\n## Common Pitfalls\n\n### Range Variable Capture\n\n```go\n// ❌ BAD: Captures loop variable\nfor _, item := range items {\n    go func() {\n        process(item) // Bug: all goroutines get last item\n    }()\n}\n\n// ✅ GOOD: Copy variable\nfor _, item := range items {\n    itemCopy := item\n    go func() {\n        process(itemCopy)\n    }()\n}\n```\n\n### Nil Interface Values\n\n```go\n// ❌ BAD: Can cause nil pointer panic\nvar err *MyError\nif condition {\n    err = &MyError{\"something went wrong\"}\n}\nreturn err // Returns non-nil interface with nil value\n\n// ✅ GOOD: Return explicit nil\nif condition {\n    return &MyError{\"something went wrong\"}\n}\nreturn nil\n```\n\n### Logger and Error Framework\n```go\n// Initialize logger at application start\nfunc main() {\n    if err := logger.InitZap(os.Getenv(\"LOG_LEVEL\"), os.Getenv(\"BIGMEANIE_DEV\") == \"true\"); err != nil {\n        panic(fmt.Sprintf(\"failed to initialize logger: %v\", err))\n    }\n    defer logger.Sync() // Flush any buffered logs on exit\n\n    // Component-specific loggers\n    log := logger.Component(\"main\")\n    log.Info(\"Starting BigMeanie trading system\")\n}\n\n// Structured error handling\nfunc LoadCandles(symbol string, timeframe string) ([]Candle, error) {\n    log := logger.Data()\n\n    candles, err := db.Query(\"SELECT * FROM candles WHERE symbol = ? AND timeframe = ?\", symbol, timeframe)\n    if err != nil {\n        return nil, errors.Wrap(\"LoadCandles\", errors.ErrTypeData, err).\n            WithSymbol(symbol).\n            WithContext(\"timeframe\", timeframe)\n    }\n\n    log.LogDataOperation(\"candles_loaded\", len(candles),\n        \"symbol\", symbol,\n        \"timeframe\", timeframe)\n\n    return candles, nil\n}\n```\n\n### Worker Pool Pattern\n```go\n// Go way: channels ARE the queue\nfunc RunWorkerPool(ctx context.Context, numWorkers int) {\n    jobs := make(chan Job, 100)\n    results := make(chan Result, 100)\n\n    // Start workers\n    var wg sync.WaitGroup\n    for i := 0; i < numWorkers; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            runWorker(ctx, id, jobs, results)\n        }(i)\n    }\n\n    // Feed jobs\n    go func() {\n        for _, job := range getAllJobs() {\n            select {\n            case jobs <- job:\n            case <-ctx.Done():\n                return\n            }\n        }\n        close(jobs)\n    }()\n\n    wg.Wait()\n    close(results)\n}\n```\n\n### Options Pattern\n```go\n// Functional options for clean APIs\ntype WorkerOption func(*Worker)\n\nfunc WithRetries(max int) WorkerOption {\n    return func(w *Worker) {\n        w.maxRetries = max\n    }\n}\n\nfunc WithTimeout(d time.Duration) WorkerOption {\n    return func(w *Worker) {\n        w.timeout = d\n    }\n}\n\nfunc NewWorker(id string, opts ...WorkerOption) *Worker {\n    // Defaults\n    w := &Worker{\n        id:         id,\n        maxRetries: 3,\n        timeout:    5 * time.Minute,\n    }\n\n    // Apply options\n    for _, opt := range opts {\n        opt(w)\n    }\n\n    return w\n}\n\n// Clean usage\nworker := NewWorker(\"worker-1\",\n    WithRetries(5),\n    WithTimeout(10*time.Minute))\n```\n\n### Table-Driven Tests\n```go\nfunc TestParameterGeneration(t *testing.T) {\n    tests := []struct {\n        name     string\n        strategy string\n        markets  []string\n        want     int\n        wantErr  bool\n    }{\n        {\n            name:     \"simple strategy\",\n            strategy: \"surfer\",\n            markets:  []string{\"BTC-USD\"},\n            want:     10,\n        },\n        {\n            name:     \"multiple markets\",\n            strategy: \"surfer\",\n            markets:  []string{\"BTC-USD\", \"ETH-USD\"},\n            want:     20,\n        },\n        {\n            name:     \"invalid strategy\",\n            strategy: \"unknown\",\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := GenerateParameters(tt.strategy, tt.markets)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"GenerateParameters() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if len(got) != tt.want {\n                t.Errorf(\"GenerateParameters() returned %d combinations, want %d\", len(got), tt.want)\n            }\n        })\n    }\n}\n```\n\n### Error Handling\n```go\n// Wrap errors with context\nfunc processJob(job Job) (Result, error) {\n    if err := validateJob(job); err != nil {\n        return Result{}, fmt.Errorf(\"validation failed: %w\", err)\n    }\n\n    data, err := fetchData(job.Symbol, job.Timeframe)\n    if err != nil {\n        return Result{}, fmt.Errorf(\"fetch data for %s: %w\", job.Symbol, err)\n    }\n\n    result, err := runBacktest(data, job.Parameters)\n    if err != nil {\n        return Result{}, fmt.Errorf(\"backtest failed: %w\", err)\n    }\n\n    return result, nil\n}\n\n// Check errors immediately\nif err := processJob(job); err != nil {\n    log.LogError(\"Job failed\", err, \"job_id\", job.ID)\n    return\n}\n```\n\n### Resource Management with Defer\n```go\nfunc (w *Worker) Execute(ctx context.Context, job Job) error {\n    // Acquire resources\n    conn := dbPool.Get()\n    defer dbPool.Put(conn)  // Always return to pool\n\n    // Create checkpoint\n    checkpoint := newCheckpoint(w.id)\n    defer func() {\n        if err := checkpoint.Save(); err != nil {\n            log.LogError(\"Failed to save checkpoint\", err)\n        }\n    }()\n\n    // Do actual work\n    return w.process(ctx, job)\n}\n```\n","numLines":576,"startLine":1,"totalLines":576}}}
{"parentUuid":"3bf6074f-fddd-4cff-9149-a36ed42c75e7","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_017FzweHikd4vmXvYxcdR1zx","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now let me check what other documentation might already exist in the code directory:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5942,"cache_read_input_tokens":32311,"output_tokens":86,"service_tier":"standard"}},"requestId":"req_011CS5F7WcJTuYkh9pSAhVRQ","type":"assistant","uuid":"826bd1a8-e2bc-48eb-a7ba-74b578774edb","timestamp":"2025-08-13T06:34:56.092Z"}
{"parentUuid":"826bd1a8-e2bc-48eb-a7ba-74b578774edb","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_017FzweHikd4vmXvYxcdR1zx","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01TDUPt3RcTJkzo5QZmGgNh2","name":"Glob","input":{"pattern":"/home/aural/Code/bigmeanie/back/.docs/code/*.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5942,"cache_read_input_tokens":32311,"output_tokens":86,"service_tier":"standard"}},"requestId":"req_011CS5F7WcJTuYkh9pSAhVRQ","type":"assistant","uuid":"be0a85a7-a4ba-43e9-88e2-2c60f495f5ac","timestamp":"2025-08-13T06:34:56.926Z"}
{"parentUuid":"be0a85a7-a4ba-43e9-88e2-2c60f495f5ac","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TDUPt3RcTJkzo5QZmGgNh2","type":"tool_result","content":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md"}]},"uuid":"5a6cfbcc-c702-435e-988e-8d8961db585a","timestamp":"2025-08-13T06:34:56.964Z","toolUseResult":{"filenames":["/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md"],"durationMs":8,"numFiles":1,"truncated":false}}
{"parentUuid":"5a6cfbcc-c702-435e-988e-8d8961db585a","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01RSxoaUkLFGQZ86oQom3B5M","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Good! Now I'll create a comprehensive set of Go documentation files. Let me create an organized structure covering all aspects of Go programming:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":120,"cache_read_input_tokens":38253,"output_tokens":9561,"service_tier":"standard"}},"requestId":"req_011CS5F7sBYykTadTW9Nmxfh","type":"assistant","uuid":"d87d2f49-3718-4378-8063-5d92a96036bf","timestamp":"2025-08-13T06:35:01.025Z"}
{"parentUuid":"d87d2f49-3718-4378-8063-5d92a96036bf","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01RSxoaUkLFGQZ86oQom3B5M","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01EXyMcGSAYAn6qFm4YEug7s","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/01-core-language.md","content":"# Go Core Language Features - Complete Guide\n\n## Table of Contents\n1. [Basic Syntax and Types](#basic-syntax-and-types)\n2. [Control Flow](#control-flow)\n3. [Functions](#functions)\n4. [Methods and Interfaces](#methods-and-interfaces)\n5. [Goroutines and Channels](#goroutines-and-channels)\n6. [Packages and Modules](#packages-and-modules)\n7. [Type System Deep Dive](#type-system-deep-dive)\n8. [Memory Model](#memory-model)\n\n## Basic Syntax and Types\n\n### Variables and Constants\n\n```go\n// Variable declarations\nvar x int                      // Zero value: 0\nvar y = 42                     // Type inference\nvar z int = 100                // Explicit type\nvar a, b, c int                // Multiple variables\nvar (                          // Variable block\n    name string = \"Go\"\n    version float64 = 1.21\n    stable bool = true\n)\n\n// Short variable declaration (only inside functions)\ncount := 10                    // Type inferred as int\nmessage := \"Hello\"              // Type inferred as string\npi := 3.14159                  // Type inferred as float64\n\n// Constants\nconst Pi = 3.14159             // Untyped constant\nconst (\n    StatusOK = 200\n    StatusNotFound = 404\n)\nconst typedConst int64 = 100   // Typed constant\n\n// Iota - constant generator\nconst (\n    Sunday = iota  // 0\n    Monday         // 1\n    Tuesday        // 2\n    Wednesday      // 3\n    Thursday       // 4\n    Friday         // 5\n    Saturday       // 6\n)\n\n// Bit flags with iota\nconst (\n    ReadPermission = 1 << iota  // 1\n    WritePermission              // 2\n    ExecutePermission            // 4\n)\n```\n\n### Basic Types\n\n```go\n// Boolean\nvar active bool = true\nvar deleted bool  // Zero value: false\n\n// Numeric types\nvar (\n    // Integers\n    i8  int8   = -128                    // -128 to 127\n    i16 int16  = -32768                  // -32,768 to 32,767\n    i32 int32  = -2147483648              // -2,147,483,648 to 2,147,483,647\n    i64 int64  = -9223372036854775808    // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n    i   int    = -1                      // Platform dependent (32 or 64 bit)\n    \n    // Unsigned integers\n    u8  uint8  = 255                     // 0 to 255 (byte is alias)\n    u16 uint16 = 65535                   // 0 to 65,535\n    u32 uint32 = 4294967295               // 0 to 4,294,967,295\n    u64 uint64 = 18446744073709551615    // 0 to 18,446,744,073,709,551,615\n    u   uint   = 1                       // Platform dependent\n    \n    // Floating point\n    f32 float32 = 3.14                   // IEEE-754 32-bit\n    f64 float64 = 3.141592653589793      // IEEE-754 64-bit\n    \n    // Complex numbers\n    c64  complex64  = 1 + 2i             // float32 real and imaginary\n    c128 complex128 = 1 + 2i             // float64 real and imaginary\n    \n    // Aliases\n    b byte = 255                         // alias for uint8\n    r rune = 'A'                         // alias for int32 (Unicode code point)\n    \n    // Pointer types\n    ptr *int                             // Pointer to int\n    uptr uintptr                         // Integer representation of pointer\n)\n\n// String type\nvar (\n    name string = \"Gopher\"\n    multiline = `This is\na multiline\nstring`\n    empty string  // Zero value: \"\"\n)\n\n// Type conversions (no implicit conversions in Go)\nvar x int = 42\nvar y float64 = float64(x)\nvar z uint = uint(y)\nvar s string = string(65)  // \"A\" (Unicode code point)\n```\n\n### Composite Types\n\n```go\n// Arrays - fixed size\nvar arr1 [5]int                     // Zero value: [0 0 0 0 0]\narr2 := [5]int{1, 2, 3, 4, 5}\narr3 := [...]int{1, 2, 3}           // Compiler counts elements\narr4 := [5]int{0: 10, 4: 50}        // Sparse initialization\n\n// Slices - dynamic arrays\nvar slice1 []int                    // Zero value: nil\nslice2 := []int{1, 2, 3}\nslice3 := make([]int, 5)            // Length 5, capacity 5\nslice4 := make([]int, 5, 10)        // Length 5, capacity 10\nslice5 := arr2[1:4]                 // Slice from array [2 3 4]\n\n// Slice operations\nappend(slice2, 4, 5)                // Append elements\ncopy(dst, src)                      // Copy elements\nlen(slice2)                         // Length\ncap(slice2)                         // Capacity\n\n// Maps - hash tables\nvar map1 map[string]int             // Zero value: nil\nmap2 := make(map[string]int)\nmap3 := map[string]int{\n    \"apple\":  5,\n    \"banana\": 3,\n}\n\n// Map operations\nmap3[\"orange\"] = 7                  // Insert/update\ndelete(map3, \"banana\")               // Delete\nvalue, exists := map3[\"apple\"]      // Lookup with existence check\n\n// Structs - grouped data\ntype Person struct {\n    Name string\n    Age  int\n    Email string `json:\"email\" validate:\"required,email\"`  // Tags\n}\n\nvar person1 Person                  // Zero value: {\"\" 0 \"\"}\nperson2 := Person{\n    Name: \"Alice\",\n    Age:  30,\n    Email: \"alice@example.com\",\n}\nperson3 := Person{\"Bob\", 25, \"bob@example.com\"}  // Positional\n\n// Anonymous structs\nconfig := struct {\n    Host string\n    Port int\n}{\n    Host: \"localhost\",\n    Port: 8080,\n}\n\n// Embedded structs\ntype Employee struct {\n    Person              // Embedded\n    Department string\n    Salary     float64\n}\n\n// Pointers\nvar p *int\ni := 42\np = &i          // Address of i\nfmt.Println(*p) // Dereference: 42\n*p = 21         // Set through pointer\n\n// Pointer to struct\npersonPtr := &Person{Name: \"Charlie\", Age: 35}\npersonPtr.Name = \"Chuck\"  // Automatic dereference\n```\n\n## Control Flow\n\n### Conditionals\n\n```go\n// If statement\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else if x < 0 {\n    fmt.Println(\"Negative\")\n} else {\n    fmt.Println(\"Zero\")\n}\n\n// If with initialization\nif err := doSomething(); err != nil {\n    return err\n}\n\n// If with type assertion\nif str, ok := value.(string); ok {\n    fmt.Println(\"String value:\", str)\n}\n\n// Switch statement\nswitch day {\ncase \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\":\n    fmt.Println(\"Weekday\")\ncase \"Saturday\", \"Sunday\":\n    fmt.Println(\"Weekend\")\ndefault:\n    fmt.Println(\"Invalid day\")\n}\n\n// Switch with initialization\nswitch hour := time.Now().Hour(); {\ncase hour < 12:\n    fmt.Println(\"Morning\")\ncase hour < 17:\n    fmt.Println(\"Afternoon\")\ndefault:\n    fmt.Println(\"Evening\")\n}\n\n// Type switch\nswitch v := value.(type) {\ncase int:\n    fmt.Printf(\"Integer: %d\\n\", v)\ncase string:\n    fmt.Printf(\"String: %s\\n\", v)\ncase bool:\n    fmt.Printf(\"Boolean: %t\\n\", v)\ndefault:\n    fmt.Printf(\"Unknown type: %T\\n\", v)\n}\n\n// Fallthrough in switch\nswitch score {\ncase 100:\n    fmt.Println(\"Perfect!\")\n    fallthrough\ncase 90, 91, 92, 93, 94, 95, 96, 97, 98, 99:\n    fmt.Println(\"A grade\")\ndefault:\n    fmt.Println(\"Keep trying\")\n}\n```\n\n### Loops\n\n```go\n// For loop - traditional\nfor i := 0; i < 10; i++ {\n    fmt.Println(i)\n}\n\n// For loop - while style\ncount := 0\nfor count < 10 {\n    fmt.Println(count)\n    count++\n}\n\n// Infinite loop\nfor {\n    // Break or return to exit\n    if condition {\n        break\n    }\n}\n\n// Range over slice\nslice := []int{1, 2, 3, 4, 5}\nfor index, value := range slice {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n\n// Range over map\nm := map[string]int{\"a\": 1, \"b\": 2}\nfor key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Range over string (iterates over runes)\nfor index, runeValue := range \"Hello, 世界\" {\n    fmt.Printf(\"%d: %c\\n\", index, runeValue)\n}\n\n// Range over channel\nch := make(chan int)\ngo func() {\n    for i := 0; i < 5; i++ {\n        ch <- i\n    }\n    close(ch)\n}()\nfor value := range ch {\n    fmt.Println(value)\n}\n\n// Continue and break with labels\nouter:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        if i == 1 && j == 1 {\n            continue outer  // Continue outer loop\n        }\n        if i == 2 && j == 2 {\n            break outer     // Break from outer loop\n        }\n        fmt.Printf(\"(%d,%d) \", i, j)\n    }\n}\n```\n\n### Defer, Panic, and Recover\n\n```go\n// Defer - executes at function exit (LIFO order)\nfunc example() {\n    defer fmt.Println(\"Third\")\n    defer fmt.Println(\"Second\")\n    defer fmt.Println(\"First\")\n    fmt.Println(\"Main function\")\n    // Output: Main function, First, Second, Third\n}\n\n// Defer for cleanup\nfunc readFile(filename string) ([]byte, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return nil, err\n    }\n    defer file.Close()  // Ensures file is closed\n    \n    return ioutil.ReadAll(file)\n}\n\n// Defer with error handling\nfunc writeFile(filename string, data []byte) (err error) {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if cerr := file.Close(); cerr != nil && err == nil {\n            err = cerr  // Capture close error\n        }\n    }()\n    \n    _, err = file.Write(data)\n    return err\n}\n\n// Panic - runtime error\nfunc mustPositive(n int) {\n    if n <= 0 {\n        panic(fmt.Sprintf(\"n must be positive, got %d\", n))\n    }\n}\n\n// Recover - catch panic\nfunc safeFunction() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Recovered from panic: %v\\n\", r)\n        }\n    }()\n    \n    // Code that might panic\n    riskyOperation()\n}\n\n// Structured panic/recover pattern\nfunc robustFunction() (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    \n    // Risky operations\n    return nil\n}\n```\n\n## Functions\n\n### Function Declarations\n\n```go\n// Basic function\nfunc add(x, y int) int {\n    return x + y\n}\n\n// Multiple return values\nfunc divmod(a, b int) (quotient, remainder int) {\n    return a / b, a % b\n}\n\n// Named return values\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return  // Naked return\n}\n\n// Variadic functions\nfunc sum(nums ...int) int {\n    total := 0\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n\n// Call variadic function\nresult := sum(1, 2, 3, 4, 5)\nslice := []int{1, 2, 3}\nresult = sum(slice...)  // Expand slice\n\n// Function as parameter\nfunc apply(fn func(int, int) int, a, b int) int {\n    return fn(a, b)\n}\n\nresult = apply(add, 5, 3)\n\n// Function returning function\nfunc multiplier(factor int) func(int) int {\n    return func(x int) int {\n        return x * factor\n    }\n}\n\ndouble := multiplier(2)\nfmt.Println(double(5))  // 10\n\n// Anonymous functions\nfunc() {\n    fmt.Println(\"Anonymous function\")\n}()\n\n// Function type\ntype Operation func(int, int) int\n\nvar op Operation = add\nresult = op(10, 5)\n\n// Method expression\ntype Calculator struct{}\nfunc (c Calculator) Add(x, y int) int { return x + y }\n\nvar calc Calculator\nfn := Calculator.Add  // Method expression\nresult = fn(calc, 3, 4)\n\n// Method value\nfn2 := calc.Add  // Method value\nresult = fn2(3, 4)\n```\n\n### Closures\n\n```go\n// Closure capturing variables\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nc := counter()\nfmt.Println(c())  // 1\nfmt.Println(c())  // 2\nfmt.Println(c())  // 3\n\n// Closure in loop (common pitfall)\nvar funcs []func()\n\n// Wrong - captures loop variable\nfor i := 0; i < 3; i++ {\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // All print 3\n    })\n}\n\n// Correct - capture copy\nfor i := 0; i < 3; i++ {\n    i := i  // Shadow with new variable\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // Prints 0, 1, 2\n    })\n}\n\n// Fibonacci closure\nfunc fibonacci() func() int {\n    a, b := 0, 1\n    return func() int {\n        a, b = b, a+b\n        return a\n    }\n}\n```\n\n## Methods and Interfaces\n\n### Methods\n\n```go\n// Method with value receiver\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\n// Method with pointer receiver\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n\n// Method on non-struct types\ntype MyInt int\n\nfunc (m MyInt) IsPositive() bool {\n    return m > 0\n}\n\n// Method set rules\nrect := Rectangle{10, 5}\nrect.Area()        // OK - value receiver\nrect.Scale(2)      // OK - Go automatically takes address\n\nrectPtr := &Rectangle{10, 5}\nrectPtr.Area()     // OK - Go automatically dereferences\nrectPtr.Scale(2)   // OK - pointer receiver\n\n// Method chaining\ntype Builder struct {\n    str strings.Builder\n}\n\nfunc (b *Builder) Add(s string) *Builder {\n    b.str.WriteString(s)\n    return b\n}\n\nfunc (b *Builder) Build() string {\n    return b.str.String()\n}\n\nresult := (&Builder{}).Add(\"Hello\").Add(\" \").Add(\"World\").Build()\n```\n\n### Interfaces\n\n```go\n// Interface definition\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\n// Interface composition\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\n// Empty interface\nvar any interface{}  // Can hold any value\nany = 42\nany = \"hello\"\nany = []int{1, 2, 3}\n\n// Type assertion\nvalue := any.(string)  // Panics if not string\nvalue, ok := any.(string)  // Safe assertion\n\n// Type switch\nswitch v := any.(type) {\ncase int:\n    fmt.Printf(\"Integer: %d\\n\", v)\ncase string:\n    fmt.Printf(\"String: %s\\n\", v)\ncase []int:\n    fmt.Printf(\"Int slice: %v\\n\", v)\n}\n\n// Interface satisfaction (implicit)\ntype MyWriter struct{}\n\nfunc (w MyWriter) Write(p []byte) (int, error) {\n    fmt.Print(string(p))\n    return len(p), nil\n}\n\nvar w Writer = MyWriter{}  // Satisfies Writer interface\n\n// Common interfaces\ntype Stringer interface {\n    String() string\n}\n\ntype error interface {\n    Error() string\n}\n\n// Interface embedding\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Nil interface values\nvar w Writer\nfmt.Println(w == nil)  // true\n\nw = (*MyWriter)(nil)\nfmt.Println(w == nil)  // false! Interface holds nil pointer\n\n// Interface comparison\nvar x, y interface{}\nx = 1\ny = 1\nfmt.Println(x == y)  // true\n\nx = []int{1}\ny = []int{1}\n// fmt.Println(x == y)  // Panic! Slices not comparable\n```\n\n## Goroutines and Channels\n\n### Goroutines\n\n```go\n// Start a goroutine\ngo func() {\n    fmt.Println(\"Running in goroutine\")\n}()\n\n// Goroutine with function\nfunc worker(id int) {\n    fmt.Printf(\"Worker %d starting\\n\", id)\n    time.Sleep(time.Second)\n    fmt.Printf(\"Worker %d done\\n\", id)\n}\n\ngo worker(1)\n\n// WaitGroup for synchronization\nvar wg sync.WaitGroup\n\nfor i := 0; i < 5; i++ {\n    wg.Add(1)\n    go func(id int) {\n        defer wg.Done()\n        worker(id)\n    }(i)\n}\n\nwg.Wait()  // Wait for all goroutines\n\n// Goroutine lifecycle\nfunc longRunning(ctx context.Context) {\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Println(\"Goroutine stopping\")\n            return\n        default:\n            // Do work\n            time.Sleep(100 * time.Millisecond)\n        }\n    }\n}\n\nctx, cancel := context.WithCancel(context.Background())\ngo longRunning(ctx)\ntime.Sleep(time.Second)\ncancel()  // Signal goroutine to stop\n```\n\n### Channels\n\n```go\n// Channel creation\nch := make(chan int)         // Unbuffered channel\nch := make(chan int, 10)     // Buffered channel with capacity 10\n\n// Send and receive\nch <- 42        // Send\nvalue := <-ch   // Receive\n<-ch            // Receive and discard\n\n// Channel as function parameter\nfunc send(ch chan<- int) {  // Send-only channel\n    ch <- 42\n}\n\nfunc receive(ch <-chan int) {  // Receive-only channel\n    value := <-ch\n}\n\n// Close channel\nclose(ch)\n\n// Check if channel is closed\nvalue, ok := <-ch\nif !ok {\n    fmt.Println(\"Channel closed\")\n}\n\n// Range over channel\nfor value := range ch {\n    fmt.Println(value)\n}\n\n// Select statement\nselect {\ncase v1 := <-ch1:\n    fmt.Println(\"Received from ch1:\", v1)\ncase v2 := <-ch2:\n    fmt.Println(\"Received from ch2:\", v2)\ncase ch3 <- 42:\n    fmt.Println(\"Sent to ch3\")\ndefault:\n    fmt.Println(\"No communication ready\")\n}\n\n// Select with timeout\nselect {\ncase result := <-ch:\n    fmt.Println(\"Got result:\", result)\ncase <-time.After(time.Second):\n    fmt.Println(\"Timeout\")\n}\n\n// Fan-in pattern\nfunc fanIn(ch1, ch2 <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for {\n            select {\n            case v := <-ch1:\n                out <- v\n            case v := <-ch2:\n                out <- v\n            }\n        }\n    }()\n    return out\n}\n\n// Pipeline pattern\nfunc pipeline() {\n    numbers := generate()\n    squares := square(numbers)\n    print(squares)\n}\n\nfunc generate() <-chan int {\n    out := make(chan int)\n    go func() {\n        for i := 1; i <= 10; i++ {\n            out <- i\n        }\n        close(out)\n    }()\n    return out\n}\n\nfunc square(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            out <- n * n\n        }\n        close(out)\n    }()\n    return out\n}\n```\n\n## Packages and Modules\n\n### Package Organization\n\n```go\n// Package declaration\npackage mypackage\n\n// Import statements\nimport (\n    \"fmt\"              // Standard library\n    \"math/rand\"        // Nested package\n    \n    \"github.com/user/repo\"  // External package\n    alias \"github.com/long/package/name\"  // Aliased import\n    . \"math\"           // Dot import (use sparingly)\n    _ \"image/png\"      // Blank import (side effects only)\n)\n\n// Package initialization\nfunc init() {\n    // Runs when package is imported\n    // Can have multiple init functions\n    fmt.Println(\"Package initialized\")\n}\n\n// Exported (public) - starts with capital letter\ntype PublicType struct {\n    PublicField int\n    privateField string\n}\n\nfunc PublicFunction() {}\n\n// Unexported (private) - starts with lowercase\ntype privateType struct {}\nfunc privateFunction() {}\n\n// Internal packages - only accessible within module\n// internal/\n//   └── helper/\n//       └── helper.go\n```\n\n### Modules\n\n```bash\n# Initialize module\ngo mod init github.com/user/project\n\n# Add dependency\ngo get github.com/some/package@v1.2.3\n\n# Update dependencies\ngo get -u ./...\n\n# Download dependencies\ngo mod download\n\n# Vendor dependencies\ngo mod vendor\n\n# Tidy dependencies\ngo mod tidy\n\n# Module proxy\nexport GOPROXY=https://proxy.golang.org\n\n# Private modules\nexport GOPRIVATE=github.com/company/*\n```\n\n```go\n// go.mod file\nmodule github.com/user/project\n\ngo 1.21\n\nrequire (\n    github.com/shopspring/decimal v1.3.1\n    github.com/stretchr/testify v1.8.4\n)\n\nrequire (\n    github.com/davecgh/go-spew v1.1.1 // indirect\n    github.com/pmezard/go-difflib v1.0.0 // indirect\n)\n\nreplace github.com/old/package => github.com/new/package v1.0.0\n\nexclude github.com/bad/package v1.0.0\n```\n\n## Type System Deep Dive\n\n### Type Definitions and Aliases\n\n```go\n// Type definition (creates new type)\ntype UserID int\ntype Username string\n\nvar id UserID = 42\nvar name Username = \"alice\"\n\n// id + 1  // Error: mismatched types\nid = UserID(100)  // Explicit conversion needed\n\n// Type alias (same type, different name)\ntype Byte = uint8\ntype Rune = int32\n\nvar b Byte = 255\nvar u uint8 = b  // OK, same type\n\n// Method on custom type\ntype Celsius float64\ntype Fahrenheit float64\n\nfunc (c Celsius) ToFahrenheit() Fahrenheit {\n    return Fahrenheit(c*9/5 + 32)\n}\n\n// Type embedding\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype ReadWriter interface {\n    Reader  // Embedded\n    Writer  // Embedded\n}\n\n// Struct embedding\ntype Animal struct {\n    Name string\n    Age  int\n}\n\nfunc (a Animal) Speak() {\n    fmt.Printf(\"%s makes a sound\\n\", a.Name)\n}\n\ntype Dog struct {\n    Animal  // Embedded\n    Breed string\n}\n\ndog := Dog{\n    Animal: Animal{Name: \"Buddy\", Age: 3},\n    Breed: \"Labrador\",\n}\ndog.Speak()  // Inherited method\nfmt.Println(dog.Name)  // Promoted field\n```\n\n### Generics (Go 1.18+)\n\n```go\n// Generic function\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nresult := Min(3, 5)  // Type inference\nresult := Min[float64](3.14, 2.71)  // Explicit type\n\n// Generic type\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    var zero T\n    if len(s.items) == 0 {\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\n// Type constraints\ntype Number interface {\n    int | int64 | float32 | float64\n}\n\nfunc Sum[T Number](numbers []T) T {\n    var sum T\n    for _, n := range numbers {\n        sum += n\n    }\n    return sum\n}\n\n// Custom constraints\ntype Comparable[T any] interface {\n    Compare(T) int\n}\n\n// Type sets\ntype Signed interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64\n}\n\n// Generic interface\ntype Container[T any] interface {\n    Add(T)\n    Get(int) T\n    Size() int\n}\n```\n\n## Memory Model\n\n### Stack vs Heap\n\n```go\n// Stack allocation (usually)\nfunc stackAlloc() {\n    x := 42  // Likely on stack\n    y := x + 10\n    fmt.Println(y)\n}\n\n// Heap allocation (escape analysis)\nfunc heapAlloc() *int {\n    x := 42\n    return &x  // x escapes to heap\n}\n\n// Check escape analysis\n// go build -gcflags=\"-m\" main.go\n\n// Force heap allocation\nfunc forceHeap() {\n    slice := make([]int, 1000000)  // Large allocation\n    _ = slice\n}\n\n// Memory alignment\ntype Aligned struct {\n    a bool    // 1 byte\n    b int64   // 8 bytes\n    c bool    // 1 byte\n}\n// Size: 24 bytes (with padding)\n\ntype Packed struct {\n    a bool    // 1 byte\n    c bool    // 1 byte\n    b int64   // 8 bytes\n}\n// Size: 16 bytes (better alignment)\n\n// Check size and alignment\nfmt.Println(unsafe.Sizeof(Aligned{}))    // 24\nfmt.Println(unsafe.Alignof(Aligned{}))   // 8\n\n// Zero values\nvar (\n    i int        // 0\n    f float64    // 0.0\n    b bool       // false\n    s string     // \"\"\n    p *int       // nil\n    sl []int     // nil\n    m map[int]int // nil\n    ch chan int  // nil\n    fn func()    // nil\n    iface interface{} // nil\n)\n\n// Make vs new\nslice := make([]int, 10)     // Initialized slice\nmapVar := make(map[string]int) // Initialized map\nch := make(chan int, 5)       // Initialized channel\n\nptr := new(int)               // *int pointing to zero value\n*ptr = 42\n\n// Memory barriers and happens-before\nvar x, y int\nvar ready bool\n\n// Goroutine 1\ngo func() {\n    x = 1\n    y = 2\n    ready = true  // Other goroutine might see this before x and y\n}()\n\n// Goroutine 2\ngo func() {\n    if ready {\n        // Might print 0, 0 without proper synchronization\n        fmt.Println(x, y)\n    }\n}()\n\n// Proper synchronization with channels\ndone := make(chan bool)\ngo func() {\n    x = 1\n    y = 2\n    done <- true  // Synchronization point\n}()\n<-done  // Guaranteed to see x=1, y=2\n```\n\n### Garbage Collection\n\n```go\n// GC tuning\nimport \"runtime/debug\"\n\n// Set GC percentage\ndebug.SetGCPercent(50)  // More aggressive GC\n\n// Force GC\nruntime.GC()\n\n// GC stats\nvar stats runtime.MemStats\nruntime.ReadMemStats(&stats)\nfmt.Printf(\"Allocated: %v MB\\n\", stats.Alloc/1024/1024)\nfmt.Printf(\"Total Allocated: %v MB\\n\", stats.TotalAlloc/1024/1024)\nfmt.Printf(\"System: %v MB\\n\", stats.Sys/1024/1024)\nfmt.Printf(\"GC Runs: %v\\n\", stats.NumGC)\n\n// Finalizers (use sparingly)\ntype Resource struct {\n    handle int\n}\n\nfunc NewResource() *Resource {\n    r := &Resource{handle: allocateHandle()}\n    runtime.SetFinalizer(r, (*Resource).cleanup)\n    return r\n}\n\nfunc (r *Resource) cleanup() {\n    releaseHandle(r.handle)\n}\n\n// Object pooling to reduce GC pressure\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 1024)\n    },\n}\n\nfunc processData() {\n    buf := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buf)\n    \n    // Use buffer\n}\n```\n\n## Advanced Language Features\n\n### Reflection\n\n```go\nimport \"reflect\"\n\n// Type information\nvar x float64 = 3.14\nt := reflect.TypeOf(x)\nfmt.Println(\"Type:\", t)           // float64\nfmt.Println(\"Kind:\", t.Kind())    // float64\nfmt.Println(\"Size:\", t.Size())    // 8\n\n// Value manipulation\nv := reflect.ValueOf(x)\nfmt.Println(\"Value:\", v)          // 3.14\nfmt.Println(\"Type:\", v.Type())    // float64\nfmt.Println(\"Kind:\", v.Kind())    // float64\nfmt.Println(\"Float:\", v.Float())  // 3.14\n\n// Modify through reflection\nvar y float64 = 3.14\np := reflect.ValueOf(&y)\nv = p.Elem()\nv.SetFloat(2.71)\nfmt.Println(y)  // 2.71\n\n// Struct reflection\ntype Person struct {\n    Name string `json:\"name\" validate:\"required\"`\n    Age  int    `json:\"age\" validate:\"min=0\"`\n}\n\nperson := Person{\"Alice\", 30}\nt = reflect.TypeOf(person)\nv = reflect.ValueOf(person)\n\nfor i := 0; i < t.NumField(); i++ {\n    field := t.Field(i)\n    value := v.Field(i)\n    \n    fmt.Printf(\"Field: %s, Type: %s, Value: %v\\n\",\n        field.Name, field.Type, value.Interface())\n    \n    // Get tags\n    jsonTag := field.Tag.Get(\"json\")\n    validateTag := field.Tag.Get(\"validate\")\n    fmt.Printf(\"  JSON: %s, Validate: %s\\n\", jsonTag, validateTag)\n}\n\n// Call methods through reflection\nv = reflect.ValueOf(&person)\nmethod := v.MethodByName(\"String\")\nif method.IsValid() {\n    results := method.Call(nil)\n    fmt.Println(results[0].Interface())\n}\n\n// Create new instances\nt = reflect.TypeOf(Person{})\nnewPerson := reflect.New(t).Elem()\nnewPerson.Field(0).SetString(\"Bob\")\nnewPerson.Field(1).SetInt(25)\nfmt.Println(newPerson.Interface())  // {Bob 25}\n```\n\n### Unsafe Operations\n\n```go\nimport \"unsafe\"\n\n// Sizeof\nvar x int64 = 10\nsize := unsafe.Sizeof(x)  // 8 bytes\n\n// Alignof\nalignment := unsafe.Alignof(x)  // 8 bytes\n\n// Offsetof\ntype Sample struct {\n    a bool\n    b int64\n    c int32\n}\noffset := unsafe.Offsetof(Sample{}.b)  // Offset of field b\n\n// Pointer arithmetic (dangerous!)\narr := [3]int{1, 2, 3}\nptr := unsafe.Pointer(&arr[0])\n\n// Access second element\nsecond := (*int)(unsafe.Add(ptr, unsafe.Sizeof(arr[0])))\nfmt.Println(*second)  // 2\n\n// Convert between types (bypass type system)\nvar i int64 = 42\nvar f float64\nf = *(*float64)(unsafe.Pointer(&i))  // Reinterpret bits\n\n// String to []byte without copy\ns := \"hello\"\nbytes := *(*[]byte)(unsafe.Pointer(&s))\n\n// Struct padding\ntype Padded struct {\n    a bool   // 1 byte\n    // 7 bytes padding\n    b int64  // 8 bytes\n    c bool   // 1 byte\n    // 7 bytes padding\n}\nfmt.Println(unsafe.Sizeof(Padded{}))  // 24 bytes\n\n// Access private fields (don't do this!)\ntype private struct {\n    secret string\n}\n\np := private{secret: \"hidden\"}\nfield := reflect.ValueOf(&p).Elem().Field(0)\nptr = unsafe.Pointer(field.UnsafeAddr())\nsecret := *(*string)(ptr)\nfmt.Println(secret)  // \"hidden\"\n```\n\n### Build Tags and Conditional Compilation\n\n```go\n// +build linux,amd64\n\npackage main\n\n// File only compiled on Linux AMD64\n\n// Build tags\n// +build debug\n// +build !prod\n// +build linux darwin\n// +build 386 amd64\n\n// Go 1.17+ syntax\n//go:build linux && amd64\n\n// Custom build tags\n// go build -tags=\"debug,feature1\"\n\n// File naming conventions\n// file_linux.go       // Linux only\n// file_windows.go     // Windows only\n// file_amd64.go       // AMD64 only\n// file_test.go        // Test files\n\n// Conditional compilation in code\n// +build debug\n\nfunc debugLog(msg string) {\n    fmt.Println(\"[DEBUG]\", msg)\n}\n\n// +build !debug\n\nfunc debugLog(msg string) {\n    // No-op in production\n}\n```\n\n### CGO and Foreign Function Interface\n\n```go\n// #include <stdio.h>\n// #include <stdlib.h>\n//\n// static void myprint(const char* s) {\n//     printf(\"%s\\n\", s);\n// }\nimport \"C\"\nimport \"unsafe\"\n\nfunc main() {\n    cs := C.CString(\"Hello from C\")\n    defer C.free(unsafe.Pointer(cs))\n    C.myprint(cs)\n}\n\n// Calling Go from C\n//export GoFunction\nfunc GoFunction(x C.int) C.int {\n    return x * 2\n}\n\n// Linking with external libraries\n// #cgo LDFLAGS: -lm\n// #include <math.h>\nimport \"C\"\n\nfunc sqrt(x float64) float64 {\n    return float64(C.sqrt(C.double(x)))\n}\n```\n\n## Best Practices Summary\n\n1. **Keep it simple** - Don't over-engineer\n2. **Handle errors explicitly** - No exceptions in Go\n3. **Use channels for communication** - Not shared memory\n4. **Make the zero value useful** - Design types to work without initialization\n5. **Return early** - Reduce nesting with early returns\n6. **Document exported APIs** - All public functions need comments\n7. **Test everything** - Table-driven tests are idiomatic\n8. **Profile before optimizing** - Measure, don't guess\n9. **Respect context** - Pass context.Context for cancellation\n10. **Close resources** - Always defer Close() after acquiring resources"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":120,"cache_read_input_tokens":38253,"output_tokens":9561,"service_tier":"standard"}},"requestId":"req_011CS5F7sBYykTadTW9Nmxfh","type":"assistant","uuid":"fa358e09-1533-4bad-9953-4a81ac35e2e2","timestamp":"2025-08-13T06:38:43.780Z"}
{"parentUuid":"fa358e09-1533-4bad-9953-4a81ac35e2e2","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EXyMcGSAYAn6qFm4YEug7s","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/01-core-language.md"}]},"uuid":"6357ab51-dbc2-4388-b7b0-2063f07b3b68","timestamp":"2025-08-13T06:40:45.837Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/01-core-language.md","content":"# Go Core Language Features - Complete Guide\n\n## Table of Contents\n1. [Basic Syntax and Types](#basic-syntax-and-types)\n2. [Control Flow](#control-flow)\n3. [Functions](#functions)\n4. [Methods and Interfaces](#methods-and-interfaces)\n5. [Goroutines and Channels](#goroutines-and-channels)\n6. [Packages and Modules](#packages-and-modules)\n7. [Type System Deep Dive](#type-system-deep-dive)\n8. [Memory Model](#memory-model)\n\n## Basic Syntax and Types\n\n### Variables and Constants\n\n```go\n// Variable declarations\nvar x int                      // Zero value: 0\nvar y = 42                     // Type inference\nvar z int = 100                // Explicit type\nvar a, b, c int                // Multiple variables\nvar (                          // Variable block\n    name string = \"Go\"\n    version float64 = 1.21\n    stable bool = true\n)\n\n// Short variable declaration (only inside functions)\ncount := 10                    // Type inferred as int\nmessage := \"Hello\"              // Type inferred as string\npi := 3.14159                  // Type inferred as float64\n\n// Constants\nconst Pi = 3.14159             // Untyped constant\nconst (\n    StatusOK = 200\n    StatusNotFound = 404\n)\nconst typedConst int64 = 100   // Typed constant\n\n// Iota - constant generator\nconst (\n    Sunday = iota  // 0\n    Monday         // 1\n    Tuesday        // 2\n    Wednesday      // 3\n    Thursday       // 4\n    Friday         // 5\n    Saturday       // 6\n)\n\n// Bit flags with iota\nconst (\n    ReadPermission = 1 << iota  // 1\n    WritePermission              // 2\n    ExecutePermission            // 4\n)\n```\n\n### Basic Types\n\n```go\n// Boolean\nvar active bool = true\nvar deleted bool  // Zero value: false\n\n// Numeric types\nvar (\n    // Integers\n    i8  int8   = -128                    // -128 to 127\n    i16 int16  = -32768                  // -32,768 to 32,767\n    i32 int32  = -2147483648              // -2,147,483,648 to 2,147,483,647\n    i64 int64  = -9223372036854775808    // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n    i   int    = -1                      // Platform dependent (32 or 64 bit)\n    \n    // Unsigned integers\n    u8  uint8  = 255                     // 0 to 255 (byte is alias)\n    u16 uint16 = 65535                   // 0 to 65,535\n    u32 uint32 = 4294967295               // 0 to 4,294,967,295\n    u64 uint64 = 18446744073709551615    // 0 to 18,446,744,073,709,551,615\n    u   uint   = 1                       // Platform dependent\n    \n    // Floating point\n    f32 float32 = 3.14                   // IEEE-754 32-bit\n    f64 float64 = 3.141592653589793      // IEEE-754 64-bit\n    \n    // Complex numbers\n    c64  complex64  = 1 + 2i             // float32 real and imaginary\n    c128 complex128 = 1 + 2i             // float64 real and imaginary\n    \n    // Aliases\n    b byte = 255                         // alias for uint8\n    r rune = 'A'                         // alias for int32 (Unicode code point)\n    \n    // Pointer types\n    ptr *int                             // Pointer to int\n    uptr uintptr                         // Integer representation of pointer\n)\n\n// String type\nvar (\n    name string = \"Gopher\"\n    multiline = `This is\na multiline\nstring`\n    empty string  // Zero value: \"\"\n)\n\n// Type conversions (no implicit conversions in Go)\nvar x int = 42\nvar y float64 = float64(x)\nvar z uint = uint(y)\nvar s string = string(65)  // \"A\" (Unicode code point)\n```\n\n### Composite Types\n\n```go\n// Arrays - fixed size\nvar arr1 [5]int                     // Zero value: [0 0 0 0 0]\narr2 := [5]int{1, 2, 3, 4, 5}\narr3 := [...]int{1, 2, 3}           // Compiler counts elements\narr4 := [5]int{0: 10, 4: 50}        // Sparse initialization\n\n// Slices - dynamic arrays\nvar slice1 []int                    // Zero value: nil\nslice2 := []int{1, 2, 3}\nslice3 := make([]int, 5)            // Length 5, capacity 5\nslice4 := make([]int, 5, 10)        // Length 5, capacity 10\nslice5 := arr2[1:4]                 // Slice from array [2 3 4]\n\n// Slice operations\nappend(slice2, 4, 5)                // Append elements\ncopy(dst, src)                      // Copy elements\nlen(slice2)                         // Length\ncap(slice2)                         // Capacity\n\n// Maps - hash tables\nvar map1 map[string]int             // Zero value: nil\nmap2 := make(map[string]int)\nmap3 := map[string]int{\n    \"apple\":  5,\n    \"banana\": 3,\n}\n\n// Map operations\nmap3[\"orange\"] = 7                  // Insert/update\ndelete(map3, \"banana\")               // Delete\nvalue, exists := map3[\"apple\"]      // Lookup with existence check\n\n// Structs - grouped data\ntype Person struct {\n    Name string\n    Age  int\n    Email string `json:\"email\" validate:\"required,email\"`  // Tags\n}\n\nvar person1 Person                  // Zero value: {\"\" 0 \"\"}\nperson2 := Person{\n    Name: \"Alice\",\n    Age:  30,\n    Email: \"alice@example.com\",\n}\nperson3 := Person{\"Bob\", 25, \"bob@example.com\"}  // Positional\n\n// Anonymous structs\nconfig := struct {\n    Host string\n    Port int\n}{\n    Host: \"localhost\",\n    Port: 8080,\n}\n\n// Embedded structs\ntype Employee struct {\n    Person              // Embedded\n    Department string\n    Salary     float64\n}\n\n// Pointers\nvar p *int\ni := 42\np = &i          // Address of i\nfmt.Println(*p) // Dereference: 42\n*p = 21         // Set through pointer\n\n// Pointer to struct\npersonPtr := &Person{Name: \"Charlie\", Age: 35}\npersonPtr.Name = \"Chuck\"  // Automatic dereference\n```\n\n## Control Flow\n\n### Conditionals\n\n```go\n// If statement\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else if x < 0 {\n    fmt.Println(\"Negative\")\n} else {\n    fmt.Println(\"Zero\")\n}\n\n// If with initialization\nif err := doSomething(); err != nil {\n    return err\n}\n\n// If with type assertion\nif str, ok := value.(string); ok {\n    fmt.Println(\"String value:\", str)\n}\n\n// Switch statement\nswitch day {\ncase \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\":\n    fmt.Println(\"Weekday\")\ncase \"Saturday\", \"Sunday\":\n    fmt.Println(\"Weekend\")\ndefault:\n    fmt.Println(\"Invalid day\")\n}\n\n// Switch with initialization\nswitch hour := time.Now().Hour(); {\ncase hour < 12:\n    fmt.Println(\"Morning\")\ncase hour < 17:\n    fmt.Println(\"Afternoon\")\ndefault:\n    fmt.Println(\"Evening\")\n}\n\n// Type switch\nswitch v := value.(type) {\ncase int:\n    fmt.Printf(\"Integer: %d\\n\", v)\ncase string:\n    fmt.Printf(\"String: %s\\n\", v)\ncase bool:\n    fmt.Printf(\"Boolean: %t\\n\", v)\ndefault:\n    fmt.Printf(\"Unknown type: %T\\n\", v)\n}\n\n// Fallthrough in switch\nswitch score {\ncase 100:\n    fmt.Println(\"Perfect!\")\n    fallthrough\ncase 90, 91, 92, 93, 94, 95, 96, 97, 98, 99:\n    fmt.Println(\"A grade\")\ndefault:\n    fmt.Println(\"Keep trying\")\n}\n```\n\n### Loops\n\n```go\n// For loop - traditional\nfor i := 0; i < 10; i++ {\n    fmt.Println(i)\n}\n\n// For loop - while style\ncount := 0\nfor count < 10 {\n    fmt.Println(count)\n    count++\n}\n\n// Infinite loop\nfor {\n    // Break or return to exit\n    if condition {\n        break\n    }\n}\n\n// Range over slice\nslice := []int{1, 2, 3, 4, 5}\nfor index, value := range slice {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n\n// Range over map\nm := map[string]int{\"a\": 1, \"b\": 2}\nfor key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Range over string (iterates over runes)\nfor index, runeValue := range \"Hello, 世界\" {\n    fmt.Printf(\"%d: %c\\n\", index, runeValue)\n}\n\n// Range over channel\nch := make(chan int)\ngo func() {\n    for i := 0; i < 5; i++ {\n        ch <- i\n    }\n    close(ch)\n}()\nfor value := range ch {\n    fmt.Println(value)\n}\n\n// Continue and break with labels\nouter:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        if i == 1 && j == 1 {\n            continue outer  // Continue outer loop\n        }\n        if i == 2 && j == 2 {\n            break outer     // Break from outer loop\n        }\n        fmt.Printf(\"(%d,%d) \", i, j)\n    }\n}\n```\n\n### Defer, Panic, and Recover\n\n```go\n// Defer - executes at function exit (LIFO order)\nfunc example() {\n    defer fmt.Println(\"Third\")\n    defer fmt.Println(\"Second\")\n    defer fmt.Println(\"First\")\n    fmt.Println(\"Main function\")\n    // Output: Main function, First, Second, Third\n}\n\n// Defer for cleanup\nfunc readFile(filename string) ([]byte, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return nil, err\n    }\n    defer file.Close()  // Ensures file is closed\n    \n    return ioutil.ReadAll(file)\n}\n\n// Defer with error handling\nfunc writeFile(filename string, data []byte) (err error) {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if cerr := file.Close(); cerr != nil && err == nil {\n            err = cerr  // Capture close error\n        }\n    }()\n    \n    _, err = file.Write(data)\n    return err\n}\n\n// Panic - runtime error\nfunc mustPositive(n int) {\n    if n <= 0 {\n        panic(fmt.Sprintf(\"n must be positive, got %d\", n))\n    }\n}\n\n// Recover - catch panic\nfunc safeFunction() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Recovered from panic: %v\\n\", r)\n        }\n    }()\n    \n    // Code that might panic\n    riskyOperation()\n}\n\n// Structured panic/recover pattern\nfunc robustFunction() (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    \n    // Risky operations\n    return nil\n}\n```\n\n## Functions\n\n### Function Declarations\n\n```go\n// Basic function\nfunc add(x, y int) int {\n    return x + y\n}\n\n// Multiple return values\nfunc divmod(a, b int) (quotient, remainder int) {\n    return a / b, a % b\n}\n\n// Named return values\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return  // Naked return\n}\n\n// Variadic functions\nfunc sum(nums ...int) int {\n    total := 0\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n\n// Call variadic function\nresult := sum(1, 2, 3, 4, 5)\nslice := []int{1, 2, 3}\nresult = sum(slice...)  // Expand slice\n\n// Function as parameter\nfunc apply(fn func(int, int) int, a, b int) int {\n    return fn(a, b)\n}\n\nresult = apply(add, 5, 3)\n\n// Function returning function\nfunc multiplier(factor int) func(int) int {\n    return func(x int) int {\n        return x * factor\n    }\n}\n\ndouble := multiplier(2)\nfmt.Println(double(5))  // 10\n\n// Anonymous functions\nfunc() {\n    fmt.Println(\"Anonymous function\")\n}()\n\n// Function type\ntype Operation func(int, int) int\n\nvar op Operation = add\nresult = op(10, 5)\n\n// Method expression\ntype Calculator struct{}\nfunc (c Calculator) Add(x, y int) int { return x + y }\n\nvar calc Calculator\nfn := Calculator.Add  // Method expression\nresult = fn(calc, 3, 4)\n\n// Method value\nfn2 := calc.Add  // Method value\nresult = fn2(3, 4)\n```\n\n### Closures\n\n```go\n// Closure capturing variables\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nc := counter()\nfmt.Println(c())  // 1\nfmt.Println(c())  // 2\nfmt.Println(c())  // 3\n\n// Closure in loop (common pitfall)\nvar funcs []func()\n\n// Wrong - captures loop variable\nfor i := 0; i < 3; i++ {\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // All print 3\n    })\n}\n\n// Correct - capture copy\nfor i := 0; i < 3; i++ {\n    i := i  // Shadow with new variable\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // Prints 0, 1, 2\n    })\n}\n\n// Fibonacci closure\nfunc fibonacci() func() int {\n    a, b := 0, 1\n    return func() int {\n        a, b = b, a+b\n        return a\n    }\n}\n```\n\n## Methods and Interfaces\n\n### Methods\n\n```go\n// Method with value receiver\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\n// Method with pointer receiver\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n\n// Method on non-struct types\ntype MyInt int\n\nfunc (m MyInt) IsPositive() bool {\n    return m > 0\n}\n\n// Method set rules\nrect := Rectangle{10, 5}\nrect.Area()        // OK - value receiver\nrect.Scale(2)      // OK - Go automatically takes address\n\nrectPtr := &Rectangle{10, 5}\nrectPtr.Area()     // OK - Go automatically dereferences\nrectPtr.Scale(2)   // OK - pointer receiver\n\n// Method chaining\ntype Builder struct {\n    str strings.Builder\n}\n\nfunc (b *Builder) Add(s string) *Builder {\n    b.str.WriteString(s)\n    return b\n}\n\nfunc (b *Builder) Build() string {\n    return b.str.String()\n}\n\nresult := (&Builder{}).Add(\"Hello\").Add(\" \").Add(\"World\").Build()\n```\n\n### Interfaces\n\n```go\n// Interface definition\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\n// Interface composition\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\n// Empty interface\nvar any interface{}  // Can hold any value\nany = 42\nany = \"hello\"\nany = []int{1, 2, 3}\n\n// Type assertion\nvalue := any.(string)  // Panics if not string\nvalue, ok := any.(string)  // Safe assertion\n\n// Type switch\nswitch v := any.(type) {\ncase int:\n    fmt.Printf(\"Integer: %d\\n\", v)\ncase string:\n    fmt.Printf(\"String: %s\\n\", v)\ncase []int:\n    fmt.Printf(\"Int slice: %v\\n\", v)\n}\n\n// Interface satisfaction (implicit)\ntype MyWriter struct{}\n\nfunc (w MyWriter) Write(p []byte) (int, error) {\n    fmt.Print(string(p))\n    return len(p), nil\n}\n\nvar w Writer = MyWriter{}  // Satisfies Writer interface\n\n// Common interfaces\ntype Stringer interface {\n    String() string\n}\n\ntype error interface {\n    Error() string\n}\n\n// Interface embedding\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Nil interface values\nvar w Writer\nfmt.Println(w == nil)  // true\n\nw = (*MyWriter)(nil)\nfmt.Println(w == nil)  // false! Interface holds nil pointer\n\n// Interface comparison\nvar x, y interface{}\nx = 1\ny = 1\nfmt.Println(x == y)  // true\n\nx = []int{1}\ny = []int{1}\n// fmt.Println(x == y)  // Panic! Slices not comparable\n```\n\n## Goroutines and Channels\n\n### Goroutines\n\n```go\n// Start a goroutine\ngo func() {\n    fmt.Println(\"Running in goroutine\")\n}()\n\n// Goroutine with function\nfunc worker(id int) {\n    fmt.Printf(\"Worker %d starting\\n\", id)\n    time.Sleep(time.Second)\n    fmt.Printf(\"Worker %d done\\n\", id)\n}\n\ngo worker(1)\n\n// WaitGroup for synchronization\nvar wg sync.WaitGroup\n\nfor i := 0; i < 5; i++ {\n    wg.Add(1)\n    go func(id int) {\n        defer wg.Done()\n        worker(id)\n    }(i)\n}\n\nwg.Wait()  // Wait for all goroutines\n\n// Goroutine lifecycle\nfunc longRunning(ctx context.Context) {\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Println(\"Goroutine stopping\")\n            return\n        default:\n            // Do work\n            time.Sleep(100 * time.Millisecond)\n        }\n    }\n}\n\nctx, cancel := context.WithCancel(context.Background())\ngo longRunning(ctx)\ntime.Sleep(time.Second)\ncancel()  // Signal goroutine to stop\n```\n\n### Channels\n\n```go\n// Channel creation\nch := make(chan int)         // Unbuffered channel\nch := make(chan int, 10)     // Buffered channel with capacity 10\n\n// Send and receive\nch <- 42        // Send\nvalue := <-ch   // Receive\n<-ch            // Receive and discard\n\n// Channel as function parameter\nfunc send(ch chan<- int) {  // Send-only channel\n    ch <- 42\n}\n\nfunc receive(ch <-chan int) {  // Receive-only channel\n    value := <-ch\n}\n\n// Close channel\nclose(ch)\n\n// Check if channel is closed\nvalue, ok := <-ch\nif !ok {\n    fmt.Println(\"Channel closed\")\n}\n\n// Range over channel\nfor value := range ch {\n    fmt.Println(value)\n}\n\n// Select statement\nselect {\ncase v1 := <-ch1:\n    fmt.Println(\"Received from ch1:\", v1)\ncase v2 := <-ch2:\n    fmt.Println(\"Received from ch2:\", v2)\ncase ch3 <- 42:\n    fmt.Println(\"Sent to ch3\")\ndefault:\n    fmt.Println(\"No communication ready\")\n}\n\n// Select with timeout\nselect {\ncase result := <-ch:\n    fmt.Println(\"Got result:\", result)\ncase <-time.After(time.Second):\n    fmt.Println(\"Timeout\")\n}\n\n// Fan-in pattern\nfunc fanIn(ch1, ch2 <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for {\n            select {\n            case v := <-ch1:\n                out <- v\n            case v := <-ch2:\n                out <- v\n            }\n        }\n    }()\n    return out\n}\n\n// Pipeline pattern\nfunc pipeline() {\n    numbers := generate()\n    squares := square(numbers)\n    print(squares)\n}\n\nfunc generate() <-chan int {\n    out := make(chan int)\n    go func() {\n        for i := 1; i <= 10; i++ {\n            out <- i\n        }\n        close(out)\n    }()\n    return out\n}\n\nfunc square(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            out <- n * n\n        }\n        close(out)\n    }()\n    return out\n}\n```\n\n## Packages and Modules\n\n### Package Organization\n\n```go\n// Package declaration\npackage mypackage\n\n// Import statements\nimport (\n    \"fmt\"              // Standard library\n    \"math/rand\"        // Nested package\n    \n    \"github.com/user/repo\"  // External package\n    alias \"github.com/long/package/name\"  // Aliased import\n    . \"math\"           // Dot import (use sparingly)\n    _ \"image/png\"      // Blank import (side effects only)\n)\n\n// Package initialization\nfunc init() {\n    // Runs when package is imported\n    // Can have multiple init functions\n    fmt.Println(\"Package initialized\")\n}\n\n// Exported (public) - starts with capital letter\ntype PublicType struct {\n    PublicField int\n    privateField string\n}\n\nfunc PublicFunction() {}\n\n// Unexported (private) - starts with lowercase\ntype privateType struct {}\nfunc privateFunction() {}\n\n// Internal packages - only accessible within module\n// internal/\n//   └── helper/\n//       └── helper.go\n```\n\n### Modules\n\n```bash\n# Initialize module\ngo mod init github.com/user/project\n\n# Add dependency\ngo get github.com/some/package@v1.2.3\n\n# Update dependencies\ngo get -u ./...\n\n# Download dependencies\ngo mod download\n\n# Vendor dependencies\ngo mod vendor\n\n# Tidy dependencies\ngo mod tidy\n\n# Module proxy\nexport GOPROXY=https://proxy.golang.org\n\n# Private modules\nexport GOPRIVATE=github.com/company/*\n```\n\n```go\n// go.mod file\nmodule github.com/user/project\n\ngo 1.21\n\nrequire (\n    github.com/shopspring/decimal v1.3.1\n    github.com/stretchr/testify v1.8.4\n)\n\nrequire (\n    github.com/davecgh/go-spew v1.1.1 // indirect\n    github.com/pmezard/go-difflib v1.0.0 // indirect\n)\n\nreplace github.com/old/package => github.com/new/package v1.0.0\n\nexclude github.com/bad/package v1.0.0\n```\n\n## Type System Deep Dive\n\n### Type Definitions and Aliases\n\n```go\n// Type definition (creates new type)\ntype UserID int\ntype Username string\n\nvar id UserID = 42\nvar name Username = \"alice\"\n\n// id + 1  // Error: mismatched types\nid = UserID(100)  // Explicit conversion needed\n\n// Type alias (same type, different name)\ntype Byte = uint8\ntype Rune = int32\n\nvar b Byte = 255\nvar u uint8 = b  // OK, same type\n\n// Method on custom type\ntype Celsius float64\ntype Fahrenheit float64\n\nfunc (c Celsius) ToFahrenheit() Fahrenheit {\n    return Fahrenheit(c*9/5 + 32)\n}\n\n// Type embedding\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype ReadWriter interface {\n    Reader  // Embedded\n    Writer  // Embedded\n}\n\n// Struct embedding\ntype Animal struct {\n    Name string\n    Age  int\n}\n\nfunc (a Animal) Speak() {\n    fmt.Printf(\"%s makes a sound\\n\", a.Name)\n}\n\ntype Dog struct {\n    Animal  // Embedded\n    Breed string\n}\n\ndog := Dog{\n    Animal: Animal{Name: \"Buddy\", Age: 3},\n    Breed: \"Labrador\",\n}\ndog.Speak()  // Inherited method\nfmt.Println(dog.Name)  // Promoted field\n```\n\n### Generics (Go 1.18+)\n\n```go\n// Generic function\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nresult := Min(3, 5)  // Type inference\nresult := Min[float64](3.14, 2.71)  // Explicit type\n\n// Generic type\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    var zero T\n    if len(s.items) == 0 {\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\n// Type constraints\ntype Number interface {\n    int | int64 | float32 | float64\n}\n\nfunc Sum[T Number](numbers []T) T {\n    var sum T\n    for _, n := range numbers {\n        sum += n\n    }\n    return sum\n}\n\n// Custom constraints\ntype Comparable[T any] interface {\n    Compare(T) int\n}\n\n// Type sets\ntype Signed interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64\n}\n\n// Generic interface\ntype Container[T any] interface {\n    Add(T)\n    Get(int) T\n    Size() int\n}\n```\n\n## Memory Model\n\n### Stack vs Heap\n\n```go\n// Stack allocation (usually)\nfunc stackAlloc() {\n    x := 42  // Likely on stack\n    y := x + 10\n    fmt.Println(y)\n}\n\n// Heap allocation (escape analysis)\nfunc heapAlloc() *int {\n    x := 42\n    return &x  // x escapes to heap\n}\n\n// Check escape analysis\n// go build -gcflags=\"-m\" main.go\n\n// Force heap allocation\nfunc forceHeap() {\n    slice := make([]int, 1000000)  // Large allocation\n    _ = slice\n}\n\n// Memory alignment\ntype Aligned struct {\n    a bool    // 1 byte\n    b int64   // 8 bytes\n    c bool    // 1 byte\n}\n// Size: 24 bytes (with padding)\n\ntype Packed struct {\n    a bool    // 1 byte\n    c bool    // 1 byte\n    b int64   // 8 bytes\n}\n// Size: 16 bytes (better alignment)\n\n// Check size and alignment\nfmt.Println(unsafe.Sizeof(Aligned{}))    // 24\nfmt.Println(unsafe.Alignof(Aligned{}))   // 8\n\n// Zero values\nvar (\n    i int        // 0\n    f float64    // 0.0\n    b bool       // false\n    s string     // \"\"\n    p *int       // nil\n    sl []int     // nil\n    m map[int]int // nil\n    ch chan int  // nil\n    fn func()    // nil\n    iface interface{} // nil\n)\n\n// Make vs new\nslice := make([]int, 10)     // Initialized slice\nmapVar := make(map[string]int) // Initialized map\nch := make(chan int, 5)       // Initialized channel\n\nptr := new(int)               // *int pointing to zero value\n*ptr = 42\n\n// Memory barriers and happens-before\nvar x, y int\nvar ready bool\n\n// Goroutine 1\ngo func() {\n    x = 1\n    y = 2\n    ready = true  // Other goroutine might see this before x and y\n}()\n\n// Goroutine 2\ngo func() {\n    if ready {\n        // Might print 0, 0 without proper synchronization\n        fmt.Println(x, y)\n    }\n}()\n\n// Proper synchronization with channels\ndone := make(chan bool)\ngo func() {\n    x = 1\n    y = 2\n    done <- true  // Synchronization point\n}()\n<-done  // Guaranteed to see x=1, y=2\n```\n\n### Garbage Collection\n\n```go\n// GC tuning\nimport \"runtime/debug\"\n\n// Set GC percentage\ndebug.SetGCPercent(50)  // More aggressive GC\n\n// Force GC\nruntime.GC()\n\n// GC stats\nvar stats runtime.MemStats\nruntime.ReadMemStats(&stats)\nfmt.Printf(\"Allocated: %v MB\\n\", stats.Alloc/1024/1024)\nfmt.Printf(\"Total Allocated: %v MB\\n\", stats.TotalAlloc/1024/1024)\nfmt.Printf(\"System: %v MB\\n\", stats.Sys/1024/1024)\nfmt.Printf(\"GC Runs: %v\\n\", stats.NumGC)\n\n// Finalizers (use sparingly)\ntype Resource struct {\n    handle int\n}\n\nfunc NewResource() *Resource {\n    r := &Resource{handle: allocateHandle()}\n    runtime.SetFinalizer(r, (*Resource).cleanup)\n    return r\n}\n\nfunc (r *Resource) cleanup() {\n    releaseHandle(r.handle)\n}\n\n// Object pooling to reduce GC pressure\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 1024)\n    },\n}\n\nfunc processData() {\n    buf := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buf)\n    \n    // Use buffer\n}\n```\n\n## Advanced Language Features\n\n### Reflection\n\n```go\nimport \"reflect\"\n\n// Type information\nvar x float64 = 3.14\nt := reflect.TypeOf(x)\nfmt.Println(\"Type:\", t)           // float64\nfmt.Println(\"Kind:\", t.Kind())    // float64\nfmt.Println(\"Size:\", t.Size())    // 8\n\n// Value manipulation\nv := reflect.ValueOf(x)\nfmt.Println(\"Value:\", v)          // 3.14\nfmt.Println(\"Type:\", v.Type())    // float64\nfmt.Println(\"Kind:\", v.Kind())    // float64\nfmt.Println(\"Float:\", v.Float())  // 3.14\n\n// Modify through reflection\nvar y float64 = 3.14\np := reflect.ValueOf(&y)\nv = p.Elem()\nv.SetFloat(2.71)\nfmt.Println(y)  // 2.71\n\n// Struct reflection\ntype Person struct {\n    Name string `json:\"name\" validate:\"required\"`\n    Age  int    `json:\"age\" validate:\"min=0\"`\n}\n\nperson := Person{\"Alice\", 30}\nt = reflect.TypeOf(person)\nv = reflect.ValueOf(person)\n\nfor i := 0; i < t.NumField(); i++ {\n    field := t.Field(i)\n    value := v.Field(i)\n    \n    fmt.Printf(\"Field: %s, Type: %s, Value: %v\\n\",\n        field.Name, field.Type, value.Interface())\n    \n    // Get tags\n    jsonTag := field.Tag.Get(\"json\")\n    validateTag := field.Tag.Get(\"validate\")\n    fmt.Printf(\"  JSON: %s, Validate: %s\\n\", jsonTag, validateTag)\n}\n\n// Call methods through reflection\nv = reflect.ValueOf(&person)\nmethod := v.MethodByName(\"String\")\nif method.IsValid() {\n    results := method.Call(nil)\n    fmt.Println(results[0].Interface())\n}\n\n// Create new instances\nt = reflect.TypeOf(Person{})\nnewPerson := reflect.New(t).Elem()\nnewPerson.Field(0).SetString(\"Bob\")\nnewPerson.Field(1).SetInt(25)\nfmt.Println(newPerson.Interface())  // {Bob 25}\n```\n\n### Unsafe Operations\n\n```go\nimport \"unsafe\"\n\n// Sizeof\nvar x int64 = 10\nsize := unsafe.Sizeof(x)  // 8 bytes\n\n// Alignof\nalignment := unsafe.Alignof(x)  // 8 bytes\n\n// Offsetof\ntype Sample struct {\n    a bool\n    b int64\n    c int32\n}\noffset := unsafe.Offsetof(Sample{}.b)  // Offset of field b\n\n// Pointer arithmetic (dangerous!)\narr := [3]int{1, 2, 3}\nptr := unsafe.Pointer(&arr[0])\n\n// Access second element\nsecond := (*int)(unsafe.Add(ptr, unsafe.Sizeof(arr[0])))\nfmt.Println(*second)  // 2\n\n// Convert between types (bypass type system)\nvar i int64 = 42\nvar f float64\nf = *(*float64)(unsafe.Pointer(&i))  // Reinterpret bits\n\n// String to []byte without copy\ns := \"hello\"\nbytes := *(*[]byte)(unsafe.Pointer(&s))\n\n// Struct padding\ntype Padded struct {\n    a bool   // 1 byte\n    // 7 bytes padding\n    b int64  // 8 bytes\n    c bool   // 1 byte\n    // 7 bytes padding\n}\nfmt.Println(unsafe.Sizeof(Padded{}))  // 24 bytes\n\n// Access private fields (don't do this!)\ntype private struct {\n    secret string\n}\n\np := private{secret: \"hidden\"}\nfield := reflect.ValueOf(&p).Elem().Field(0)\nptr = unsafe.Pointer(field.UnsafeAddr())\nsecret := *(*string)(ptr)\nfmt.Println(secret)  // \"hidden\"\n```\n\n### Build Tags and Conditional Compilation\n\n```go\n// +build linux,amd64\n\npackage main\n\n// File only compiled on Linux AMD64\n\n// Build tags\n// +build debug\n// +build !prod\n// +build linux darwin\n// +build 386 amd64\n\n// Go 1.17+ syntax\n//go:build linux && amd64\n\n// Custom build tags\n// go build -tags=\"debug,feature1\"\n\n// File naming conventions\n// file_linux.go       // Linux only\n// file_windows.go     // Windows only\n// file_amd64.go       // AMD64 only\n// file_test.go        // Test files\n\n// Conditional compilation in code\n// +build debug\n\nfunc debugLog(msg string) {\n    fmt.Println(\"[DEBUG]\", msg)\n}\n\n// +build !debug\n\nfunc debugLog(msg string) {\n    // No-op in production\n}\n```\n\n### CGO and Foreign Function Interface\n\n```go\n// #include <stdio.h>\n// #include <stdlib.h>\n//\n// static void myprint(const char* s) {\n//     printf(\"%s\\n\", s);\n// }\nimport \"C\"\nimport \"unsafe\"\n\nfunc main() {\n    cs := C.CString(\"Hello from C\")\n    defer C.free(unsafe.Pointer(cs))\n    C.myprint(cs)\n}\n\n// Calling Go from C\n//export GoFunction\nfunc GoFunction(x C.int) C.int {\n    return x * 2\n}\n\n// Linking with external libraries\n// #cgo LDFLAGS: -lm\n// #include <math.h>\nimport \"C\"\n\nfunc sqrt(x float64) float64 {\n    return float64(C.sqrt(C.double(x)))\n}\n```\n\n## Best Practices Summary\n\n1. **Keep it simple** - Don't over-engineer\n2. **Handle errors explicitly** - No exceptions in Go\n3. **Use channels for communication** - Not shared memory\n4. **Make the zero value useful** - Design types to work without initialization\n5. **Return early** - Reduce nesting with early returns\n6. **Document exported APIs** - All public functions need comments\n7. **Test everything** - Table-driven tests are idiomatic\n8. **Profile before optimizing** - Measure, don't guess\n9. **Respect context** - Pass context.Context for cancellation\n10. **Close resources** - Always defer Close() after acquiring resources","structuredPatch":[]}}
{"parentUuid":"6357ab51-dbc2-4388-b7b0-2063f07b3b68","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_012vSfDArbCv5w5j41rregtf","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01XJT9gAtFZrsAYwzqEp7Wm2","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/02-design-patterns.md","content":"# Go Design Patterns - Comprehensive Guide\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Concurrency Patterns](#concurrency-patterns)\n5. [Go-Specific Idioms](#go-specific-idioms)\n6. [Messaging Patterns](#messaging-patterns)\n7. [Error Handling Patterns](#error-handling-patterns)\n8. [Architecture Patterns](#architecture-patterns)\n\n## Creational Patterns\n\n### Singleton Pattern\n\n```go\n// Thread-safe singleton using sync.Once\npackage singleton\n\nimport (\n    \"database/sql\"\n    \"sync\"\n)\n\ntype Database struct {\n    conn *sql.DB\n}\n\nvar (\n    instance *Database\n    once     sync.Once\n)\n\nfunc GetInstance() *Database {\n    once.Do(func() {\n        conn, err := sql.Open(\"postgres\", \"connection-string\")\n        if err != nil {\n            panic(err)\n        }\n        instance = &Database{conn: conn}\n    })\n    return instance\n}\n\n// Alternative: Package-level variable (simpler)\nvar db = &Database{\n    conn: initDB(),\n}\n\nfunc initDB() *sql.DB {\n    conn, err := sql.Open(\"postgres\", \"connection-string\")\n    if err != nil {\n        panic(err)\n    }\n    return conn\n}\n\nfunc GetDB() *Database {\n    return db\n}\n```\n\n### Factory Pattern\n\n```go\n// Factory Method Pattern\npackage factory\n\ntype PaymentMethod interface {\n    Pay(amount float64) error\n    ValidateDetails() error\n}\n\ntype PaymentType string\n\nconst (\n    CreditCard PaymentType = \"credit_card\"\n    PayPal     PaymentType = \"paypal\"\n    Bitcoin    PaymentType = \"bitcoin\"\n)\n\n// Factory function\nfunc NewPaymentMethod(t PaymentType, details map[string]string) (PaymentMethod, error) {\n    switch t {\n    case CreditCard:\n        return &CreditCardPayment{\n            Number: details[\"number\"],\n            CVV:    details[\"cvv\"],\n            Expiry: details[\"expiry\"],\n        }, nil\n    case PayPal:\n        return &PayPalPayment{\n            Email:    details[\"email\"],\n            Password: details[\"password\"],\n        }, nil\n    case Bitcoin:\n        return &BitcoinPayment{\n            WalletAddress: details[\"wallet\"],\n            PrivateKey:    details[\"key\"],\n        }, nil\n    default:\n        return nil, fmt.Errorf(\"unsupported payment type: %s\", t)\n    }\n}\n\n// Abstract Factory Pattern\ntype ExchangeFactory interface {\n    CreateOrderClient() OrderClient\n    CreateMarketDataClient() MarketDataClient\n    CreateAccountClient() AccountClient\n}\n\ntype BinanceFactory struct {\n    apiKey    string\n    apiSecret string\n}\n\nfunc (f *BinanceFactory) CreateOrderClient() OrderClient {\n    return &BinanceOrderClient{\n        apiKey:    f.apiKey,\n        apiSecret: f.apiSecret,\n    }\n}\n\nfunc (f *BinanceFactory) CreateMarketDataClient() MarketDataClient {\n    return &BinanceMarketDataClient{}\n}\n\nfunc (f *BinanceFactory) CreateAccountClient() AccountClient {\n    return &BinanceAccountClient{\n        apiKey:    f.apiKey,\n        apiSecret: f.apiSecret,\n    }\n}\n\n// Factory Registry Pattern\ntype StrategyFactory func(config map[string]interface{}) (Strategy, error)\n\nvar strategyFactories = make(map[string]StrategyFactory)\n\nfunc RegisterStrategy(name string, factory StrategyFactory) {\n    strategyFactories[name] = factory\n}\n\nfunc CreateStrategy(name string, config map[string]interface{}) (Strategy, error) {\n    factory, exists := strategyFactories[name]\n    if !exists {\n        return nil, fmt.Errorf(\"strategy %s not registered\", name)\n    }\n    return factory(config)\n}\n\n// Usage with init()\nfunc init() {\n    RegisterStrategy(\"moving_average\", NewMovingAverageStrategy)\n    RegisterStrategy(\"mean_reversion\", NewMeanReversionStrategy)\n    RegisterStrategy(\"momentum\", NewMomentumStrategy)\n}\n```\n\n### Builder Pattern\n\n```go\n// Builder Pattern for complex objects\npackage builder\n\ntype Server struct {\n    host         string\n    port         int\n    timeout      time.Duration\n    maxConns     int\n    tls          bool\n    certFile     string\n    keyFile      string\n    middlewares  []Middleware\n}\n\ntype ServerBuilder struct {\n    server *Server\n}\n\nfunc NewServerBuilder() *ServerBuilder {\n    return &ServerBuilder{\n        server: &Server{\n            port:     8080,\n            timeout:  30 * time.Second,\n            maxConns: 100,\n        },\n    }\n}\n\nfunc (b *ServerBuilder) Host(host string) *ServerBuilder {\n    b.server.host = host\n    return b\n}\n\nfunc (b *ServerBuilder) Port(port int) *ServerBuilder {\n    b.server.port = port\n    return b\n}\n\nfunc (b *ServerBuilder) Timeout(timeout time.Duration) *ServerBuilder {\n    b.server.timeout = timeout\n    return b\n}\n\nfunc (b *ServerBuilder) MaxConnections(max int) *ServerBuilder {\n    b.server.maxConns = max\n    return b\n}\n\nfunc (b *ServerBuilder) EnableTLS(certFile, keyFile string) *ServerBuilder {\n    b.server.tls = true\n    b.server.certFile = certFile\n    b.server.keyFile = keyFile\n    return b\n}\n\nfunc (b *ServerBuilder) AddMiddleware(m Middleware) *ServerBuilder {\n    b.server.middlewares = append(b.server.middlewares, m)\n    return b\n}\n\nfunc (b *ServerBuilder) Build() (*Server, error) {\n    // Validation\n    if b.server.host == \"\" {\n        return nil, errors.New(\"host is required\")\n    }\n    if b.server.tls && (b.server.certFile == \"\" || b.server.keyFile == \"\") {\n        return nil, errors.New(\"cert and key files required for TLS\")\n    }\n    return b.server, nil\n}\n\n// Usage\nserver, err := NewServerBuilder().\n    Host(\"localhost\").\n    Port(8443).\n    Timeout(60 * time.Second).\n    EnableTLS(\"cert.pem\", \"key.pem\").\n    AddMiddleware(LoggingMiddleware()).\n    AddMiddleware(AuthMiddleware()).\n    Build()\n\n// Functional Options Pattern (Go idiomatic alternative)\ntype Option func(*Server)\n\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTLS(certFile, keyFile string) Option {\n    return func(s *Server) {\n        s.tls = true\n        s.certFile = certFile\n        s.keyFile = keyFile\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    // Default values\n    s := &Server{\n        host:     \"localhost\",\n        port:     8080,\n        timeout:  30 * time.Second,\n        maxConns: 100,\n    }\n    \n    // Apply options\n    for _, opt := range opts {\n        opt(s)\n    }\n    \n    return s\n}\n\n// Usage with functional options\nserver := NewServer(\n    WithHost(\"api.example.com\"),\n    WithPort(443),\n    WithTLS(\"cert.pem\", \"key.pem\"),\n)\n```\n\n### Prototype Pattern\n\n```go\n// Prototype Pattern - cloning objects\npackage prototype\n\ntype Cloneable interface {\n    Clone() Cloneable\n}\n\ntype OrderTemplate struct {\n    Exchange   string\n    Symbol     string\n    OrderType  string\n    TimeInForce string\n    Settings   map[string]interface{}\n}\n\nfunc (o *OrderTemplate) Clone() Cloneable {\n    // Deep copy of settings\n    settings := make(map[string]interface{})\n    for k, v := range o.Settings {\n        settings[k] = v\n    }\n    \n    return &OrderTemplate{\n        Exchange:    o.Exchange,\n        Symbol:      o.Symbol,\n        OrderType:   o.OrderType,\n        TimeInForce: o.TimeInForce,\n        Settings:    settings,\n    }\n}\n\n// Prototype Registry\ntype PrototypeRegistry struct {\n    prototypes map[string]Cloneable\n}\n\nfunc NewPrototypeRegistry() *PrototypeRegistry {\n    return &PrototypeRegistry{\n        prototypes: make(map[string]Cloneable),\n    }\n}\n\nfunc (r *PrototypeRegistry) Register(name string, prototype Cloneable) {\n    r.prototypes[name] = prototype\n}\n\nfunc (r *PrototypeRegistry) Create(name string) (Cloneable, error) {\n    prototype, exists := r.prototypes[name]\n    if !exists {\n        return nil, fmt.Errorf(\"prototype %s not found\", name)\n    }\n    return prototype.Clone(), nil\n}\n\n// Usage\nregistry := NewPrototypeRegistry()\nregistry.Register(\"market_order\", &OrderTemplate{\n    OrderType:   \"MARKET\",\n    TimeInForce: \"IOC\",\n})\nregistry.Register(\"limit_order\", &OrderTemplate{\n    OrderType:   \"LIMIT\",\n    TimeInForce: \"GTC\",\n})\n\norder, _ := registry.Create(\"market_order\")\n```\n\n### Object Pool Pattern\n\n```go\n// Object Pool Pattern - reuse expensive objects\npackage pool\n\nimport (\n    \"sync\"\n)\n\ntype Connection struct {\n    id   int\n    host string\n}\n\nfunc (c *Connection) Reset() {\n    // Reset connection state\n}\n\ntype ConnectionPool struct {\n    mu          sync.Mutex\n    connections chan *Connection\n    factory     func() *Connection\n}\n\nfunc NewConnectionPool(size int, factory func() *Connection) *ConnectionPool {\n    pool := &ConnectionPool{\n        connections: make(chan *Connection, size),\n        factory:     factory,\n    }\n    \n    // Pre-populate pool\n    for i := 0; i < size; i++ {\n        conn := factory()\n        conn.id = i\n        pool.connections <- conn\n    }\n    \n    return pool\n}\n\nfunc (p *ConnectionPool) Get() *Connection {\n    select {\n    case conn := <-p.connections:\n        return conn\n    default:\n        // Pool empty, create new connection\n        return p.factory()\n    }\n}\n\nfunc (p *ConnectionPool) Put(conn *Connection) {\n    conn.Reset()\n    \n    select {\n    case p.connections <- conn:\n        // Connection returned to pool\n    default:\n        // Pool full, discard connection\n    }\n}\n\n// Using sync.Pool (Go standard library)\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 1024)\n    },\n}\n\nfunc ProcessData(data []byte) {\n    buffer := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buffer)\n    \n    // Use buffer for processing\n    copy(buffer, data)\n    // Process...\n}\n```\n\n## Structural Patterns\n\n### Adapter Pattern\n\n```go\n// Adapter Pattern - make incompatible interfaces work together\npackage adapter\n\n// Target interface (what we want)\ntype ModernPaymentGateway interface {\n    MakePayment(amount float64, currency string) error\n    RefundPayment(transactionID string) error\n}\n\n// Adaptee (legacy system)\ntype LegacyPaymentSystem struct{}\n\nfunc (l *LegacyPaymentSystem) SubmitPayment(cents int64) string {\n    // Legacy implementation\n    return fmt.Sprintf(\"TXN-%d\", time.Now().Unix())\n}\n\nfunc (l *LegacyPaymentSystem) CancelTransaction(txnCode string) bool {\n    // Legacy implementation\n    return true\n}\n\n// Adapter\ntype PaymentAdapter struct {\n    legacy *LegacyPaymentSystem\n}\n\nfunc NewPaymentAdapter(legacy *LegacyPaymentSystem) ModernPaymentGateway {\n    return &PaymentAdapter{legacy: legacy}\n}\n\nfunc (a *PaymentAdapter) MakePayment(amount float64, currency string) error {\n    // Convert to cents for legacy system\n    cents := int64(amount * 100)\n    \n    txnID := a.legacy.SubmitPayment(cents)\n    if txnID == \"\" {\n        return errors.New(\"payment failed\")\n    }\n    \n    return nil\n}\n\nfunc (a *PaymentAdapter) RefundPayment(transactionID string) error {\n    success := a.legacy.CancelTransaction(transactionID)\n    if !success {\n        return errors.New(\"refund failed\")\n    }\n    return nil\n}\n\n// Interface Adapter for multiple types\ntype DataSource interface {\n    GetData() ([]byte, error)\n}\n\n// Adapt io.Reader to DataSource\ntype ReaderAdapter struct {\n    reader io.Reader\n}\n\nfunc (r *ReaderAdapter) GetData() ([]byte, error) {\n    return ioutil.ReadAll(r.reader)\n}\n\n// Adapt string to DataSource\ntype StringAdapter struct {\n    data string\n}\n\nfunc (s *StringAdapter) GetData() ([]byte, error) {\n    return []byte(s.data), nil\n}\n\n// Adapt file path to DataSource\ntype FileAdapter struct {\n    path string\n}\n\nfunc (f *FileAdapter) GetData() ([]byte, error) {\n    return ioutil.ReadFile(f.path)\n}\n```\n\n### Decorator Pattern\n\n```go\n// Decorator Pattern - add functionality without altering structure\npackage decorator\n\n// Component interface\ntype DataProcessor interface {\n    Process(data []byte) ([]byte, error)\n}\n\n// Concrete component\ntype BasicProcessor struct{}\n\nfunc (p *BasicProcessor) Process(data []byte) ([]byte, error) {\n    // Basic processing\n    return data, nil\n}\n\n// Decorator base\ntype ProcessorDecorator struct {\n    processor DataProcessor\n}\n\n// Compression decorator\ntype CompressionDecorator struct {\n    ProcessorDecorator\n}\n\nfunc NewCompressionDecorator(p DataProcessor) DataProcessor {\n    return &CompressionDecorator{\n        ProcessorDecorator{processor: p},\n    }\n}\n\nfunc (d *CompressionDecorator) Process(data []byte) ([]byte, error) {\n    // Process with wrapped processor first\n    processed, err := d.processor.Process(data)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Add compression\n    var buf bytes.Buffer\n    w := gzip.NewWriter(&buf)\n    _, err = w.Write(processed)\n    w.Close()\n    \n    return buf.Bytes(), err\n}\n\n// Encryption decorator\ntype EncryptionDecorator struct {\n    ProcessorDecorator\n    key []byte\n}\n\nfunc NewEncryptionDecorator(p DataProcessor, key []byte) DataProcessor {\n    return &EncryptionDecorator{\n        ProcessorDecorator: ProcessorDecorator{processor: p},\n        key:                key,\n    }\n}\n\nfunc (d *EncryptionDecorator) Process(data []byte) ([]byte, error) {\n    processed, err := d.processor.Process(data)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Add encryption\n    encrypted := encrypt(processed, d.key)\n    return encrypted, nil\n}\n\n// Logging decorator\ntype LoggingDecorator struct {\n    ProcessorDecorator\n    logger *log.Logger\n}\n\nfunc NewLoggingDecorator(p DataProcessor, logger *log.Logger) DataProcessor {\n    return &LoggingDecorator{\n        ProcessorDecorator: ProcessorDecorator{processor: p},\n        logger:             logger,\n    }\n}\n\nfunc (d *LoggingDecorator) Process(data []byte) ([]byte, error) {\n    d.logger.Printf(\"Processing %d bytes\", len(data))\n    start := time.Now()\n    \n    result, err := d.processor.Process(data)\n    \n    d.logger.Printf(\"Processing completed in %v\", time.Since(start))\n    return result, err\n}\n\n// Usage - chain decorators\nprocessor := NewLoggingDecorator(\n    NewCompressionDecorator(\n        NewEncryptionDecorator(\n            &BasicProcessor{},\n            encryptionKey,\n        ),\n    ),\n    logger,\n)\n\nresult, err := processor.Process(data)\n\n// HTTP Middleware Decorator Pattern\ntype Middleware func(http.HandlerFunc) http.HandlerFunc\n\nfunc Logging(next http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        next(w, r)\n        log.Printf(\"%s %s %v\", r.Method, r.URL.Path, time.Since(start))\n    }\n}\n\nfunc Authentication(next http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        token := r.Header.Get(\"Authorization\")\n        if !isValidToken(token) {\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n        next(w, r)\n    }\n}\n\nfunc RateLimiting(limit int) Middleware {\n    limiter := rate.NewLimiter(rate.Limit(limit), 1)\n    \n    return func(next http.HandlerFunc) http.HandlerFunc {\n        return func(w http.ResponseWriter, r *http.Request) {\n            if !limiter.Allow() {\n                http.Error(w, \"Too Many Requests\", http.StatusTooManyRequests)\n                return\n            }\n            next(w, r)\n        }\n    }\n}\n\n// Chain middlewares\nhandler := Logging(\n    Authentication(\n        RateLimiting(100)(\n            finalHandler,\n        ),\n    ),\n)\n```\n\n### Proxy Pattern\n\n```go\n// Proxy Pattern - provide placeholder/surrogate\npackage proxy\n\n// Subject interface\ntype Database interface {\n    Query(sql string) ([]Row, error)\n    Execute(sql string) error\n}\n\n// Real subject\ntype PostgresDB struct {\n    connectionString string\n    conn             *sql.DB\n}\n\nfunc (db *PostgresDB) Query(sql string) ([]Row, error) {\n    // Actual database query\n    return db.executeQuery(sql)\n}\n\nfunc (db *PostgresDB) Execute(sql string) error {\n    // Actual database execution\n    return db.executeStatement(sql)\n}\n\n// Caching Proxy\ntype CachingDBProxy struct {\n    realDB Database\n    cache  map[string][]Row\n    mu     sync.RWMutex\n}\n\nfunc NewCachingDBProxy(db Database) Database {\n    return &CachingDBProxy{\n        realDB: db,\n        cache:  make(map[string][]Row),\n    }\n}\n\nfunc (p *CachingDBProxy) Query(sql string) ([]Row, error) {\n    // Check cache first\n    p.mu.RLock()\n    if rows, found := p.cache[sql]; found {\n        p.mu.RUnlock()\n        return rows, nil\n    }\n    p.mu.RUnlock()\n    \n    // Cache miss, query real database\n    rows, err := p.realDB.Query(sql)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Update cache\n    p.mu.Lock()\n    p.cache[sql] = rows\n    p.mu.Unlock()\n    \n    return rows, nil\n}\n\nfunc (p *CachingDBProxy) Execute(sql string) error {\n    // Clear cache on write operations\n    p.mu.Lock()\n    p.cache = make(map[string][]Row)\n    p.mu.Unlock()\n    \n    return p.realDB.Execute(sql)\n}\n\n// Virtual Proxy (Lazy Loading)\ntype Image interface {\n    Display()\n    GetDimensions() (int, int)\n}\n\ntype RealImage struct {\n    filename string\n    data     []byte\n    width    int\n    height   int\n}\n\nfunc NewRealImage(filename string) *RealImage {\n    img := &RealImage{filename: filename}\n    img.load()\n    return img\n}\n\nfunc (i *RealImage) load() {\n    // Expensive operation\n    i.data = loadImageFromDisk(i.filename)\n    i.width, i.height = getImageDimensions(i.data)\n}\n\nfunc (i *RealImage) Display() {\n    renderImage(i.data)\n}\n\nfunc (i *RealImage) GetDimensions() (int, int) {\n    return i.width, i.height\n}\n\n// Virtual Proxy\ntype ImageProxy struct {\n    filename  string\n    realImage *RealImage\n}\n\nfunc NewImageProxy(filename string) Image {\n    return &ImageProxy{filename: filename}\n}\n\nfunc (p *ImageProxy) Display() {\n    if p.realImage == nil {\n        p.realImage = NewRealImage(p.filename)\n    }\n    p.realImage.Display()\n}\n\nfunc (p *ImageProxy) GetDimensions() (int, int) {\n    if p.realImage == nil {\n        p.realImage = NewRealImage(p.filename)\n    }\n    return p.realImage.GetDimensions()\n}\n\n// Protection Proxy\ntype BankAccount interface {\n    Deposit(amount float64)\n    Withdraw(amount float64) error\n    GetBalance() float64\n}\n\ntype SecureBankAccountProxy struct {\n    account     BankAccount\n    permissions map[string]bool\n    user        string\n}\n\nfunc (p *SecureBankAccountProxy) Withdraw(amount float64) error {\n    if !p.permissions[\"withdraw\"] {\n        return errors.New(\"permission denied: withdraw\")\n    }\n    \n    log.Printf(\"User %s withdrawing %.2f\", p.user, amount)\n    return p.account.Withdraw(amount)\n}\n\nfunc (p *SecureBankAccountProxy) Deposit(amount float64) {\n    if !p.permissions[\"deposit\"] {\n        log.Printf(\"Permission denied for user %s\", p.user)\n        return\n    }\n    \n    p.account.Deposit(amount)\n}\n\nfunc (p *SecureBankAccountProxy) GetBalance() float64 {\n    if !p.permissions[\"view\"] {\n        return 0\n    }\n    return p.account.GetBalance()\n}\n```\n\n### Facade Pattern\n\n```go\n// Facade Pattern - simplified interface to complex subsystem\npackage facade\n\n// Complex subsystem components\ntype OrderService struct{}\n\nfunc (s *OrderService) CreateOrder(symbol string, quantity float64, orderType string) (*Order, error) {\n    // Complex order creation logic\n    return &Order{}, nil\n}\n\nfunc (s *OrderService) ValidateOrder(order *Order) error {\n    // Validation logic\n    return nil\n}\n\ntype RiskManager struct{}\n\nfunc (r *RiskManager) CheckRiskLimits(order *Order) error {\n    // Risk checking logic\n    return nil\n}\n\nfunc (r *RiskManager) CalculatePositionSize(balance, risk float64) float64 {\n    // Position sizing logic\n    return balance * risk\n}\n\ntype MarketDataService struct{}\n\nfunc (m *MarketDataService) GetCurrentPrice(symbol string) (float64, error) {\n    // Fetch market data\n    return 100.0, nil\n}\n\nfunc (m *MarketDataService) GetOrderBook(symbol string) (*OrderBook, error) {\n    // Fetch order book\n    return &OrderBook{}, nil\n}\n\ntype ExecutionEngine struct{}\n\nfunc (e *ExecutionEngine) SendOrder(order *Order) error {\n    // Send order to exchange\n    return nil\n}\n\nfunc (e *ExecutionEngine) CancelOrder(orderID string) error {\n    // Cancel order\n    return nil\n}\n\n// Facade\ntype TradingFacade struct {\n    orderService   *OrderService\n    riskManager    *RiskManager\n    marketData     *MarketDataService\n    execution      *ExecutionEngine\n}\n\nfunc NewTradingFacade() *TradingFacade {\n    return &TradingFacade{\n        orderService:   &OrderService{},\n        riskManager:    &RiskManager{},\n        marketData:     &MarketDataService{},\n        execution:      &ExecutionEngine{},\n    }\n}\n\n// Simplified interface\nfunc (f *TradingFacade) PlaceMarketOrder(symbol string, quantity float64) error {\n    // Get current price\n    price, err := f.marketData.GetCurrentPrice(symbol)\n    if err != nil {\n        return fmt.Errorf(\"failed to get price: %w\", err)\n    }\n    \n    // Create order\n    order, err := f.orderService.CreateOrder(symbol, quantity, \"MARKET\")\n    if err != nil {\n        return fmt.Errorf(\"failed to create order: %w\", err)\n    }\n    \n    // Validate order\n    if err := f.orderService.ValidateOrder(order); err != nil {\n        return fmt.Errorf(\"order validation failed: %w\", err)\n    }\n    \n    // Check risk\n    if err := f.riskManager.CheckRiskLimits(order); err != nil {\n        return fmt.Errorf(\"risk check failed: %w\", err)\n    }\n    \n    // Execute order\n    if err := f.execution.SendOrder(order); err != nil {\n        return fmt.Errorf(\"execution failed: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (f *TradingFacade) PlaceLimitOrder(symbol string, quantity, price float64) error {\n    // Simplified limit order placement\n    order, err := f.orderService.CreateOrder(symbol, quantity, \"LIMIT\")\n    if err != nil {\n        return err\n    }\n    \n    order.Price = price\n    \n    if err := f.orderService.ValidateOrder(order); err != nil {\n        return err\n    }\n    \n    if err := f.riskManager.CheckRiskLimits(order); err != nil {\n        return err\n    }\n    \n    return f.execution.SendOrder(order)\n}\n\nfunc (f *TradingFacade) GetMarketSnapshot(symbol string) (*MarketSnapshot, error) {\n    price, err := f.marketData.GetCurrentPrice(symbol)\n    if err != nil {\n        return nil, err\n    }\n    \n    orderBook, err := f.marketData.GetOrderBook(symbol)\n    if err != nil {\n        return nil, err\n    }\n    \n    return &MarketSnapshot{\n        Symbol:    symbol,\n        Price:     price,\n        OrderBook: orderBook,\n        Timestamp: time.Now(),\n    }, nil\n}\n```\n\n### Bridge Pattern\n\n```go\n// Bridge Pattern - decouple abstraction from implementation\npackage bridge\n\n// Implementation interface\ntype MessageSender interface {\n    Send(recipient, message string) error\n    GetDeliveryStatus(messageID string) (string, error)\n}\n\n// Concrete implementations\ntype EmailSender struct {\n    smtpServer string\n}\n\nfunc (e *EmailSender) Send(recipient, message string) error {\n    // Send email via SMTP\n    return nil\n}\n\nfunc (e *EmailSender) GetDeliveryStatus(messageID string) (string, error) {\n    return \"delivered\", nil\n}\n\ntype SMSSender struct {\n    apiKey string\n}\n\nfunc (s *SMSSender) Send(recipient, message string) error {\n    // Send SMS via API\n    return nil\n}\n\nfunc (s *SMSSender) GetDeliveryStatus(messageID string) (string, error) {\n    return \"sent\", nil\n}\n\ntype SlackSender struct {\n    webhookURL string\n}\n\nfunc (s *SlackSender) Send(recipient, message string) error {\n    // Send to Slack channel\n    return nil\n}\n\nfunc (s *SlackSender) GetDeliveryStatus(messageID string) (string, error) {\n    return \"posted\", nil\n}\n\n// Abstraction\ntype Notification struct {\n    sender MessageSender\n}\n\nfunc NewNotification(sender MessageSender) *Notification {\n    return &Notification{sender: sender}\n}\n\nfunc (n *Notification) Notify(recipient, message string) error {\n    return n.sender.Send(recipient, message)\n}\n\n// Refined abstractions\ntype UrgentNotification struct {\n    Notification\n}\n\nfunc NewUrgentNotification(sender MessageSender) *UrgentNotification {\n    return &UrgentNotification{\n        Notification{sender: sender},\n    }\n}\n\nfunc (u *UrgentNotification) Notify(recipient, message string) error {\n    urgentMessage := fmt.Sprintf(\"URGENT: %s\", message)\n    \n    // Send multiple times for urgent messages\n    for i := 0; i < 3; i++ {\n        if err := u.sender.Send(recipient, urgentMessage); err != nil {\n            return err\n        }\n        time.Sleep(time.Second)\n    }\n    \n    return nil\n}\n\ntype ScheduledNotification struct {\n    Notification\n    scheduleTime time.Time\n}\n\nfunc NewScheduledNotification(sender MessageSender, when time.Time) *ScheduledNotification {\n    return &ScheduledNotification{\n        Notification:  Notification{sender: sender},\n        scheduleTime: when,\n    }\n}\n\nfunc (s *ScheduledNotification) Notify(recipient, message string) error {\n    waitTime := time.Until(s.scheduleTime)\n    if waitTime > 0 {\n        time.Sleep(waitTime)\n    }\n    \n    return s.sender.Send(recipient, message)\n}\n\n// Usage - can mix and match abstractions with implementations\nemailNotification := NewNotification(&EmailSender{smtpServer: \"smtp.gmail.com\"})\nsmsUrgentNotification := NewUrgentNotification(&SMSSender{apiKey: \"api-key\"})\nslackScheduledNotification := NewScheduledNotification(\n    &SlackSender{webhookURL: \"https://hooks.slack.com/...\"},\n    time.Now().Add(time.Hour),\n)\n```\n\n### Composite Pattern\n\n```go\n// Composite Pattern - tree structure of objects\npackage composite\n\n// Component interface\ntype FileSystemNode interface {\n    GetName() string\n    GetSize() int64\n    Display(indent string)\n    Search(name string) *File\n}\n\n// Leaf\ntype File struct {\n    name string\n    size int64\n}\n\nfunc (f *File) GetName() string {\n    return f.name\n}\n\nfunc (f *File) GetSize() int64 {\n    return f.size\n}\n\nfunc (f *File) Display(indent string) {\n    fmt.Printf(\"%s- %s (%d bytes)\\n\", indent, f.name, f.size)\n}\n\nfunc (f *File) Search(name string) *File {\n    if f.name == name {\n        return f\n    }\n    return nil\n}\n\n// Composite\ntype Directory struct {\n    name     string\n    children []FileSystemNode\n}\n\nfunc (d *Directory) GetName() string {\n    return d.name\n}\n\nfunc (d *Directory) GetSize() int64 {\n    var total int64\n    for _, child := range d.children {\n        total += child.GetSize()\n    }\n    return total\n}\n\nfunc (d *Directory) Display(indent string) {\n    fmt.Printf(\"%s+ %s/ (%d bytes)\\n\", indent, d.name, d.GetSize())\n    for _, child := range d.children {\n        child.Display(indent + \"  \")\n    }\n}\n\nfunc (d *Directory) Add(child FileSystemNode) {\n    d.children = append(d.children, child)\n}\n\nfunc (d *Directory) Remove(child FileSystemNode) {\n    for i, c := range d.children {\n        if c == child {\n            d.children = append(d.children[:i], d.children[i+1:]...)\n            return\n        }\n    }\n}\n\nfunc (d *Directory) Search(name string) *File {\n    for _, child := range d.children {\n        if result := child.Search(name); result != nil {\n            return result\n        }\n    }\n    return nil\n}\n\n// Usage\nroot := &Directory{name: \"root\"}\nhome := &Directory{name: \"home\"}\nuser := &Directory{name: \"user\"}\ndocuments := &Directory{name: \"documents\"}\n\nfile1 := &File{name: \"readme.txt\", size: 1024}\nfile2 := &File{name: \"photo.jpg\", size: 2048}\nfile3 := &File{name: \"report.pdf\", size: 4096}\n\ndocuments.Add(file1)\ndocuments.Add(file2)\nuser.Add(documents)\nuser.Add(file3)\nhome.Add(user)\nroot.Add(home)\n\nroot.Display(\"\")\nfmt.Printf(\"Total size: %d bytes\\n\", root.GetSize())\n\n// Trading Strategy Composite Example\ntype StrategyComponent interface {\n    Evaluate(data MarketData) Signal\n    GetName() string\n}\n\ntype SimpleIndicator struct {\n    name string\n    calc func(MarketData) float64\n}\n\nfunc (s *SimpleIndicator) Evaluate(data MarketData) Signal {\n    value := s.calc(data)\n    if value > 0 {\n        return BuySignal\n    }\n    return SellSignal\n}\n\nfunc (s *SimpleIndicator) GetName() string {\n    return s.name\n}\n\ntype CompositeStrategy struct {\n    name       string\n    strategies []StrategyComponent\n    combiner   func([]Signal) Signal\n}\n\nfunc (c *CompositeStrategy) Evaluate(data MarketData) Signal {\n    signals := make([]Signal, len(c.strategies))\n    for i, strategy := range c.strategies {\n        signals[i] = strategy.Evaluate(data)\n    }\n    return c.combiner(signals)\n}\n\nfunc (c *CompositeStrategy) GetName() string {\n    return c.name\n}\n\nfunc (c *CompositeStrategy) Add(strategy StrategyComponent) {\n    c.strategies = append(c.strategies, strategy)\n}\n\n// Combine strategies hierarchically\nmainStrategy := &CompositeStrategy{\n    name: \"Main Strategy\",\n    combiner: func(signals []Signal) Signal {\n        // Majority vote\n        buyCount := 0\n        for _, s := range signals {\n            if s == BuySignal {\n                buyCount++\n            }\n        }\n        if buyCount > len(signals)/2 {\n            return BuySignal\n        }\n        return SellSignal\n    },\n}\n\nmomentumStrategy := &CompositeStrategy{\n    name: \"Momentum\",\n    combiner: unanimousVote,\n}\n\nmomentumStrategy.Add(&SimpleIndicator{name: \"RSI\", calc: calculateRSI})\nmomentumStrategy.Add(&SimpleIndicator{name: \"MACD\", calc: calculateMACD})\n\nmainStrategy.Add(momentumStrategy)\nmainStrategy.Add(&SimpleIndicator{name: \"MA Cross\", calc: calculateMACross})\n```\n\n## Behavioral Patterns\n\n### Observer Pattern\n\n```go\n// Observer Pattern - define one-to-many dependency\npackage observer\n\n// Subject interface\ntype Subject interface {\n    Attach(Observer)\n    Detach(Observer)\n    Notify()\n}\n\n// Observer interface\ntype Observer interface {\n    Update(data interface{})\n    GetID() string\n}\n\n// Concrete Subject\ntype PricePublisher struct {\n    observers map[string]Observer\n    price     float64\n    symbol    string\n    mu        sync.RWMutex\n}\n\nfunc NewPricePublisher(symbol string) *PricePublisher {\n    return &PricePublisher{\n        observers: make(map[string]Observer),\n        symbol:    symbol,\n    }\n}\n\nfunc (p *PricePublisher) Attach(observer Observer) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    p.observers[observer.GetID()] = observer\n}\n\nfunc (p *PricePublisher) Detach(observer Observer) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    delete(p.observers, observer.GetID())\n}\n\nfunc (p *PricePublisher) Notify() {\n    p.mu.RLock()\n    defer p.mu.RUnlock()\n    \n    for _, observer := range p.observers {\n        go observer.Update(PriceUpdate{\n            Symbol: p.symbol,\n            Price:  p.price,\n            Time:   time.Now(),\n        })\n    }\n}\n\nfunc (p *PricePublisher) SetPrice(price float64) {\n    p.mu.Lock()\n    p.price = price\n    p.mu.Unlock()\n    p.Notify()\n}\n\n// Concrete Observers\ntype TradingBot struct {\n    id       string\n    strategy Strategy\n}\n\nfunc (t *TradingBot) Update(data interface{}) {\n    if priceUpdate, ok := data.(PriceUpdate); ok {\n        signal := t.strategy.Analyze(priceUpdate)\n        if signal != HoldSignal {\n            t.executeTrade(signal, priceUpdate)\n        }\n    }\n}\n\nfunc (t *TradingBot) GetID() string {\n    return t.id\n}\n\ntype PriceLogger struct {\n    id     string\n    logger *log.Logger\n}\n\nfunc (p *PriceLogger) Update(data interface{}) {\n    if priceUpdate, ok := data.(PriceUpdate); ok {\n        p.logger.Printf(\"Price update: %s = %.2f at %s\",\n            priceUpdate.Symbol,\n            priceUpdate.Price,\n            priceUpdate.Time.Format(time.RFC3339))\n    }\n}\n\nfunc (p *PriceLogger) GetID() string {\n    return p.id\n}\n\n// Event-based Observer with channels\ntype EventBus struct {\n    subscribers map[string][]chan Event\n    mu          sync.RWMutex\n}\n\nfunc NewEventBus() *EventBus {\n    return &EventBus{\n        subscribers: make(map[string][]chan Event),\n    }\n}\n\nfunc (e *EventBus) Subscribe(eventType string, ch chan Event) {\n    e.mu.Lock()\n    defer e.mu.Unlock()\n    e.subscribers[eventType] = append(e.subscribers[eventType], ch)\n}\n\nfunc (e *EventBus) Publish(event Event) {\n    e.mu.RLock()\n    defer e.mu.RUnlock()\n    \n    if channels, found := e.subscribers[event.Type]; found {\n        for _, ch := range channels {\n            go func(c chan Event) {\n                c <- event\n            }(ch)\n        }\n    }\n}\n\n// Generic Observer with type parameters (Go 1.18+)\ntype TypedSubject[T any] struct {\n    observers []func(T)\n    mu        sync.RWMutex\n}\n\nfunc NewTypedSubject[T any]() *TypedSubject[T] {\n    return &TypedSubject[T]{\n        observers: make([]func(T), 0),\n    }\n}\n\nfunc (s *TypedSubject[T]) Subscribe(handler func(T)) func() {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    \n    s.observers = append(s.observers, handler)\n    \n    // Return unsubscribe function\n    return func() {\n        s.mu.Lock()\n        defer s.mu.Unlock()\n        for i, obs := range s.observers {\n            if &obs == &handler {\n                s.observers = append(s.observers[:i], s.observers[i+1:]...)\n                break\n            }\n        }\n    }\n}\n\nfunc (s *TypedSubject[T]) Notify(data T) {\n    s.mu.RLock()\n    observers := make([]func(T), len(s.observers))\n    copy(observers, s.observers)\n    s.mu.RUnlock()\n    \n    for _, observer := range observers {\n        go observer(data)\n    }\n}\n```\n\n### Strategy Pattern\n\n```go\n// Strategy Pattern - define family of algorithms\npackage strategy\n\n// Strategy interface\ntype PaymentStrategy interface {\n    Pay(amount float64) error\n    ValidatePaymentDetails() error\n}\n\n// Concrete strategies\ntype CreditCardStrategy struct {\n    cardNumber string\n    cvv        string\n    expiry     string\n}\n\nfunc (c *CreditCardStrategy) Pay(amount float64) error {\n    if err := c.ValidatePaymentDetails(); err != nil {\n        return err\n    }\n    \n    // Process credit card payment\n    fmt.Printf(\"Paid %.2f using Credit Card ending in %s\\n\",\n        amount, c.cardNumber[len(c.cardNumber)-4:])\n    return nil\n}\n\nfunc (c *CreditCardStrategy) ValidatePaymentDetails() error {\n    if len(c.cardNumber) != 16 {\n        return errors.New(\"invalid card number\")\n    }\n    if len(c.cvv) != 3 {\n        return errors.New(\"invalid CVV\")\n    }\n    return nil\n}\n\ntype PayPalStrategy struct {\n    email    string\n    password string\n}\n\nfunc (p *PayPalStrategy) Pay(amount float64) error {\n    if err := p.ValidatePaymentDetails(); err != nil {\n        return err\n    }\n    \n    // Process PayPal payment\n    fmt.Printf(\"Paid %.2f using PayPal account %s\\n\", amount, p.email)\n    return nil\n}\n\nfunc (p *PayPalStrategy) ValidatePaymentDetails() error {\n    if !strings.Contains(p.email, \"@\") {\n        return errors.New(\"invalid email\")\n    }\n    if len(p.password) < 8 {\n        return errors.New(\"invalid password\")\n    }\n    return nil\n}\n\ntype CryptoStrategy struct {\n    walletAddress string\n    privateKey    string\n    currency      string\n}\n\nfunc (c *CryptoStrategy) Pay(amount float64) error {\n    if err := c.ValidatePaymentDetails(); err != nil {\n        return err\n    }\n    \n    // Process cryptocurrency payment\n    fmt.Printf(\"Paid %.2f %s from wallet %s\\n\",\n        amount, c.currency, c.walletAddress[:10]+\"...\")\n    return nil\n}\n\nfunc (c *CryptoStrategy) ValidatePaymentDetails() error {\n    if len(c.walletAddress) < 26 {\n        return errors.New(\"invalid wallet address\")\n    }\n    if len(c.privateKey) < 32 {\n        return errors.New(\"invalid private key\")\n    }\n    return nil\n}\n\n// Context\ntype PaymentProcessor struct {\n    strategy PaymentStrategy\n}\n\nfunc (p *PaymentProcessor) SetStrategy(strategy PaymentStrategy) {\n    p.strategy = strategy\n}\n\nfunc (p *PaymentProcessor) ProcessPayment(amount float64) error {\n    if p.strategy == nil {\n        return errors.New(\"payment strategy not set\")\n    }\n    return p.strategy.Pay(amount)\n}\n\n// Trading Strategy Example\ntype TradingStrategy interface {\n    ShouldBuy(data MarketData) bool\n    ShouldSell(data MarketData) bool\n    GetStopLoss(entryPrice float64) float64\n    GetTakeProfit(entryPrice float64) float64\n}\n\ntype MomentumStrategy struct {\n    period    int\n    threshold float64\n}\n\nfunc (m *MomentumStrategy) ShouldBuy(data MarketData) bool {\n    momentum := calculateMomentum(data.Prices, m.period)\n    return momentum > m.threshold\n}\n\nfunc (m *MomentumStrategy) ShouldSell(data MarketData) bool {\n    momentum := calculateMomentum(data.Prices, m.period)\n    return momentum < -m.threshold\n}\n\nfunc (m *MomentumStrategy) GetStopLoss(entryPrice float64) float64 {\n    return entryPrice * 0.98 // 2% stop loss\n}\n\nfunc (m *MomentumStrategy) GetTakeProfit(entryPrice float64) float64 {\n    return entryPrice * 1.05 // 5% take profit\n}\n\ntype MeanReversionStrategy struct {\n    period      int\n    stdDevMulti float64\n}\n\nfunc (m *MeanReversionStrategy) ShouldBuy(data MarketData) bool {\n    mean, stdDev := calculateBollingerBands(data.Prices, m.period)\n    currentPrice := data.Prices[len(data.Prices)-1]\n    return currentPrice < mean-stdDev*m.stdDevMulti\n}\n\nfunc (m *MeanReversionStrategy) ShouldSell(data MarketData) bool {\n    mean, stdDev := calculateBollingerBands(data.Prices, m.period)\n    currentPrice := data.Prices[len(data.Prices)-1]\n    return currentPrice > mean+stdDev*m.stdDevMulti\n}\n\nfunc (m *MeanReversionStrategy) GetStopLoss(entryPrice float64) float64 {\n    return entryPrice * 0.95 // 5% stop loss\n}\n\nfunc (m *MeanReversionStrategy) GetTakeProfit(entryPrice float64) float64 {\n    return entryPrice * 1.02 // 2% take profit\n}\n\n// Strategy Factory\nfunc CreateStrategy(name string, params map[string]interface{}) (TradingStrategy, error) {\n    switch name {\n    case \"momentum\":\n        return &MomentumStrategy{\n            period:    params[\"period\"].(int),\n            threshold: params[\"threshold\"].(float64),\n        }, nil\n    case \"mean_reversion\":\n        return &MeanReversionStrategy{\n            period:      params[\"period\"].(int),\n            stdDevMulti: params[\"std_dev\"].(float64),\n        }, nil\n    default:\n        return nil, fmt.Errorf(\"unknown strategy: %s\", name)\n    }\n}\n```\n\n## Concurrency Patterns\n\n### Worker Pool Pattern\n\n```go\n// Worker Pool Pattern\npackage concurrency\n\ntype Job struct {\n    ID   int\n    Data interface{}\n}\n\ntype Result struct {\n    JobID int\n    Data  interface{}\n    Error error\n}\n\ntype WorkerPool struct {\n    workers    int\n    jobs       chan Job\n    results    chan Result\n    done       chan struct{}\n    wg         sync.WaitGroup\n}\n\nfunc NewWorkerPool(workers int, jobBuffer int) *WorkerPool {\n    return &WorkerPool{\n        workers: workers,\n        jobs:    make(chan Job, jobBuffer),\n        results: make(chan Result, jobBuffer),\n        done:    make(chan struct{}),\n    }\n}\n\nfunc (p *WorkerPool) Start(handler func(Job) Result) {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go p.worker(i, handler)\n    }\n}\n\nfunc (p *WorkerPool) worker(id int, handler func(Job) Result) {\n    defer p.wg.Done()\n    \n    for {\n        select {\n        case job, ok := <-p.jobs:\n            if !ok {\n                return\n            }\n            result := handler(job)\n            \n            select {\n            case p.results <- result:\n            case <-p.done:\n                return\n            }\n        case <-p.done:\n            return\n        }\n    }\n}\n\nfunc (p *WorkerPool) Submit(job Job) {\n    select {\n    case p.jobs <- job:\n    case <-p.done:\n    }\n}\n\nfunc (p *WorkerPool) GetResult() (Result, bool) {\n    select {\n    case result := <-p.results:\n        return result, true\n    default:\n        return Result{}, false\n    }\n}\n\nfunc (p *WorkerPool) Shutdown() {\n    close(p.done)\n    close(p.jobs)\n    p.wg.Wait()\n    close(p.results)\n}\n\n// Advanced Worker Pool with context and rate limiting\ntype AdvancedWorkerPool struct {\n    workers     int\n    jobQueue    chan Job\n    resultQueue chan Result\n    ctx         context.Context\n    cancel      context.CancelFunc\n    limiter     *rate.Limiter\n    wg          sync.WaitGroup\n}\n\nfunc NewAdvancedWorkerPool(ctx context.Context, workers int, rateLimit int) *AdvancedWorkerPool {\n    ctx, cancel := context.WithCancel(ctx)\n    return &AdvancedWorkerPool{\n        workers:     workers,\n        jobQueue:    make(chan Job, workers*2),\n        resultQueue: make(chan Result, workers*2),\n        ctx:         ctx,\n        cancel:      cancel,\n        limiter:     rate.NewLimiter(rate.Limit(rateLimit), 1),\n    }\n}\n\nfunc (p *AdvancedWorkerPool) Start(handler func(context.Context, Job) Result) {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go func(workerID int) {\n            defer p.wg.Done()\n            \n            for {\n                select {\n                case <-p.ctx.Done():\n                    return\n                case job := <-p.jobQueue:\n                    // Apply rate limiting\n                    if err := p.limiter.Wait(p.ctx); err != nil {\n                        p.resultQueue <- Result{\n                            JobID: job.ID,\n                            Error: err,\n                        }\n                        continue\n                    }\n                    \n                    // Process job with timeout\n                    jobCtx, cancel := context.WithTimeout(p.ctx, 30*time.Second)\n                    result := handler(jobCtx, job)\n                    cancel()\n                    \n                    select {\n                    case p.resultQueue <- result:\n                    case <-p.ctx.Done():\n                        return\n                    }\n                }\n            }\n        }(i)\n    }\n}\n```\n\n### Fan-Out/Fan-In Pattern\n\n```go\n// Fan-Out/Fan-In Pattern\npackage concurrency\n\n// Fan-out: distribute work across multiple goroutines\nfunc FanOut(in <-chan int, workers int) []<-chan int {\n    channels := make([]<-chan int, workers)\n    \n    for i := 0; i < workers; i++ {\n        ch := make(chan int)\n        channels[i] = ch\n        \n        go func(out chan<- int) {\n            for val := range in {\n                // Process value\n                result := val * val\n                out <- result\n            }\n            close(out)\n        }(ch)\n    }\n    \n    return channels\n}\n\n// Fan-in: merge multiple channels into one\nfunc FanIn(channels ...<-chan int) <-chan int {\n    out := make(chan int)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan int) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n\n// Generic Fan-Out/Fan-In\nfunc FanOutGeneric[T any, R any](\n    in <-chan T,\n    workers int,\n    processor func(T) R,\n) []<-chan R {\n    channels := make([]<-chan R, workers)\n    \n    for i := 0; i < workers; i++ {\n        ch := make(chan R)\n        channels[i] = ch\n        \n        go func(out chan<- R) {\n            for val := range in {\n                out <- processor(val)\n            }\n            close(out)\n        }(ch)\n    }\n    \n    return channels\n}\n\nfunc FanInGeneric[T any](channels ...<-chan T) <-chan T {\n    out := make(chan T)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan T) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n\n// Usage example\nfunc ProcessDataPipeline(data []int) []int {\n    // Create input channel\n    input := make(chan int)\n    go func() {\n        for _, val := range data {\n            input <- val\n        }\n        close(input)\n    }()\n    \n    // Fan-out to 4 workers\n    workers := FanOut(input, 4)\n    \n    // Fan-in results\n    output := FanIn(workers...)\n    \n    // Collect results\n    var results []int\n    for result := range output {\n        results = append(results, result)\n    }\n    \n    return results\n}\n```\n\n### Pipeline Pattern\n\n```go\n// Pipeline Pattern\npackage concurrency\n\n// Pipeline stages\nfunc Generate(nums ...int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for _, n := range nums {\n            out <- n\n        }\n        close(out)\n    }()\n    return out\n}\n\nfunc Square(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            out <- n * n\n        }\n        close(out)\n    }()\n    return out\n}\n\nfunc Filter(in <-chan int, predicate func(int) bool) <-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            if predicate(n) {\n                out <- n\n            }\n        }\n        close(out)\n    }()\n    return out\n}\n\n// Generic Pipeline\ntype Pipeline[T any] struct {\n    stages []func(<-chan T) <-chan T\n}\n\nfunc NewPipeline[T any]() *Pipeline[T] {\n    return &Pipeline[T]{}\n}\n\nfunc (p *Pipeline[T]) AddStage(stage func(<-chan T) <-chan T) *Pipeline[T] {\n    p.stages = append(p.stages, stage)\n    return p\n}\n\nfunc (p *Pipeline[T]) Execute(input <-chan T) <-chan T {\n    output := input\n    for _, stage := range p.stages {\n        output = stage(output)\n    }\n    return output\n}\n\n// Cancellable Pipeline\nfunc GenerateWithCancel(ctx context.Context, nums ...int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for _, n := range nums {\n            select {\n            case out <- n:\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return out\n}\n\nfunc TransformWithCancel(ctx context.Context, in <-chan int, fn func(int) int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for {\n            select {\n            case n, ok := <-in:\n                if !ok {\n                    return\n                }\n                select {\n                case out <- fn(n):\n                case <-ctx.Done():\n                    return\n                }\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return out\n}\n\n// Error handling in pipeline\ntype Result[T any] struct {\n    Value T\n    Error error\n}\n\nfunc TransformWithError[T, R any](\n    in <-chan Result[T],\n    fn func(T) (R, error),\n) <-chan Result[R] {\n    out := make(chan Result[R])\n    go func() {\n        defer close(out)\n        for result := range in {\n            if result.Error != nil {\n                out <- Result[R]{Error: result.Error}\n                continue\n            }\n            \n            value, err := fn(result.Value)\n            out <- Result[R]{Value: value, Error: err}\n        }\n    }()\n    return out\n}\n```\n\n## Go-Specific Idioms\n\n### Functional Options Pattern\n\n```go\n// Functional Options Pattern\npackage idioms\n\ntype Server struct {\n    host        string\n    port        int\n    timeout     time.Duration\n    maxConn     int\n    tls         bool\n    middlewares []func(http.Handler) http.Handler\n}\n\ntype Option func(*Server)\n\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = timeout\n    }\n}\n\nfunc WithTLS(enabled bool) Option {\n    return func(s *Server) {\n        s.tls = enabled\n    }\n}\n\nfunc WithMiddleware(mw func(http.Handler) http.Handler) Option {\n    return func(s *Server) {\n        s.middlewares = append(s.middlewares, mw)\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    // Default values\n    s := &Server{\n        host:    \"localhost\",\n        port:    8080,\n        timeout: 30 * time.Second,\n        maxConn: 100,\n    }\n    \n    // Apply options\n    for _, opt := range opts {\n        opt(s)\n    }\n    \n    return s\n}\n\n// Usage\nserver := NewServer(\n    WithHost(\"api.example.com\"),\n    WithPort(443),\n    WithTLS(true),\n    WithTimeout(60*time.Second),\n    WithMiddleware(loggingMiddleware),\n    WithMiddleware(authMiddleware),\n)\n\n// Advanced: Options with validation\ntype OptionError struct {\n    Option string\n    Err    error\n}\n\ntype OptionWithError func(*Server) error\n\nfunc WithPortValidated(port int) OptionWithError {\n    return func(s *Server) error {\n        if port < 1 || port > 65535 {\n            return fmt.Errorf(\"invalid port: %d\", port)\n        }\n        s.port = port\n        return nil\n    }\n}\n\nfunc NewServerValidated(opts ...OptionWithError) (*Server, error) {\n    s := &Server{\n        host:    \"localhost\",\n        port:    8080,\n        timeout: 30 * time.Second,\n    }\n    \n    for _, opt := range opts {\n        if err := opt(s); err != nil {\n            return nil, err\n        }\n    }\n    \n    return s, nil\n}\n```\n\n### Embedding Pattern\n\n```go\n// Embedding Pattern\npackage idioms\n\n// Interface embedding\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Struct embedding for composition\ntype Logger struct {\n    prefix string\n}\n\nfunc (l *Logger) Log(message string) {\n    fmt.Printf(\"[%s] %s\\n\", l.prefix, message)\n}\n\ntype Service struct {\n    Logger  // Embedded\n    name string\n}\n\nfunc (s *Service) Start() {\n    s.Log(fmt.Sprintf(\"Starting service: %s\", s.name))  // Promoted method\n}\n\n// Embedding to extend functionality\ntype ResponseWriter struct {\n    http.ResponseWriter  // Embed standard interface\n    statusCode int\n}\n\nfunc (w *ResponseWriter) WriteHeader(code int) {\n    w.statusCode = code\n    w.ResponseWriter.WriteHeader(code)\n}\n\nfunc WrapResponseWriter(w http.ResponseWriter) *ResponseWriter {\n    return &ResponseWriter{ResponseWriter: w, statusCode: 200}\n}\n\n// Multiple embedding with method overriding\ntype Animal struct {\n    Name string\n}\n\nfunc (a *Animal) Speak() string {\n    return fmt.Sprintf(\"%s makes a sound\", a.Name)\n}\n\nfunc (a *Animal) Move() string {\n    return fmt.Sprintf(\"%s moves\", a.Name)\n}\n\ntype Swimmer struct{}\n\nfunc (s *Swimmer) Swim() string {\n    return \"swimming\"\n}\n\ntype Flyer struct{}\n\nfunc (f *Flyer) Fly() string {\n    return \"flying\"\n}\n\ntype Duck struct {\n    Animal\n    Swimmer\n    Flyer\n}\n\nfunc (d *Duck) Speak() string {\n    return fmt.Sprintf(\"%s quacks\", d.Name)  // Override Animal.Speak\n}\n\n// Usage\nduck := &Duck{Animal: Animal{Name: \"Donald\"}}\nfmt.Println(duck.Speak())  // \"Donald quacks\" (overridden)\nfmt.Println(duck.Move())   // \"Donald moves\" (inherited)\nfmt.Println(duck.Swim())   // \"swimming\"\nfmt.Println(duck.Fly())    // \"flying\"\n```\n\n### Empty Interface and Type Assertion Pattern\n\n```go\n// Type Assertion and Switch Pattern\npackage idioms\n\nfunc ProcessValue(v interface{}) (string, error) {\n    switch val := v.(type) {\n    case string:\n        return val, nil\n    case int:\n        return strconv.Itoa(val), nil\n    case float64:\n        return fmt.Sprintf(\"%.2f\", val), nil\n    case bool:\n        return strconv.FormatBool(val), nil\n    case fmt.Stringer:\n        return val.String(), nil\n    case error:\n        return \"\", val\n    default:\n        return \"\", fmt.Errorf(\"unsupported type: %T\", v)\n    }\n}\n\n// Safe type assertion\nfunc SafeCast[T any](v interface{}) (T, bool) {\n    result, ok := v.(T)\n    return result, ok\n}\n\n// Generic constraint with type assertion\ntype Number interface {\n    int | int64 | float32 | float64\n}\n\nfunc ConvertToFloat64[T Number](v T) float64 {\n    // Type switch not needed with generics\n    return float64(v)\n}\n\n// Store with type-safe retrieval\ntype TypedStore struct {\n    data map[string]interface{}\n    mu   sync.RWMutex\n}\n\nfunc (s *TypedStore) Set(key string, value interface{}) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.data[key] = value\n}\n\nfunc (s *TypedStore) Get(key string) (interface{}, bool) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    val, ok := s.data[key]\n    return val, ok\n}\n\nfunc (s *TypedStore) GetString(key string) (string, error) {\n    val, ok := s.Get(key)\n    if !ok {\n        return \"\", fmt.Errorf(\"key not found: %s\", key)\n    }\n    \n    str, ok := val.(string)\n    if !ok {\n        return \"\", fmt.Errorf(\"value is not string: %T\", val)\n    }\n    \n    return str, nil\n}\n\nfunc (s *TypedStore) GetInt(key string) (int, error) {\n    val, ok := s.Get(key)\n    if !ok {\n        return 0, fmt.Errorf(\"key not found: %s\", key)\n    }\n    \n    switch v := val.(type) {\n    case int:\n        return v, nil\n    case int64:\n        return int(v), nil\n    case float64:\n        return int(v), nil\n    default:\n        return 0, fmt.Errorf(\"value is not numeric: %T\", val)\n    }\n}\n```\n\n## Architecture Patterns\n\n### Hexagonal Architecture (Ports & Adapters)\n\n```go\n// Hexagonal Architecture Pattern\npackage architecture\n\n// Core Domain (center of hexagon)\ntype Order struct {\n    ID        string\n    Symbol    string\n    Quantity  float64\n    Price     float64\n    Type      OrderType\n    Status    OrderStatus\n    CreatedAt time.Time\n}\n\ntype OrderService struct {\n    repo      OrderRepository      // Port\n    exchange  ExchangeGateway      // Port\n    notifier  NotificationService  // Port\n}\n\n// Ports (interfaces defined by core)\ntype OrderRepository interface {\n    Save(order *Order) error\n    FindByID(id string) (*Order, error)\n    FindByStatus(status OrderStatus) ([]*Order, error)\n}\n\ntype ExchangeGateway interface {\n    PlaceOrder(order *Order) error\n    CancelOrder(orderID string) error\n    GetOrderStatus(orderID string) (OrderStatus, error)\n}\n\ntype NotificationService interface {\n    NotifyOrderPlaced(order *Order) error\n    NotifyOrderFilled(order *Order) error\n}\n\n// Adapters (implementations)\ntype PostgresOrderRepository struct {\n    db *sql.DB\n}\n\nfunc (r *PostgresOrderRepository) Save(order *Order) error {\n    query := `INSERT INTO orders (id, symbol, quantity, price, type, status, created_at)\n              VALUES ($1, $2, $3, $4, $5, $6, $7)`\n    _, err := r.db.Exec(query, order.ID, order.Symbol, order.Quantity,\n                         order.Price, order.Type, order.Status, order.CreatedAt)\n    return err\n}\n\nfunc (r *PostgresOrderRepository) FindByID(id string) (*Order, error) {\n    // Implementation\n    return nil, nil\n}\n\nfunc (r *PostgresOrderRepository) FindByStatus(status OrderStatus) ([]*Order, error) {\n    // Implementation\n    return nil, nil\n}\n\ntype BinanceExchangeAdapter struct {\n    apiKey    string\n    apiSecret string\n    client    *binance.Client\n}\n\nfunc (b *BinanceExchangeAdapter) PlaceOrder(order *Order) error {\n    // Convert domain order to Binance API format\n    binanceOrder := b.toBinanceOrder(order)\n    // Call Binance API\n    return b.client.CreateOrder(binanceOrder)\n}\n\nfunc (b *BinanceExchangeAdapter) CancelOrder(orderID string) error {\n    return b.client.CancelOrder(orderID)\n}\n\nfunc (b *BinanceExchangeAdapter) GetOrderStatus(orderID string) (OrderStatus, error) {\n    status, err := b.client.GetOrder(orderID)\n    if err != nil {\n        return \"\", err\n    }\n    return b.fromBinanceStatus(status), nil\n}\n\ntype EmailNotificationAdapter struct {\n    smtpHost string\n    smtpPort int\n}\n\nfunc (e *EmailNotificationAdapter) NotifyOrderPlaced(order *Order) error {\n    subject := fmt.Sprintf(\"Order Placed: %s\", order.ID)\n    body := fmt.Sprintf(\"Your order for %f %s has been placed\", order.Quantity, order.Symbol)\n    return e.sendEmail(subject, body)\n}\n\nfunc (e *EmailNotificationAdapter) NotifyOrderFilled(order *Order) error {\n    subject := fmt.Sprintf(\"Order Filled: %s\", order.ID)\n    body := fmt.Sprintf(\"Your order for %f %s has been filled at %f\",\n                        order.Quantity, order.Symbol, order.Price)\n    return e.sendEmail(subject, body)\n}\n\n// Dependency Injection\nfunc NewOrderService(\n    repo OrderRepository,\n    exchange ExchangeGateway,\n    notifier NotificationService,\n) *OrderService {\n    return &OrderService{\n        repo:     repo,\n        exchange: exchange,\n        notifier: notifier,\n    }\n}\n\n// Usage\nfunc main() {\n    // Setup adapters\n    db, _ := sql.Open(\"postgres\", \"connection-string\")\n    repo := &PostgresOrderRepository{db: db}\n    exchange := &BinanceExchangeAdapter{apiKey: \"key\", apiSecret: \"secret\"}\n    notifier := &EmailNotificationAdapter{smtpHost: \"smtp.gmail.com\", smtpPort: 587}\n    \n    // Create service with injected dependencies\n    service := NewOrderService(repo, exchange, notifier)\n    \n    // Use service\n    order := &Order{\n        ID:       generateID(),\n        Symbol:   \"BTC/USDT\",\n        Quantity: 0.01,\n        Price:    50000,\n        Type:     LimitOrder,\n    }\n    \n    service.PlaceOrder(order)\n}\n```\n\nThis completes the comprehensive guide to Go design patterns. Each pattern is demonstrated with practical, real-world examples that show how to implement them idiomatically in Go."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":47975,"cache_read_input_tokens":0,"output_tokens":17533,"service_tier":"standard"}},"requestId":"req_011CS5FZasFjt2Ffr5reauTV","type":"assistant","uuid":"4e8d407c-88af-4cd7-9bb5-9f7a90d363b4","timestamp":"2025-08-13T06:47:23.115Z"}
{"parentUuid":"4e8d407c-88af-4cd7-9bb5-9f7a90d363b4","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XJT9gAtFZrsAYwzqEp7Wm2","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/02-design-patterns.md"}]},"uuid":"16676f79-d571-40bb-b23e-5b1c29604de9","timestamp":"2025-08-13T06:47:23.167Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/02-design-patterns.md","content":"# Go Design Patterns - Comprehensive Guide\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Concurrency Patterns](#concurrency-patterns)\n5. [Go-Specific Idioms](#go-specific-idioms)\n6. [Messaging Patterns](#messaging-patterns)\n7. [Error Handling Patterns](#error-handling-patterns)\n8. [Architecture Patterns](#architecture-patterns)\n\n## Creational Patterns\n\n### Singleton Pattern\n\n```go\n// Thread-safe singleton using sync.Once\npackage singleton\n\nimport (\n    \"database/sql\"\n    \"sync\"\n)\n\ntype Database struct {\n    conn *sql.DB\n}\n\nvar (\n    instance *Database\n    once     sync.Once\n)\n\nfunc GetInstance() *Database {\n    once.Do(func() {\n        conn, err := sql.Open(\"postgres\", \"connection-string\")\n        if err != nil {\n            panic(err)\n        }\n        instance = &Database{conn: conn}\n    })\n    return instance\n}\n\n// Alternative: Package-level variable (simpler)\nvar db = &Database{\n    conn: initDB(),\n}\n\nfunc initDB() *sql.DB {\n    conn, err := sql.Open(\"postgres\", \"connection-string\")\n    if err != nil {\n        panic(err)\n    }\n    return conn\n}\n\nfunc GetDB() *Database {\n    return db\n}\n```\n\n### Factory Pattern\n\n```go\n// Factory Method Pattern\npackage factory\n\ntype PaymentMethod interface {\n    Pay(amount float64) error\n    ValidateDetails() error\n}\n\ntype PaymentType string\n\nconst (\n    CreditCard PaymentType = \"credit_card\"\n    PayPal     PaymentType = \"paypal\"\n    Bitcoin    PaymentType = \"bitcoin\"\n)\n\n// Factory function\nfunc NewPaymentMethod(t PaymentType, details map[string]string) (PaymentMethod, error) {\n    switch t {\n    case CreditCard:\n        return &CreditCardPayment{\n            Number: details[\"number\"],\n            CVV:    details[\"cvv\"],\n            Expiry: details[\"expiry\"],\n        }, nil\n    case PayPal:\n        return &PayPalPayment{\n            Email:    details[\"email\"],\n            Password: details[\"password\"],\n        }, nil\n    case Bitcoin:\n        return &BitcoinPayment{\n            WalletAddress: details[\"wallet\"],\n            PrivateKey:    details[\"key\"],\n        }, nil\n    default:\n        return nil, fmt.Errorf(\"unsupported payment type: %s\", t)\n    }\n}\n\n// Abstract Factory Pattern\ntype ExchangeFactory interface {\n    CreateOrderClient() OrderClient\n    CreateMarketDataClient() MarketDataClient\n    CreateAccountClient() AccountClient\n}\n\ntype BinanceFactory struct {\n    apiKey    string\n    apiSecret string\n}\n\nfunc (f *BinanceFactory) CreateOrderClient() OrderClient {\n    return &BinanceOrderClient{\n        apiKey:    f.apiKey,\n        apiSecret: f.apiSecret,\n    }\n}\n\nfunc (f *BinanceFactory) CreateMarketDataClient() MarketDataClient {\n    return &BinanceMarketDataClient{}\n}\n\nfunc (f *BinanceFactory) CreateAccountClient() AccountClient {\n    return &BinanceAccountClient{\n        apiKey:    f.apiKey,\n        apiSecret: f.apiSecret,\n    }\n}\n\n// Factory Registry Pattern\ntype StrategyFactory func(config map[string]interface{}) (Strategy, error)\n\nvar strategyFactories = make(map[string]StrategyFactory)\n\nfunc RegisterStrategy(name string, factory StrategyFactory) {\n    strategyFactories[name] = factory\n}\n\nfunc CreateStrategy(name string, config map[string]interface{}) (Strategy, error) {\n    factory, exists := strategyFactories[name]\n    if !exists {\n        return nil, fmt.Errorf(\"strategy %s not registered\", name)\n    }\n    return factory(config)\n}\n\n// Usage with init()\nfunc init() {\n    RegisterStrategy(\"moving_average\", NewMovingAverageStrategy)\n    RegisterStrategy(\"mean_reversion\", NewMeanReversionStrategy)\n    RegisterStrategy(\"momentum\", NewMomentumStrategy)\n}\n```\n\n### Builder Pattern\n\n```go\n// Builder Pattern for complex objects\npackage builder\n\ntype Server struct {\n    host         string\n    port         int\n    timeout      time.Duration\n    maxConns     int\n    tls          bool\n    certFile     string\n    keyFile      string\n    middlewares  []Middleware\n}\n\ntype ServerBuilder struct {\n    server *Server\n}\n\nfunc NewServerBuilder() *ServerBuilder {\n    return &ServerBuilder{\n        server: &Server{\n            port:     8080,\n            timeout:  30 * time.Second,\n            maxConns: 100,\n        },\n    }\n}\n\nfunc (b *ServerBuilder) Host(host string) *ServerBuilder {\n    b.server.host = host\n    return b\n}\n\nfunc (b *ServerBuilder) Port(port int) *ServerBuilder {\n    b.server.port = port\n    return b\n}\n\nfunc (b *ServerBuilder) Timeout(timeout time.Duration) *ServerBuilder {\n    b.server.timeout = timeout\n    return b\n}\n\nfunc (b *ServerBuilder) MaxConnections(max int) *ServerBuilder {\n    b.server.maxConns = max\n    return b\n}\n\nfunc (b *ServerBuilder) EnableTLS(certFile, keyFile string) *ServerBuilder {\n    b.server.tls = true\n    b.server.certFile = certFile\n    b.server.keyFile = keyFile\n    return b\n}\n\nfunc (b *ServerBuilder) AddMiddleware(m Middleware) *ServerBuilder {\n    b.server.middlewares = append(b.server.middlewares, m)\n    return b\n}\n\nfunc (b *ServerBuilder) Build() (*Server, error) {\n    // Validation\n    if b.server.host == \"\" {\n        return nil, errors.New(\"host is required\")\n    }\n    if b.server.tls && (b.server.certFile == \"\" || b.server.keyFile == \"\") {\n        return nil, errors.New(\"cert and key files required for TLS\")\n    }\n    return b.server, nil\n}\n\n// Usage\nserver, err := NewServerBuilder().\n    Host(\"localhost\").\n    Port(8443).\n    Timeout(60 * time.Second).\n    EnableTLS(\"cert.pem\", \"key.pem\").\n    AddMiddleware(LoggingMiddleware()).\n    AddMiddleware(AuthMiddleware()).\n    Build()\n\n// Functional Options Pattern (Go idiomatic alternative)\ntype Option func(*Server)\n\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTLS(certFile, keyFile string) Option {\n    return func(s *Server) {\n        s.tls = true\n        s.certFile = certFile\n        s.keyFile = keyFile\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    // Default values\n    s := &Server{\n        host:     \"localhost\",\n        port:     8080,\n        timeout:  30 * time.Second,\n        maxConns: 100,\n    }\n    \n    // Apply options\n    for _, opt := range opts {\n        opt(s)\n    }\n    \n    return s\n}\n\n// Usage with functional options\nserver := NewServer(\n    WithHost(\"api.example.com\"),\n    WithPort(443),\n    WithTLS(\"cert.pem\", \"key.pem\"),\n)\n```\n\n### Prototype Pattern\n\n```go\n// Prototype Pattern - cloning objects\npackage prototype\n\ntype Cloneable interface {\n    Clone() Cloneable\n}\n\ntype OrderTemplate struct {\n    Exchange   string\n    Symbol     string\n    OrderType  string\n    TimeInForce string\n    Settings   map[string]interface{}\n}\n\nfunc (o *OrderTemplate) Clone() Cloneable {\n    // Deep copy of settings\n    settings := make(map[string]interface{})\n    for k, v := range o.Settings {\n        settings[k] = v\n    }\n    \n    return &OrderTemplate{\n        Exchange:    o.Exchange,\n        Symbol:      o.Symbol,\n        OrderType:   o.OrderType,\n        TimeInForce: o.TimeInForce,\n        Settings:    settings,\n    }\n}\n\n// Prototype Registry\ntype PrototypeRegistry struct {\n    prototypes map[string]Cloneable\n}\n\nfunc NewPrototypeRegistry() *PrototypeRegistry {\n    return &PrototypeRegistry{\n        prototypes: make(map[string]Cloneable),\n    }\n}\n\nfunc (r *PrototypeRegistry) Register(name string, prototype Cloneable) {\n    r.prototypes[name] = prototype\n}\n\nfunc (r *PrototypeRegistry) Create(name string) (Cloneable, error) {\n    prototype, exists := r.prototypes[name]\n    if !exists {\n        return nil, fmt.Errorf(\"prototype %s not found\", name)\n    }\n    return prototype.Clone(), nil\n}\n\n// Usage\nregistry := NewPrototypeRegistry()\nregistry.Register(\"market_order\", &OrderTemplate{\n    OrderType:   \"MARKET\",\n    TimeInForce: \"IOC\",\n})\nregistry.Register(\"limit_order\", &OrderTemplate{\n    OrderType:   \"LIMIT\",\n    TimeInForce: \"GTC\",\n})\n\norder, _ := registry.Create(\"market_order\")\n```\n\n### Object Pool Pattern\n\n```go\n// Object Pool Pattern - reuse expensive objects\npackage pool\n\nimport (\n    \"sync\"\n)\n\ntype Connection struct {\n    id   int\n    host string\n}\n\nfunc (c *Connection) Reset() {\n    // Reset connection state\n}\n\ntype ConnectionPool struct {\n    mu          sync.Mutex\n    connections chan *Connection\n    factory     func() *Connection\n}\n\nfunc NewConnectionPool(size int, factory func() *Connection) *ConnectionPool {\n    pool := &ConnectionPool{\n        connections: make(chan *Connection, size),\n        factory:     factory,\n    }\n    \n    // Pre-populate pool\n    for i := 0; i < size; i++ {\n        conn := factory()\n        conn.id = i\n        pool.connections <- conn\n    }\n    \n    return pool\n}\n\nfunc (p *ConnectionPool) Get() *Connection {\n    select {\n    case conn := <-p.connections:\n        return conn\n    default:\n        // Pool empty, create new connection\n        return p.factory()\n    }\n}\n\nfunc (p *ConnectionPool) Put(conn *Connection) {\n    conn.Reset()\n    \n    select {\n    case p.connections <- conn:\n        // Connection returned to pool\n    default:\n        // Pool full, discard connection\n    }\n}\n\n// Using sync.Pool (Go standard library)\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 1024)\n    },\n}\n\nfunc ProcessData(data []byte) {\n    buffer := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buffer)\n    \n    // Use buffer for processing\n    copy(buffer, data)\n    // Process...\n}\n```\n\n## Structural Patterns\n\n### Adapter Pattern\n\n```go\n// Adapter Pattern - make incompatible interfaces work together\npackage adapter\n\n// Target interface (what we want)\ntype ModernPaymentGateway interface {\n    MakePayment(amount float64, currency string) error\n    RefundPayment(transactionID string) error\n}\n\n// Adaptee (legacy system)\ntype LegacyPaymentSystem struct{}\n\nfunc (l *LegacyPaymentSystem) SubmitPayment(cents int64) string {\n    // Legacy implementation\n    return fmt.Sprintf(\"TXN-%d\", time.Now().Unix())\n}\n\nfunc (l *LegacyPaymentSystem) CancelTransaction(txnCode string) bool {\n    // Legacy implementation\n    return true\n}\n\n// Adapter\ntype PaymentAdapter struct {\n    legacy *LegacyPaymentSystem\n}\n\nfunc NewPaymentAdapter(legacy *LegacyPaymentSystem) ModernPaymentGateway {\n    return &PaymentAdapter{legacy: legacy}\n}\n\nfunc (a *PaymentAdapter) MakePayment(amount float64, currency string) error {\n    // Convert to cents for legacy system\n    cents := int64(amount * 100)\n    \n    txnID := a.legacy.SubmitPayment(cents)\n    if txnID == \"\" {\n        return errors.New(\"payment failed\")\n    }\n    \n    return nil\n}\n\nfunc (a *PaymentAdapter) RefundPayment(transactionID string) error {\n    success := a.legacy.CancelTransaction(transactionID)\n    if !success {\n        return errors.New(\"refund failed\")\n    }\n    return nil\n}\n\n// Interface Adapter for multiple types\ntype DataSource interface {\n    GetData() ([]byte, error)\n}\n\n// Adapt io.Reader to DataSource\ntype ReaderAdapter struct {\n    reader io.Reader\n}\n\nfunc (r *ReaderAdapter) GetData() ([]byte, error) {\n    return ioutil.ReadAll(r.reader)\n}\n\n// Adapt string to DataSource\ntype StringAdapter struct {\n    data string\n}\n\nfunc (s *StringAdapter) GetData() ([]byte, error) {\n    return []byte(s.data), nil\n}\n\n// Adapt file path to DataSource\ntype FileAdapter struct {\n    path string\n}\n\nfunc (f *FileAdapter) GetData() ([]byte, error) {\n    return ioutil.ReadFile(f.path)\n}\n```\n\n### Decorator Pattern\n\n```go\n// Decorator Pattern - add functionality without altering structure\npackage decorator\n\n// Component interface\ntype DataProcessor interface {\n    Process(data []byte) ([]byte, error)\n}\n\n// Concrete component\ntype BasicProcessor struct{}\n\nfunc (p *BasicProcessor) Process(data []byte) ([]byte, error) {\n    // Basic processing\n    return data, nil\n}\n\n// Decorator base\ntype ProcessorDecorator struct {\n    processor DataProcessor\n}\n\n// Compression decorator\ntype CompressionDecorator struct {\n    ProcessorDecorator\n}\n\nfunc NewCompressionDecorator(p DataProcessor) DataProcessor {\n    return &CompressionDecorator{\n        ProcessorDecorator{processor: p},\n    }\n}\n\nfunc (d *CompressionDecorator) Process(data []byte) ([]byte, error) {\n    // Process with wrapped processor first\n    processed, err := d.processor.Process(data)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Add compression\n    var buf bytes.Buffer\n    w := gzip.NewWriter(&buf)\n    _, err = w.Write(processed)\n    w.Close()\n    \n    return buf.Bytes(), err\n}\n\n// Encryption decorator\ntype EncryptionDecorator struct {\n    ProcessorDecorator\n    key []byte\n}\n\nfunc NewEncryptionDecorator(p DataProcessor, key []byte) DataProcessor {\n    return &EncryptionDecorator{\n        ProcessorDecorator: ProcessorDecorator{processor: p},\n        key:                key,\n    }\n}\n\nfunc (d *EncryptionDecorator) Process(data []byte) ([]byte, error) {\n    processed, err := d.processor.Process(data)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Add encryption\n    encrypted := encrypt(processed, d.key)\n    return encrypted, nil\n}\n\n// Logging decorator\ntype LoggingDecorator struct {\n    ProcessorDecorator\n    logger *log.Logger\n}\n\nfunc NewLoggingDecorator(p DataProcessor, logger *log.Logger) DataProcessor {\n    return &LoggingDecorator{\n        ProcessorDecorator: ProcessorDecorator{processor: p},\n        logger:             logger,\n    }\n}\n\nfunc (d *LoggingDecorator) Process(data []byte) ([]byte, error) {\n    d.logger.Printf(\"Processing %d bytes\", len(data))\n    start := time.Now()\n    \n    result, err := d.processor.Process(data)\n    \n    d.logger.Printf(\"Processing completed in %v\", time.Since(start))\n    return result, err\n}\n\n// Usage - chain decorators\nprocessor := NewLoggingDecorator(\n    NewCompressionDecorator(\n        NewEncryptionDecorator(\n            &BasicProcessor{},\n            encryptionKey,\n        ),\n    ),\n    logger,\n)\n\nresult, err := processor.Process(data)\n\n// HTTP Middleware Decorator Pattern\ntype Middleware func(http.HandlerFunc) http.HandlerFunc\n\nfunc Logging(next http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        next(w, r)\n        log.Printf(\"%s %s %v\", r.Method, r.URL.Path, time.Since(start))\n    }\n}\n\nfunc Authentication(next http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        token := r.Header.Get(\"Authorization\")\n        if !isValidToken(token) {\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n        next(w, r)\n    }\n}\n\nfunc RateLimiting(limit int) Middleware {\n    limiter := rate.NewLimiter(rate.Limit(limit), 1)\n    \n    return func(next http.HandlerFunc) http.HandlerFunc {\n        return func(w http.ResponseWriter, r *http.Request) {\n            if !limiter.Allow() {\n                http.Error(w, \"Too Many Requests\", http.StatusTooManyRequests)\n                return\n            }\n            next(w, r)\n        }\n    }\n}\n\n// Chain middlewares\nhandler := Logging(\n    Authentication(\n        RateLimiting(100)(\n            finalHandler,\n        ),\n    ),\n)\n```\n\n### Proxy Pattern\n\n```go\n// Proxy Pattern - provide placeholder/surrogate\npackage proxy\n\n// Subject interface\ntype Database interface {\n    Query(sql string) ([]Row, error)\n    Execute(sql string) error\n}\n\n// Real subject\ntype PostgresDB struct {\n    connectionString string\n    conn             *sql.DB\n}\n\nfunc (db *PostgresDB) Query(sql string) ([]Row, error) {\n    // Actual database query\n    return db.executeQuery(sql)\n}\n\nfunc (db *PostgresDB) Execute(sql string) error {\n    // Actual database execution\n    return db.executeStatement(sql)\n}\n\n// Caching Proxy\ntype CachingDBProxy struct {\n    realDB Database\n    cache  map[string][]Row\n    mu     sync.RWMutex\n}\n\nfunc NewCachingDBProxy(db Database) Database {\n    return &CachingDBProxy{\n        realDB: db,\n        cache:  make(map[string][]Row),\n    }\n}\n\nfunc (p *CachingDBProxy) Query(sql string) ([]Row, error) {\n    // Check cache first\n    p.mu.RLock()\n    if rows, found := p.cache[sql]; found {\n        p.mu.RUnlock()\n        return rows, nil\n    }\n    p.mu.RUnlock()\n    \n    // Cache miss, query real database\n    rows, err := p.realDB.Query(sql)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Update cache\n    p.mu.Lock()\n    p.cache[sql] = rows\n    p.mu.Unlock()\n    \n    return rows, nil\n}\n\nfunc (p *CachingDBProxy) Execute(sql string) error {\n    // Clear cache on write operations\n    p.mu.Lock()\n    p.cache = make(map[string][]Row)\n    p.mu.Unlock()\n    \n    return p.realDB.Execute(sql)\n}\n\n// Virtual Proxy (Lazy Loading)\ntype Image interface {\n    Display()\n    GetDimensions() (int, int)\n}\n\ntype RealImage struct {\n    filename string\n    data     []byte\n    width    int\n    height   int\n}\n\nfunc NewRealImage(filename string) *RealImage {\n    img := &RealImage{filename: filename}\n    img.load()\n    return img\n}\n\nfunc (i *RealImage) load() {\n    // Expensive operation\n    i.data = loadImageFromDisk(i.filename)\n    i.width, i.height = getImageDimensions(i.data)\n}\n\nfunc (i *RealImage) Display() {\n    renderImage(i.data)\n}\n\nfunc (i *RealImage) GetDimensions() (int, int) {\n    return i.width, i.height\n}\n\n// Virtual Proxy\ntype ImageProxy struct {\n    filename  string\n    realImage *RealImage\n}\n\nfunc NewImageProxy(filename string) Image {\n    return &ImageProxy{filename: filename}\n}\n\nfunc (p *ImageProxy) Display() {\n    if p.realImage == nil {\n        p.realImage = NewRealImage(p.filename)\n    }\n    p.realImage.Display()\n}\n\nfunc (p *ImageProxy) GetDimensions() (int, int) {\n    if p.realImage == nil {\n        p.realImage = NewRealImage(p.filename)\n    }\n    return p.realImage.GetDimensions()\n}\n\n// Protection Proxy\ntype BankAccount interface {\n    Deposit(amount float64)\n    Withdraw(amount float64) error\n    GetBalance() float64\n}\n\ntype SecureBankAccountProxy struct {\n    account     BankAccount\n    permissions map[string]bool\n    user        string\n}\n\nfunc (p *SecureBankAccountProxy) Withdraw(amount float64) error {\n    if !p.permissions[\"withdraw\"] {\n        return errors.New(\"permission denied: withdraw\")\n    }\n    \n    log.Printf(\"User %s withdrawing %.2f\", p.user, amount)\n    return p.account.Withdraw(amount)\n}\n\nfunc (p *SecureBankAccountProxy) Deposit(amount float64) {\n    if !p.permissions[\"deposit\"] {\n        log.Printf(\"Permission denied for user %s\", p.user)\n        return\n    }\n    \n    p.account.Deposit(amount)\n}\n\nfunc (p *SecureBankAccountProxy) GetBalance() float64 {\n    if !p.permissions[\"view\"] {\n        return 0\n    }\n    return p.account.GetBalance()\n}\n```\n\n### Facade Pattern\n\n```go\n// Facade Pattern - simplified interface to complex subsystem\npackage facade\n\n// Complex subsystem components\ntype OrderService struct{}\n\nfunc (s *OrderService) CreateOrder(symbol string, quantity float64, orderType string) (*Order, error) {\n    // Complex order creation logic\n    return &Order{}, nil\n}\n\nfunc (s *OrderService) ValidateOrder(order *Order) error {\n    // Validation logic\n    return nil\n}\n\ntype RiskManager struct{}\n\nfunc (r *RiskManager) CheckRiskLimits(order *Order) error {\n    // Risk checking logic\n    return nil\n}\n\nfunc (r *RiskManager) CalculatePositionSize(balance, risk float64) float64 {\n    // Position sizing logic\n    return balance * risk\n}\n\ntype MarketDataService struct{}\n\nfunc (m *MarketDataService) GetCurrentPrice(symbol string) (float64, error) {\n    // Fetch market data\n    return 100.0, nil\n}\n\nfunc (m *MarketDataService) GetOrderBook(symbol string) (*OrderBook, error) {\n    // Fetch order book\n    return &OrderBook{}, nil\n}\n\ntype ExecutionEngine struct{}\n\nfunc (e *ExecutionEngine) SendOrder(order *Order) error {\n    // Send order to exchange\n    return nil\n}\n\nfunc (e *ExecutionEngine) CancelOrder(orderID string) error {\n    // Cancel order\n    return nil\n}\n\n// Facade\ntype TradingFacade struct {\n    orderService   *OrderService\n    riskManager    *RiskManager\n    marketData     *MarketDataService\n    execution      *ExecutionEngine\n}\n\nfunc NewTradingFacade() *TradingFacade {\n    return &TradingFacade{\n        orderService:   &OrderService{},\n        riskManager:    &RiskManager{},\n        marketData:     &MarketDataService{},\n        execution:      &ExecutionEngine{},\n    }\n}\n\n// Simplified interface\nfunc (f *TradingFacade) PlaceMarketOrder(symbol string, quantity float64) error {\n    // Get current price\n    price, err := f.marketData.GetCurrentPrice(symbol)\n    if err != nil {\n        return fmt.Errorf(\"failed to get price: %w\", err)\n    }\n    \n    // Create order\n    order, err := f.orderService.CreateOrder(symbol, quantity, \"MARKET\")\n    if err != nil {\n        return fmt.Errorf(\"failed to create order: %w\", err)\n    }\n    \n    // Validate order\n    if err := f.orderService.ValidateOrder(order); err != nil {\n        return fmt.Errorf(\"order validation failed: %w\", err)\n    }\n    \n    // Check risk\n    if err := f.riskManager.CheckRiskLimits(order); err != nil {\n        return fmt.Errorf(\"risk check failed: %w\", err)\n    }\n    \n    // Execute order\n    if err := f.execution.SendOrder(order); err != nil {\n        return fmt.Errorf(\"execution failed: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (f *TradingFacade) PlaceLimitOrder(symbol string, quantity, price float64) error {\n    // Simplified limit order placement\n    order, err := f.orderService.CreateOrder(symbol, quantity, \"LIMIT\")\n    if err != nil {\n        return err\n    }\n    \n    order.Price = price\n    \n    if err := f.orderService.ValidateOrder(order); err != nil {\n        return err\n    }\n    \n    if err := f.riskManager.CheckRiskLimits(order); err != nil {\n        return err\n    }\n    \n    return f.execution.SendOrder(order)\n}\n\nfunc (f *TradingFacade) GetMarketSnapshot(symbol string) (*MarketSnapshot, error) {\n    price, err := f.marketData.GetCurrentPrice(symbol)\n    if err != nil {\n        return nil, err\n    }\n    \n    orderBook, err := f.marketData.GetOrderBook(symbol)\n    if err != nil {\n        return nil, err\n    }\n    \n    return &MarketSnapshot{\n        Symbol:    symbol,\n        Price:     price,\n        OrderBook: orderBook,\n        Timestamp: time.Now(),\n    }, nil\n}\n```\n\n### Bridge Pattern\n\n```go\n// Bridge Pattern - decouple abstraction from implementation\npackage bridge\n\n// Implementation interface\ntype MessageSender interface {\n    Send(recipient, message string) error\n    GetDeliveryStatus(messageID string) (string, error)\n}\n\n// Concrete implementations\ntype EmailSender struct {\n    smtpServer string\n}\n\nfunc (e *EmailSender) Send(recipient, message string) error {\n    // Send email via SMTP\n    return nil\n}\n\nfunc (e *EmailSender) GetDeliveryStatus(messageID string) (string, error) {\n    return \"delivered\", nil\n}\n\ntype SMSSender struct {\n    apiKey string\n}\n\nfunc (s *SMSSender) Send(recipient, message string) error {\n    // Send SMS via API\n    return nil\n}\n\nfunc (s *SMSSender) GetDeliveryStatus(messageID string) (string, error) {\n    return \"sent\", nil\n}\n\ntype SlackSender struct {\n    webhookURL string\n}\n\nfunc (s *SlackSender) Send(recipient, message string) error {\n    // Send to Slack channel\n    return nil\n}\n\nfunc (s *SlackSender) GetDeliveryStatus(messageID string) (string, error) {\n    return \"posted\", nil\n}\n\n// Abstraction\ntype Notification struct {\n    sender MessageSender\n}\n\nfunc NewNotification(sender MessageSender) *Notification {\n    return &Notification{sender: sender}\n}\n\nfunc (n *Notification) Notify(recipient, message string) error {\n    return n.sender.Send(recipient, message)\n}\n\n// Refined abstractions\ntype UrgentNotification struct {\n    Notification\n}\n\nfunc NewUrgentNotification(sender MessageSender) *UrgentNotification {\n    return &UrgentNotification{\n        Notification{sender: sender},\n    }\n}\n\nfunc (u *UrgentNotification) Notify(recipient, message string) error {\n    urgentMessage := fmt.Sprintf(\"URGENT: %s\", message)\n    \n    // Send multiple times for urgent messages\n    for i := 0; i < 3; i++ {\n        if err := u.sender.Send(recipient, urgentMessage); err != nil {\n            return err\n        }\n        time.Sleep(time.Second)\n    }\n    \n    return nil\n}\n\ntype ScheduledNotification struct {\n    Notification\n    scheduleTime time.Time\n}\n\nfunc NewScheduledNotification(sender MessageSender, when time.Time) *ScheduledNotification {\n    return &ScheduledNotification{\n        Notification:  Notification{sender: sender},\n        scheduleTime: when,\n    }\n}\n\nfunc (s *ScheduledNotification) Notify(recipient, message string) error {\n    waitTime := time.Until(s.scheduleTime)\n    if waitTime > 0 {\n        time.Sleep(waitTime)\n    }\n    \n    return s.sender.Send(recipient, message)\n}\n\n// Usage - can mix and match abstractions with implementations\nemailNotification := NewNotification(&EmailSender{smtpServer: \"smtp.gmail.com\"})\nsmsUrgentNotification := NewUrgentNotification(&SMSSender{apiKey: \"api-key\"})\nslackScheduledNotification := NewScheduledNotification(\n    &SlackSender{webhookURL: \"https://hooks.slack.com/...\"},\n    time.Now().Add(time.Hour),\n)\n```\n\n### Composite Pattern\n\n```go\n// Composite Pattern - tree structure of objects\npackage composite\n\n// Component interface\ntype FileSystemNode interface {\n    GetName() string\n    GetSize() int64\n    Display(indent string)\n    Search(name string) *File\n}\n\n// Leaf\ntype File struct {\n    name string\n    size int64\n}\n\nfunc (f *File) GetName() string {\n    return f.name\n}\n\nfunc (f *File) GetSize() int64 {\n    return f.size\n}\n\nfunc (f *File) Display(indent string) {\n    fmt.Printf(\"%s- %s (%d bytes)\\n\", indent, f.name, f.size)\n}\n\nfunc (f *File) Search(name string) *File {\n    if f.name == name {\n        return f\n    }\n    return nil\n}\n\n// Composite\ntype Directory struct {\n    name     string\n    children []FileSystemNode\n}\n\nfunc (d *Directory) GetName() string {\n    return d.name\n}\n\nfunc (d *Directory) GetSize() int64 {\n    var total int64\n    for _, child := range d.children {\n        total += child.GetSize()\n    }\n    return total\n}\n\nfunc (d *Directory) Display(indent string) {\n    fmt.Printf(\"%s+ %s/ (%d bytes)\\n\", indent, d.name, d.GetSize())\n    for _, child := range d.children {\n        child.Display(indent + \"  \")\n    }\n}\n\nfunc (d *Directory) Add(child FileSystemNode) {\n    d.children = append(d.children, child)\n}\n\nfunc (d *Directory) Remove(child FileSystemNode) {\n    for i, c := range d.children {\n        if c == child {\n            d.children = append(d.children[:i], d.children[i+1:]...)\n            return\n        }\n    }\n}\n\nfunc (d *Directory) Search(name string) *File {\n    for _, child := range d.children {\n        if result := child.Search(name); result != nil {\n            return result\n        }\n    }\n    return nil\n}\n\n// Usage\nroot := &Directory{name: \"root\"}\nhome := &Directory{name: \"home\"}\nuser := &Directory{name: \"user\"}\ndocuments := &Directory{name: \"documents\"}\n\nfile1 := &File{name: \"readme.txt\", size: 1024}\nfile2 := &File{name: \"photo.jpg\", size: 2048}\nfile3 := &File{name: \"report.pdf\", size: 4096}\n\ndocuments.Add(file1)\ndocuments.Add(file2)\nuser.Add(documents)\nuser.Add(file3)\nhome.Add(user)\nroot.Add(home)\n\nroot.Display(\"\")\nfmt.Printf(\"Total size: %d bytes\\n\", root.GetSize())\n\n// Trading Strategy Composite Example\ntype StrategyComponent interface {\n    Evaluate(data MarketData) Signal\n    GetName() string\n}\n\ntype SimpleIndicator struct {\n    name string\n    calc func(MarketData) float64\n}\n\nfunc (s *SimpleIndicator) Evaluate(data MarketData) Signal {\n    value := s.calc(data)\n    if value > 0 {\n        return BuySignal\n    }\n    return SellSignal\n}\n\nfunc (s *SimpleIndicator) GetName() string {\n    return s.name\n}\n\ntype CompositeStrategy struct {\n    name       string\n    strategies []StrategyComponent\n    combiner   func([]Signal) Signal\n}\n\nfunc (c *CompositeStrategy) Evaluate(data MarketData) Signal {\n    signals := make([]Signal, len(c.strategies))\n    for i, strategy := range c.strategies {\n        signals[i] = strategy.Evaluate(data)\n    }\n    return c.combiner(signals)\n}\n\nfunc (c *CompositeStrategy) GetName() string {\n    return c.name\n}\n\nfunc (c *CompositeStrategy) Add(strategy StrategyComponent) {\n    c.strategies = append(c.strategies, strategy)\n}\n\n// Combine strategies hierarchically\nmainStrategy := &CompositeStrategy{\n    name: \"Main Strategy\",\n    combiner: func(signals []Signal) Signal {\n        // Majority vote\n        buyCount := 0\n        for _, s := range signals {\n            if s == BuySignal {\n                buyCount++\n            }\n        }\n        if buyCount > len(signals)/2 {\n            return BuySignal\n        }\n        return SellSignal\n    },\n}\n\nmomentumStrategy := &CompositeStrategy{\n    name: \"Momentum\",\n    combiner: unanimousVote,\n}\n\nmomentumStrategy.Add(&SimpleIndicator{name: \"RSI\", calc: calculateRSI})\nmomentumStrategy.Add(&SimpleIndicator{name: \"MACD\", calc: calculateMACD})\n\nmainStrategy.Add(momentumStrategy)\nmainStrategy.Add(&SimpleIndicator{name: \"MA Cross\", calc: calculateMACross})\n```\n\n## Behavioral Patterns\n\n### Observer Pattern\n\n```go\n// Observer Pattern - define one-to-many dependency\npackage observer\n\n// Subject interface\ntype Subject interface {\n    Attach(Observer)\n    Detach(Observer)\n    Notify()\n}\n\n// Observer interface\ntype Observer interface {\n    Update(data interface{})\n    GetID() string\n}\n\n// Concrete Subject\ntype PricePublisher struct {\n    observers map[string]Observer\n    price     float64\n    symbol    string\n    mu        sync.RWMutex\n}\n\nfunc NewPricePublisher(symbol string) *PricePublisher {\n    return &PricePublisher{\n        observers: make(map[string]Observer),\n        symbol:    symbol,\n    }\n}\n\nfunc (p *PricePublisher) Attach(observer Observer) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    p.observers[observer.GetID()] = observer\n}\n\nfunc (p *PricePublisher) Detach(observer Observer) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    delete(p.observers, observer.GetID())\n}\n\nfunc (p *PricePublisher) Notify() {\n    p.mu.RLock()\n    defer p.mu.RUnlock()\n    \n    for _, observer := range p.observers {\n        go observer.Update(PriceUpdate{\n            Symbol: p.symbol,\n            Price:  p.price,\n            Time:   time.Now(),\n        })\n    }\n}\n\nfunc (p *PricePublisher) SetPrice(price float64) {\n    p.mu.Lock()\n    p.price = price\n    p.mu.Unlock()\n    p.Notify()\n}\n\n// Concrete Observers\ntype TradingBot struct {\n    id       string\n    strategy Strategy\n}\n\nfunc (t *TradingBot) Update(data interface{}) {\n    if priceUpdate, ok := data.(PriceUpdate); ok {\n        signal := t.strategy.Analyze(priceUpdate)\n        if signal != HoldSignal {\n            t.executeTrade(signal, priceUpdate)\n        }\n    }\n}\n\nfunc (t *TradingBot) GetID() string {\n    return t.id\n}\n\ntype PriceLogger struct {\n    id     string\n    logger *log.Logger\n}\n\nfunc (p *PriceLogger) Update(data interface{}) {\n    if priceUpdate, ok := data.(PriceUpdate); ok {\n        p.logger.Printf(\"Price update: %s = %.2f at %s\",\n            priceUpdate.Symbol,\n            priceUpdate.Price,\n            priceUpdate.Time.Format(time.RFC3339))\n    }\n}\n\nfunc (p *PriceLogger) GetID() string {\n    return p.id\n}\n\n// Event-based Observer with channels\ntype EventBus struct {\n    subscribers map[string][]chan Event\n    mu          sync.RWMutex\n}\n\nfunc NewEventBus() *EventBus {\n    return &EventBus{\n        subscribers: make(map[string][]chan Event),\n    }\n}\n\nfunc (e *EventBus) Subscribe(eventType string, ch chan Event) {\n    e.mu.Lock()\n    defer e.mu.Unlock()\n    e.subscribers[eventType] = append(e.subscribers[eventType], ch)\n}\n\nfunc (e *EventBus) Publish(event Event) {\n    e.mu.RLock()\n    defer e.mu.RUnlock()\n    \n    if channels, found := e.subscribers[event.Type]; found {\n        for _, ch := range channels {\n            go func(c chan Event) {\n                c <- event\n            }(ch)\n        }\n    }\n}\n\n// Generic Observer with type parameters (Go 1.18+)\ntype TypedSubject[T any] struct {\n    observers []func(T)\n    mu        sync.RWMutex\n}\n\nfunc NewTypedSubject[T any]() *TypedSubject[T] {\n    return &TypedSubject[T]{\n        observers: make([]func(T), 0),\n    }\n}\n\nfunc (s *TypedSubject[T]) Subscribe(handler func(T)) func() {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    \n    s.observers = append(s.observers, handler)\n    \n    // Return unsubscribe function\n    return func() {\n        s.mu.Lock()\n        defer s.mu.Unlock()\n        for i, obs := range s.observers {\n            if &obs == &handler {\n                s.observers = append(s.observers[:i], s.observers[i+1:]...)\n                break\n            }\n        }\n    }\n}\n\nfunc (s *TypedSubject[T]) Notify(data T) {\n    s.mu.RLock()\n    observers := make([]func(T), len(s.observers))\n    copy(observers, s.observers)\n    s.mu.RUnlock()\n    \n    for _, observer := range observers {\n        go observer(data)\n    }\n}\n```\n\n### Strategy Pattern\n\n```go\n// Strategy Pattern - define family of algorithms\npackage strategy\n\n// Strategy interface\ntype PaymentStrategy interface {\n    Pay(amount float64) error\n    ValidatePaymentDetails() error\n}\n\n// Concrete strategies\ntype CreditCardStrategy struct {\n    cardNumber string\n    cvv        string\n    expiry     string\n}\n\nfunc (c *CreditCardStrategy) Pay(amount float64) error {\n    if err := c.ValidatePaymentDetails(); err != nil {\n        return err\n    }\n    \n    // Process credit card payment\n    fmt.Printf(\"Paid %.2f using Credit Card ending in %s\\n\",\n        amount, c.cardNumber[len(c.cardNumber)-4:])\n    return nil\n}\n\nfunc (c *CreditCardStrategy) ValidatePaymentDetails() error {\n    if len(c.cardNumber) != 16 {\n        return errors.New(\"invalid card number\")\n    }\n    if len(c.cvv) != 3 {\n        return errors.New(\"invalid CVV\")\n    }\n    return nil\n}\n\ntype PayPalStrategy struct {\n    email    string\n    password string\n}\n\nfunc (p *PayPalStrategy) Pay(amount float64) error {\n    if err := p.ValidatePaymentDetails(); err != nil {\n        return err\n    }\n    \n    // Process PayPal payment\n    fmt.Printf(\"Paid %.2f using PayPal account %s\\n\", amount, p.email)\n    return nil\n}\n\nfunc (p *PayPalStrategy) ValidatePaymentDetails() error {\n    if !strings.Contains(p.email, \"@\") {\n        return errors.New(\"invalid email\")\n    }\n    if len(p.password) < 8 {\n        return errors.New(\"invalid password\")\n    }\n    return nil\n}\n\ntype CryptoStrategy struct {\n    walletAddress string\n    privateKey    string\n    currency      string\n}\n\nfunc (c *CryptoStrategy) Pay(amount float64) error {\n    if err := c.ValidatePaymentDetails(); err != nil {\n        return err\n    }\n    \n    // Process cryptocurrency payment\n    fmt.Printf(\"Paid %.2f %s from wallet %s\\n\",\n        amount, c.currency, c.walletAddress[:10]+\"...\")\n    return nil\n}\n\nfunc (c *CryptoStrategy) ValidatePaymentDetails() error {\n    if len(c.walletAddress) < 26 {\n        return errors.New(\"invalid wallet address\")\n    }\n    if len(c.privateKey) < 32 {\n        return errors.New(\"invalid private key\")\n    }\n    return nil\n}\n\n// Context\ntype PaymentProcessor struct {\n    strategy PaymentStrategy\n}\n\nfunc (p *PaymentProcessor) SetStrategy(strategy PaymentStrategy) {\n    p.strategy = strategy\n}\n\nfunc (p *PaymentProcessor) ProcessPayment(amount float64) error {\n    if p.strategy == nil {\n        return errors.New(\"payment strategy not set\")\n    }\n    return p.strategy.Pay(amount)\n}\n\n// Trading Strategy Example\ntype TradingStrategy interface {\n    ShouldBuy(data MarketData) bool\n    ShouldSell(data MarketData) bool\n    GetStopLoss(entryPrice float64) float64\n    GetTakeProfit(entryPrice float64) float64\n}\n\ntype MomentumStrategy struct {\n    period    int\n    threshold float64\n}\n\nfunc (m *MomentumStrategy) ShouldBuy(data MarketData) bool {\n    momentum := calculateMomentum(data.Prices, m.period)\n    return momentum > m.threshold\n}\n\nfunc (m *MomentumStrategy) ShouldSell(data MarketData) bool {\n    momentum := calculateMomentum(data.Prices, m.period)\n    return momentum < -m.threshold\n}\n\nfunc (m *MomentumStrategy) GetStopLoss(entryPrice float64) float64 {\n    return entryPrice * 0.98 // 2% stop loss\n}\n\nfunc (m *MomentumStrategy) GetTakeProfit(entryPrice float64) float64 {\n    return entryPrice * 1.05 // 5% take profit\n}\n\ntype MeanReversionStrategy struct {\n    period      int\n    stdDevMulti float64\n}\n\nfunc (m *MeanReversionStrategy) ShouldBuy(data MarketData) bool {\n    mean, stdDev := calculateBollingerBands(data.Prices, m.period)\n    currentPrice := data.Prices[len(data.Prices)-1]\n    return currentPrice < mean-stdDev*m.stdDevMulti\n}\n\nfunc (m *MeanReversionStrategy) ShouldSell(data MarketData) bool {\n    mean, stdDev := calculateBollingerBands(data.Prices, m.period)\n    currentPrice := data.Prices[len(data.Prices)-1]\n    return currentPrice > mean+stdDev*m.stdDevMulti\n}\n\nfunc (m *MeanReversionStrategy) GetStopLoss(entryPrice float64) float64 {\n    return entryPrice * 0.95 // 5% stop loss\n}\n\nfunc (m *MeanReversionStrategy) GetTakeProfit(entryPrice float64) float64 {\n    return entryPrice * 1.02 // 2% take profit\n}\n\n// Strategy Factory\nfunc CreateStrategy(name string, params map[string]interface{}) (TradingStrategy, error) {\n    switch name {\n    case \"momentum\":\n        return &MomentumStrategy{\n            period:    params[\"period\"].(int),\n            threshold: params[\"threshold\"].(float64),\n        }, nil\n    case \"mean_reversion\":\n        return &MeanReversionStrategy{\n            period:      params[\"period\"].(int),\n            stdDevMulti: params[\"std_dev\"].(float64),\n        }, nil\n    default:\n        return nil, fmt.Errorf(\"unknown strategy: %s\", name)\n    }\n}\n```\n\n## Concurrency Patterns\n\n### Worker Pool Pattern\n\n```go\n// Worker Pool Pattern\npackage concurrency\n\ntype Job struct {\n    ID   int\n    Data interface{}\n}\n\ntype Result struct {\n    JobID int\n    Data  interface{}\n    Error error\n}\n\ntype WorkerPool struct {\n    workers    int\n    jobs       chan Job\n    results    chan Result\n    done       chan struct{}\n    wg         sync.WaitGroup\n}\n\nfunc NewWorkerPool(workers int, jobBuffer int) *WorkerPool {\n    return &WorkerPool{\n        workers: workers,\n        jobs:    make(chan Job, jobBuffer),\n        results: make(chan Result, jobBuffer),\n        done:    make(chan struct{}),\n    }\n}\n\nfunc (p *WorkerPool) Start(handler func(Job) Result) {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go p.worker(i, handler)\n    }\n}\n\nfunc (p *WorkerPool) worker(id int, handler func(Job) Result) {\n    defer p.wg.Done()\n    \n    for {\n        select {\n        case job, ok := <-p.jobs:\n            if !ok {\n                return\n            }\n            result := handler(job)\n            \n            select {\n            case p.results <- result:\n            case <-p.done:\n                return\n            }\n        case <-p.done:\n            return\n        }\n    }\n}\n\nfunc (p *WorkerPool) Submit(job Job) {\n    select {\n    case p.jobs <- job:\n    case <-p.done:\n    }\n}\n\nfunc (p *WorkerPool) GetResult() (Result, bool) {\n    select {\n    case result := <-p.results:\n        return result, true\n    default:\n        return Result{}, false\n    }\n}\n\nfunc (p *WorkerPool) Shutdown() {\n    close(p.done)\n    close(p.jobs)\n    p.wg.Wait()\n    close(p.results)\n}\n\n// Advanced Worker Pool with context and rate limiting\ntype AdvancedWorkerPool struct {\n    workers     int\n    jobQueue    chan Job\n    resultQueue chan Result\n    ctx         context.Context\n    cancel      context.CancelFunc\n    limiter     *rate.Limiter\n    wg          sync.WaitGroup\n}\n\nfunc NewAdvancedWorkerPool(ctx context.Context, workers int, rateLimit int) *AdvancedWorkerPool {\n    ctx, cancel := context.WithCancel(ctx)\n    return &AdvancedWorkerPool{\n        workers:     workers,\n        jobQueue:    make(chan Job, workers*2),\n        resultQueue: make(chan Result, workers*2),\n        ctx:         ctx,\n        cancel:      cancel,\n        limiter:     rate.NewLimiter(rate.Limit(rateLimit), 1),\n    }\n}\n\nfunc (p *AdvancedWorkerPool) Start(handler func(context.Context, Job) Result) {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go func(workerID int) {\n            defer p.wg.Done()\n            \n            for {\n                select {\n                case <-p.ctx.Done():\n                    return\n                case job := <-p.jobQueue:\n                    // Apply rate limiting\n                    if err := p.limiter.Wait(p.ctx); err != nil {\n                        p.resultQueue <- Result{\n                            JobID: job.ID,\n                            Error: err,\n                        }\n                        continue\n                    }\n                    \n                    // Process job with timeout\n                    jobCtx, cancel := context.WithTimeout(p.ctx, 30*time.Second)\n                    result := handler(jobCtx, job)\n                    cancel()\n                    \n                    select {\n                    case p.resultQueue <- result:\n                    case <-p.ctx.Done():\n                        return\n                    }\n                }\n            }\n        }(i)\n    }\n}\n```\n\n### Fan-Out/Fan-In Pattern\n\n```go\n// Fan-Out/Fan-In Pattern\npackage concurrency\n\n// Fan-out: distribute work across multiple goroutines\nfunc FanOut(in <-chan int, workers int) []<-chan int {\n    channels := make([]<-chan int, workers)\n    \n    for i := 0; i < workers; i++ {\n        ch := make(chan int)\n        channels[i] = ch\n        \n        go func(out chan<- int) {\n            for val := range in {\n                // Process value\n                result := val * val\n                out <- result\n            }\n            close(out)\n        }(ch)\n    }\n    \n    return channels\n}\n\n// Fan-in: merge multiple channels into one\nfunc FanIn(channels ...<-chan int) <-chan int {\n    out := make(chan int)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan int) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n\n// Generic Fan-Out/Fan-In\nfunc FanOutGeneric[T any, R any](\n    in <-chan T,\n    workers int,\n    processor func(T) R,\n) []<-chan R {\n    channels := make([]<-chan R, workers)\n    \n    for i := 0; i < workers; i++ {\n        ch := make(chan R)\n        channels[i] = ch\n        \n        go func(out chan<- R) {\n            for val := range in {\n                out <- processor(val)\n            }\n            close(out)\n        }(ch)\n    }\n    \n    return channels\n}\n\nfunc FanInGeneric[T any](channels ...<-chan T) <-chan T {\n    out := make(chan T)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan T) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n\n// Usage example\nfunc ProcessDataPipeline(data []int) []int {\n    // Create input channel\n    input := make(chan int)\n    go func() {\n        for _, val := range data {\n            input <- val\n        }\n        close(input)\n    }()\n    \n    // Fan-out to 4 workers\n    workers := FanOut(input, 4)\n    \n    // Fan-in results\n    output := FanIn(workers...)\n    \n    // Collect results\n    var results []int\n    for result := range output {\n        results = append(results, result)\n    }\n    \n    return results\n}\n```\n\n### Pipeline Pattern\n\n```go\n// Pipeline Pattern\npackage concurrency\n\n// Pipeline stages\nfunc Generate(nums ...int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for _, n := range nums {\n            out <- n\n        }\n        close(out)\n    }()\n    return out\n}\n\nfunc Square(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            out <- n * n\n        }\n        close(out)\n    }()\n    return out\n}\n\nfunc Filter(in <-chan int, predicate func(int) bool) <-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            if predicate(n) {\n                out <- n\n            }\n        }\n        close(out)\n    }()\n    return out\n}\n\n// Generic Pipeline\ntype Pipeline[T any] struct {\n    stages []func(<-chan T) <-chan T\n}\n\nfunc NewPipeline[T any]() *Pipeline[T] {\n    return &Pipeline[T]{}\n}\n\nfunc (p *Pipeline[T]) AddStage(stage func(<-chan T) <-chan T) *Pipeline[T] {\n    p.stages = append(p.stages, stage)\n    return p\n}\n\nfunc (p *Pipeline[T]) Execute(input <-chan T) <-chan T {\n    output := input\n    for _, stage := range p.stages {\n        output = stage(output)\n    }\n    return output\n}\n\n// Cancellable Pipeline\nfunc GenerateWithCancel(ctx context.Context, nums ...int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for _, n := range nums {\n            select {\n            case out <- n:\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return out\n}\n\nfunc TransformWithCancel(ctx context.Context, in <-chan int, fn func(int) int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for {\n            select {\n            case n, ok := <-in:\n                if !ok {\n                    return\n                }\n                select {\n                case out <- fn(n):\n                case <-ctx.Done():\n                    return\n                }\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n    return out\n}\n\n// Error handling in pipeline\ntype Result[T any] struct {\n    Value T\n    Error error\n}\n\nfunc TransformWithError[T, R any](\n    in <-chan Result[T],\n    fn func(T) (R, error),\n) <-chan Result[R] {\n    out := make(chan Result[R])\n    go func() {\n        defer close(out)\n        for result := range in {\n            if result.Error != nil {\n                out <- Result[R]{Error: result.Error}\n                continue\n            }\n            \n            value, err := fn(result.Value)\n            out <- Result[R]{Value: value, Error: err}\n        }\n    }()\n    return out\n}\n```\n\n## Go-Specific Idioms\n\n### Functional Options Pattern\n\n```go\n// Functional Options Pattern\npackage idioms\n\ntype Server struct {\n    host        string\n    port        int\n    timeout     time.Duration\n    maxConn     int\n    tls         bool\n    middlewares []func(http.Handler) http.Handler\n}\n\ntype Option func(*Server)\n\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = timeout\n    }\n}\n\nfunc WithTLS(enabled bool) Option {\n    return func(s *Server) {\n        s.tls = enabled\n    }\n}\n\nfunc WithMiddleware(mw func(http.Handler) http.Handler) Option {\n    return func(s *Server) {\n        s.middlewares = append(s.middlewares, mw)\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    // Default values\n    s := &Server{\n        host:    \"localhost\",\n        port:    8080,\n        timeout: 30 * time.Second,\n        maxConn: 100,\n    }\n    \n    // Apply options\n    for _, opt := range opts {\n        opt(s)\n    }\n    \n    return s\n}\n\n// Usage\nserver := NewServer(\n    WithHost(\"api.example.com\"),\n    WithPort(443),\n    WithTLS(true),\n    WithTimeout(60*time.Second),\n    WithMiddleware(loggingMiddleware),\n    WithMiddleware(authMiddleware),\n)\n\n// Advanced: Options with validation\ntype OptionError struct {\n    Option string\n    Err    error\n}\n\ntype OptionWithError func(*Server) error\n\nfunc WithPortValidated(port int) OptionWithError {\n    return func(s *Server) error {\n        if port < 1 || port > 65535 {\n            return fmt.Errorf(\"invalid port: %d\", port)\n        }\n        s.port = port\n        return nil\n    }\n}\n\nfunc NewServerValidated(opts ...OptionWithError) (*Server, error) {\n    s := &Server{\n        host:    \"localhost\",\n        port:    8080,\n        timeout: 30 * time.Second,\n    }\n    \n    for _, opt := range opts {\n        if err := opt(s); err != nil {\n            return nil, err\n        }\n    }\n    \n    return s, nil\n}\n```\n\n### Embedding Pattern\n\n```go\n// Embedding Pattern\npackage idioms\n\n// Interface embedding\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Struct embedding for composition\ntype Logger struct {\n    prefix string\n}\n\nfunc (l *Logger) Log(message string) {\n    fmt.Printf(\"[%s] %s\\n\", l.prefix, message)\n}\n\ntype Service struct {\n    Logger  // Embedded\n    name string\n}\n\nfunc (s *Service) Start() {\n    s.Log(fmt.Sprintf(\"Starting service: %s\", s.name))  // Promoted method\n}\n\n// Embedding to extend functionality\ntype ResponseWriter struct {\n    http.ResponseWriter  // Embed standard interface\n    statusCode int\n}\n\nfunc (w *ResponseWriter) WriteHeader(code int) {\n    w.statusCode = code\n    w.ResponseWriter.WriteHeader(code)\n}\n\nfunc WrapResponseWriter(w http.ResponseWriter) *ResponseWriter {\n    return &ResponseWriter{ResponseWriter: w, statusCode: 200}\n}\n\n// Multiple embedding with method overriding\ntype Animal struct {\n    Name string\n}\n\nfunc (a *Animal) Speak() string {\n    return fmt.Sprintf(\"%s makes a sound\", a.Name)\n}\n\nfunc (a *Animal) Move() string {\n    return fmt.Sprintf(\"%s moves\", a.Name)\n}\n\ntype Swimmer struct{}\n\nfunc (s *Swimmer) Swim() string {\n    return \"swimming\"\n}\n\ntype Flyer struct{}\n\nfunc (f *Flyer) Fly() string {\n    return \"flying\"\n}\n\ntype Duck struct {\n    Animal\n    Swimmer\n    Flyer\n}\n\nfunc (d *Duck) Speak() string {\n    return fmt.Sprintf(\"%s quacks\", d.Name)  // Override Animal.Speak\n}\n\n// Usage\nduck := &Duck{Animal: Animal{Name: \"Donald\"}}\nfmt.Println(duck.Speak())  // \"Donald quacks\" (overridden)\nfmt.Println(duck.Move())   // \"Donald moves\" (inherited)\nfmt.Println(duck.Swim())   // \"swimming\"\nfmt.Println(duck.Fly())    // \"flying\"\n```\n\n### Empty Interface and Type Assertion Pattern\n\n```go\n// Type Assertion and Switch Pattern\npackage idioms\n\nfunc ProcessValue(v interface{}) (string, error) {\n    switch val := v.(type) {\n    case string:\n        return val, nil\n    case int:\n        return strconv.Itoa(val), nil\n    case float64:\n        return fmt.Sprintf(\"%.2f\", val), nil\n    case bool:\n        return strconv.FormatBool(val), nil\n    case fmt.Stringer:\n        return val.String(), nil\n    case error:\n        return \"\", val\n    default:\n        return \"\", fmt.Errorf(\"unsupported type: %T\", v)\n    }\n}\n\n// Safe type assertion\nfunc SafeCast[T any](v interface{}) (T, bool) {\n    result, ok := v.(T)\n    return result, ok\n}\n\n// Generic constraint with type assertion\ntype Number interface {\n    int | int64 | float32 | float64\n}\n\nfunc ConvertToFloat64[T Number](v T) float64 {\n    // Type switch not needed with generics\n    return float64(v)\n}\n\n// Store with type-safe retrieval\ntype TypedStore struct {\n    data map[string]interface{}\n    mu   sync.RWMutex\n}\n\nfunc (s *TypedStore) Set(key string, value interface{}) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.data[key] = value\n}\n\nfunc (s *TypedStore) Get(key string) (interface{}, bool) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    val, ok := s.data[key]\n    return val, ok\n}\n\nfunc (s *TypedStore) GetString(key string) (string, error) {\n    val, ok := s.Get(key)\n    if !ok {\n        return \"\", fmt.Errorf(\"key not found: %s\", key)\n    }\n    \n    str, ok := val.(string)\n    if !ok {\n        return \"\", fmt.Errorf(\"value is not string: %T\", val)\n    }\n    \n    return str, nil\n}\n\nfunc (s *TypedStore) GetInt(key string) (int, error) {\n    val, ok := s.Get(key)\n    if !ok {\n        return 0, fmt.Errorf(\"key not found: %s\", key)\n    }\n    \n    switch v := val.(type) {\n    case int:\n        return v, nil\n    case int64:\n        return int(v), nil\n    case float64:\n        return int(v), nil\n    default:\n        return 0, fmt.Errorf(\"value is not numeric: %T\", val)\n    }\n}\n```\n\n## Architecture Patterns\n\n### Hexagonal Architecture (Ports & Adapters)\n\n```go\n// Hexagonal Architecture Pattern\npackage architecture\n\n// Core Domain (center of hexagon)\ntype Order struct {\n    ID        string\n    Symbol    string\n    Quantity  float64\n    Price     float64\n    Type      OrderType\n    Status    OrderStatus\n    CreatedAt time.Time\n}\n\ntype OrderService struct {\n    repo      OrderRepository      // Port\n    exchange  ExchangeGateway      // Port\n    notifier  NotificationService  // Port\n}\n\n// Ports (interfaces defined by core)\ntype OrderRepository interface {\n    Save(order *Order) error\n    FindByID(id string) (*Order, error)\n    FindByStatus(status OrderStatus) ([]*Order, error)\n}\n\ntype ExchangeGateway interface {\n    PlaceOrder(order *Order) error\n    CancelOrder(orderID string) error\n    GetOrderStatus(orderID string) (OrderStatus, error)\n}\n\ntype NotificationService interface {\n    NotifyOrderPlaced(order *Order) error\n    NotifyOrderFilled(order *Order) error\n}\n\n// Adapters (implementations)\ntype PostgresOrderRepository struct {\n    db *sql.DB\n}\n\nfunc (r *PostgresOrderRepository) Save(order *Order) error {\n    query := `INSERT INTO orders (id, symbol, quantity, price, type, status, created_at)\n              VALUES ($1, $2, $3, $4, $5, $6, $7)`\n    _, err := r.db.Exec(query, order.ID, order.Symbol, order.Quantity,\n                         order.Price, order.Type, order.Status, order.CreatedAt)\n    return err\n}\n\nfunc (r *PostgresOrderRepository) FindByID(id string) (*Order, error) {\n    // Implementation\n    return nil, nil\n}\n\nfunc (r *PostgresOrderRepository) FindByStatus(status OrderStatus) ([]*Order, error) {\n    // Implementation\n    return nil, nil\n}\n\ntype BinanceExchangeAdapter struct {\n    apiKey    string\n    apiSecret string\n    client    *binance.Client\n}\n\nfunc (b *BinanceExchangeAdapter) PlaceOrder(order *Order) error {\n    // Convert domain order to Binance API format\n    binanceOrder := b.toBinanceOrder(order)\n    // Call Binance API\n    return b.client.CreateOrder(binanceOrder)\n}\n\nfunc (b *BinanceExchangeAdapter) CancelOrder(orderID string) error {\n    return b.client.CancelOrder(orderID)\n}\n\nfunc (b *BinanceExchangeAdapter) GetOrderStatus(orderID string) (OrderStatus, error) {\n    status, err := b.client.GetOrder(orderID)\n    if err != nil {\n        return \"\", err\n    }\n    return b.fromBinanceStatus(status), nil\n}\n\ntype EmailNotificationAdapter struct {\n    smtpHost string\n    smtpPort int\n}\n\nfunc (e *EmailNotificationAdapter) NotifyOrderPlaced(order *Order) error {\n    subject := fmt.Sprintf(\"Order Placed: %s\", order.ID)\n    body := fmt.Sprintf(\"Your order for %f %s has been placed\", order.Quantity, order.Symbol)\n    return e.sendEmail(subject, body)\n}\n\nfunc (e *EmailNotificationAdapter) NotifyOrderFilled(order *Order) error {\n    subject := fmt.Sprintf(\"Order Filled: %s\", order.ID)\n    body := fmt.Sprintf(\"Your order for %f %s has been filled at %f\",\n                        order.Quantity, order.Symbol, order.Price)\n    return e.sendEmail(subject, body)\n}\n\n// Dependency Injection\nfunc NewOrderService(\n    repo OrderRepository,\n    exchange ExchangeGateway,\n    notifier NotificationService,\n) *OrderService {\n    return &OrderService{\n        repo:     repo,\n        exchange: exchange,\n        notifier: notifier,\n    }\n}\n\n// Usage\nfunc main() {\n    // Setup adapters\n    db, _ := sql.Open(\"postgres\", \"connection-string\")\n    repo := &PostgresOrderRepository{db: db}\n    exchange := &BinanceExchangeAdapter{apiKey: \"key\", apiSecret: \"secret\"}\n    notifier := &EmailNotificationAdapter{smtpHost: \"smtp.gmail.com\", smtpPort: 587}\n    \n    // Create service with injected dependencies\n    service := NewOrderService(repo, exchange, notifier)\n    \n    // Use service\n    order := &Order{\n        ID:       generateID(),\n        Symbol:   \"BTC/USDT\",\n        Quantity: 0.01,\n        Price:    50000,\n        Type:     LimitOrder,\n    }\n    \n    service.PlaceOrder(order)\n}\n```\n\nThis completes the comprehensive guide to Go design patterns. Each pattern is demonstrated with practical, real-world examples that show how to implement them idiomatically in Go.","structuredPatch":[]}}
{"parentUuid":"16676f79-d571-40bb-b23e-5b1c29604de9","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01CU9eJ82Lsq1EBnXbtKyhuC","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now I'll continue creating more comprehensive Go documentation files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":65870,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS5G4tcQkDvtCuhsE4nBh","type":"assistant","uuid":"54330464-2224-4d15-ac3e-c7845d6f9006","timestamp":"2025-08-13T06:47:29.158Z"}
{"parentUuid":"54330464-2224-4d15-ac3e-c7845d6f9006","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"assistant","uuid":"ed1ac993-2d9b-4237-8dfc-2b38ee7d7a2d","timestamp":"2025-08-13T07:05:41.306Z","message":{"id":"b362c2e3-3682-400f-b792-25aa281d0e2a","model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0},"service_tier":null},"content":[{"type":"text","text":"API Error: Request timed out."}]},"isApiErrorMessage":true}
{"parentUuid":"66dc3d77-023d-43b0-ad64-ec7f1fe50ecf","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GPpcgd68cKwbZSRj2AUnm6","type":"tool_result","content":[{"type":"text","text":"API Error: Request timed out."}]}]},"uuid":"a1183aa3-e72c-48a2-9620-e166ce963d27","timestamp":"2025-08-13T07:05:41.319Z","toolUseResult":{"content":[{"type":"text","text":"API Error: Request timed out."}],"totalDurationMs":1854211,"totalTokens":0,"totalToolUseCount":4,"usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0},"service_tier":null}}}
{"parentUuid":"a1183aa3-e72c-48a2-9620-e166ce963d27","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01VREhJmh6FaRvxqvcjj3w4H","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Let me retry with a more focused approach:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":25301,"cache_read_input_tokens":11551,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS5HTpNRfAs9D6aDpyy6r","type":"assistant","uuid":"76d9f16f-37dc-41fc-ab8e-0cc5bd2fd5cc","timestamp":"2025-08-13T07:05:45.911Z"}
{"parentUuid":"76d9f16f-37dc-41fc-ab8e-0cc5bd2fd5cc","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01VREhJmh6FaRvxqvcjj3w4H","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01WDqGi6MsGb97iMSkeL7Ru5","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Examine existing /back/.docs/code/practices-patterns file","status":"pending"},{"id":"2","content":"Create comprehensive Go language fundamentals documentation","status":"pending"},{"id":"3","content":"Document all Go design patterns and idioms","status":"pending"},{"id":"4","content":"Create advanced Go concurrency documentation","status":"pending"},{"id":"5","content":"Document Go testing and benchmarking practices","status":"pending"},{"id":"6","content":"Create Go performance optimization guide","status":"pending"},{"id":"7","content":"Document Go security best practices","status":"pending"},{"id":"8","content":"Create Go tooling and ecosystem documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":25301,"cache_read_input_tokens":11551,"output_tokens":357,"service_tier":"standard"}},"requestId":"req_011CS5HTpNRfAs9D6aDpyy6r","type":"assistant","uuid":"be18beba-e599-4c42-839d-5d2dc0faeed3","timestamp":"2025-08-13T07:05:53.675Z"}
{"parentUuid":"be18beba-e599-4c42-839d-5d2dc0faeed3","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WDqGi6MsGb97iMSkeL7Ru5","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"76fe5fc0-e83b-4f2c-a88a-7a4edac1d69e","timestamp":"2025-08-13T07:05:53.715Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"pending","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"pending","id":"2"},{"content":"Document all Go design patterns and idioms","status":"pending","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}]}}
{"parentUuid":"76fe5fc0-e83b-4f2c-a88a-7a4edac1d69e","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01WamcfyNXTsurRLnuwTyL7S","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01DPScpyZGMu1k3WNpVicMg2","name":"Task","input":{"description":"Create comprehensive Go documentation","subagent_type":"gad","prompt":"Create exhaustively comprehensive Go programming documentation in /back/.docs/code/.\n\nFirst, read the existing /back/.docs/code/practices-patterns file to understand current documentation.\n\nThen create a complete set of Go documentation files covering:\n\n1. **go-fundamentals.md** - Complete language reference: syntax, types, control flow, functions, methods, structs, interfaces, error handling basics\n\n2. **go-concurrency.md** - Mastering concurrency: goroutines, channels, select, sync package, atomic operations, patterns, race conditions, deadlocks\n\n3. **go-patterns.md** - All design patterns for Go: creational, structural, behavioral, concurrency patterns, Go idioms, functional options, dependency injection\n\n4. **go-testing.md** - Complete testing guide: unit tests, table-driven tests, subtests, mocks, fuzz testing, benchmarks, coverage, integration tests\n\n5. **go-performance.md** - Optimization mastery: profiling (CPU, memory, goroutine), benchmarking, memory management, compiler optimizations, caching strategies\n\n6. **go-packages.md** - Package design: API design, internal packages, versioning, documentation, module management, dependencies\n\n7. **go-errors.md** - Error handling excellence: error types, wrapping, sentinel errors, custom errors, panic/recover, error design patterns\n\n8. **go-security.md** - Security practices: input validation, SQL injection prevention, crypto usage, secrets management, common vulnerabilities\n\n9. **go-tools.md** - Tooling ecosystem: go commands, linters, formatters, static analysis, debugging, code generation, build tags\n\n10. **go-advanced.md** - Expert topics: reflection, unsafe, cgo, assembly, compiler directives, runtime internals\n\nEach file should be exhaustive with practical examples, best practices, and anti-patterns to avoid. Make this the definitive Go reference.\n\nOutput the documentation directly to the terminal as you create it, so I can see the comprehensive content being generated."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":515,"cache_read_input_tokens":36852,"output_tokens":543,"service_tier":"standard"}},"requestId":"req_011CS5HUk4zUjWE2RU5hxCKR","type":"assistant","uuid":"ef9d2eff-d788-456c-b5a3-771b7e3c5c6f","timestamp":"2025-08-13T07:06:08.556Z"}
{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":"Create exhaustively comprehensive Go programming documentation in /back/.docs/code/.\n\nFirst, read the existing /back/.docs/code/practices-patterns file to understand current documentation.\n\nThen create a complete set of Go documentation files covering:\n\n1. **go-fundamentals.md** - Complete language reference: syntax, types, control flow, functions, methods, structs, interfaces, error handling basics\n\n2. **go-concurrency.md** - Mastering concurrency: goroutines, channels, select, sync package, atomic operations, patterns, race conditions, deadlocks\n\n3. **go-patterns.md** - All design patterns for Go: creational, structural, behavioral, concurrency patterns, Go idioms, functional options, dependency injection\n\n4. **go-testing.md** - Complete testing guide: unit tests, table-driven tests, subtests, mocks, fuzz testing, benchmarks, coverage, integration tests\n\n5. **go-performance.md** - Optimization mastery: profiling (CPU, memory, goroutine), benchmarking, memory management, compiler optimizations, caching strategies\n\n6. **go-packages.md** - Package design: API design, internal packages, versioning, documentation, module management, dependencies\n\n7. **go-errors.md** - Error handling excellence: error types, wrapping, sentinel errors, custom errors, panic/recover, error design patterns\n\n8. **go-security.md** - Security practices: input validation, SQL injection prevention, crypto usage, secrets management, common vulnerabilities\n\n9. **go-tools.md** - Tooling ecosystem: go commands, linters, formatters, static analysis, debugging, code generation, build tags\n\n10. **go-advanced.md** - Expert topics: reflection, unsafe, cgo, assembly, compiler directives, runtime internals\n\nEach file should be exhaustive with practical examples, best practices, and anti-patterns to avoid. Make this the definitive Go reference.\n\nOutput the documentation directly to the terminal as you create it, so I can see the comprehensive content being generated."},"uuid":"a839c3a7-0b77-4831-bd56-f9a2ac9fc283","timestamp":"2025-08-13T07:06:08.593Z"}
{"parentUuid":"a839c3a7-0b77-4831-bd56-f9a2ac9fc283","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_018X7q2XNnPfbtnmutK3FuXB","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"I'll create comprehensive Go programming documentation for you. Let me first read the existing practices-patterns file to understand the current documentation structure, then create the exhaustive documentation set."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1647,"cache_read_input_tokens":30636,"output_tokens":111,"service_tier":"standard"}},"requestId":"req_011CS5HVp4srxG3ogsMesZao","type":"assistant","uuid":"baaa782b-ec9f-40d5-b260-e2a4e23793e6","timestamp":"2025-08-13T07:06:12.334Z"}
{"parentUuid":"baaa782b-ec9f-40d5-b260-e2a4e23793e6","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_018X7q2XNnPfbtnmutK3FuXB","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01DZ9uZomzN92LFwxv47Hy2S","name":"Read","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1647,"cache_read_input_tokens":30636,"output_tokens":111,"service_tier":"standard"}},"requestId":"req_011CS5HVp4srxG3ogsMesZao","type":"assistant","uuid":"f001a6ce-0f00-407b-8f6f-940f39932e0a","timestamp":"2025-08-13T07:06:13.036Z"}
{"parentUuid":"f001a6ce-0f00-407b-8f6f-940f39932e0a","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DZ9uZomzN92LFwxv47Hy2S","type":"tool_result","content":"     1→# Go Best Practices\n     2→\n     3→## Overview\n     4→\n     5→Go-specific best practices and patterns following Go idioms and community standards.\n     6→\n     7→### Core Go Principles\n     8→- **Simplicity over abstraction** - Start simple, add complexity only when needed\n     9→- **Channels for communication** - Don't communicate by sharing memory, share memory by communicating\n    10→- **Errors as values** - Return errors, don't panic\n    11→- **Small interfaces** - The bigger the interface, the weaker the abstraction\n    12→- **Composition over inheritance** - Embed types, don't create hierarchies\n    13→- **Context for cancellation** - Pass context.Context for cancellation and timeouts\n    14→\n    15→## Interface Design\n    16→\n    17→### Small, Focused Interfaces\n    18→\n    19→Follow the Go proverb: \"The bigger the interface, the weaker the abstraction.\"\n    20→\n    21→```go\n    22→// ✅ GOOD: Small interfaces are easier to implement and test\n    23→type PriceProvider interface {\n    24→    GetPrice(symbol string) (decimal.Decimal, error)\n    25→}\n    26→\n    27→type OrderPlacer interface {\n    28→    PlaceOrder(order *Order) (*OrderResult, error)\n    29→}\n    30→\n    31→// ❌ BAD: Large interface with many responsibilities\n    32→type TradingService interface {\n    33→    GetPrice(symbol string) (decimal.Decimal, error)\n    34→    PlaceOrder(order *Order) (*OrderResult, error)\n    35→    CancelOrder(id string) error\n    36→    GetOrderStatus(id string) (*OrderStatus, error)\n    37→    GetBalance(currency string) (decimal.Decimal, error)\n    38→    // ... 20 more methods\n    39→}\n    40→```\n    41→\n    42→## Naming Conventions\n    43→\n    44→### Clear Names Without Unnecessary Abbreviations\n    45→\n    46→```go\n    47→// ❌ BAD: Unclear abbreviations\n    48→cfg, mgr, svc, calc, resp, req\n    49→\n    50→// ✅ GOOD: Clear, full names\n    51→config, manager, service, calculate, response, request\n    52→\n    53→// Exception: Well-known abbreviations are acceptable\n    54→ctx context.Context  // Standard Go abbreviation\n    55→db *sql.DB          // Widely understood\n    56→err error           // Go convention\n    57→```\n    58→\n    59→### Function and Method Names\n    60→\n    61→```go\n    62→// Function names should be self-explanatory\n    63→func CalculatePositionSize(balance, riskPercentage decimal.Decimal) decimal.Decimal\n    64→\n    65→// Avoid redundant package names in functions\n    66→// ❌ BAD\n    67→package order\n    68→func OrderValidator() // order.OrderValidator is redundant\n    69→\n    70→// ✅ GOOD\n    71→package order\n    72→func Validator() // order.Validator is clear\n    73→```\n    74→\n    75→### Receiver Names\n    76→\n    77→Use single-letter receivers for methods:\n    78→\n    79→```go\n    80→// ✅ GOOD: Single letter that represents the type\n    81→func (s *Strategy) Analyze(data MarketData) Signal\n    82→func (c *Config) Validate() error\n    83→func (o *Order) Execute() error\n    84→\n    85→// ❌ BAD: Long receiver names\n    86→func (strategy *Strategy) Analyze(data MarketData) Signal\n    87→func (config *Config) Validate() error\n    88→```\n    89→\n    90→## Error Handling\n    91→\n    92→### Always Check Errors\n    93→\n    94→Never ignore errors, even in deferred functions:\n    95→\n    96→```go\n    97→// ❌ BAD: Ignoring error\n    98→defer file.Close()\n    99→\n   100→// ✅ GOOD: Check error even in defer\n   101→defer func() {\n   102→    if err := file.Close(); err != nil {\n   103→        log.Printf(\"failed to close file: %v\", err)\n   104→    }\n   105→}()\n   106→```\n   107→\n   108→## Concurrency Patterns\n   109→\n   110→### Don't Communicate by Sharing Memory\n   111→\n   112→Follow Go's concurrency philosophy:\n   113→\n   114→```go\n   115→// ❌ BAD: Shared memory with mutex\n   116→type Counter struct {\n   117→    mu    sync.Mutex\n   118→    value int\n   119→}\n   120→\n   121→func (c *Counter) Inc() {\n   122→    c.mu.Lock()\n   123→    c.value++\n   124→    c.mu.Unlock()\n   125→}\n   126→\n   127→// ✅ GOOD: Communicate via channels\n   128→type Counter struct {\n   129→    inc chan int\n   130→    get chan int\n   131→}\n   132→\n   133→func (c *Counter) run() {\n   134→    value := 0\n   135→    for {\n   136→        select {\n   137→        case <-c.inc:\n   138→            value++\n   139→        case c.get <- value:\n   140→        }\n   141→    }\n   142→}\n   143→```\n   144→\n   145→### Context for Cancellation\n   146→\n   147→Always use context for cancellation and timeouts:\n   148→\n   149→```go\n   150→// ✅ GOOD: Respecting context\n   151→func FetchData(ctx context.Context, symbol string) (*Data, error) {\n   152→    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n   153→    if err != nil {\n   154→        return nil, err\n   155→    }\n   156→\n   157→    resp, err := client.Do(req)\n   158→    // ... handle response\n   159→}\n   160→```\n   161→\n   162→## Resource Management\n   163→\n   164→### Defer Cleanup\n   165→\n   166→Always defer cleanup immediately after acquiring resources:\n   167→\n   168→```go\n   169→// ✅ GOOD: Immediate defer\n   170→file, err := os.Open(\"data.txt\")\n   171→if err != nil {\n   172→    return err\n   173→}\n   174→defer file.Close() // Immediately after successful open\n   175→\n   176→// Process file...\n   177→```\n   178→\n   179→### Check Close Errors\n   180→\n   181→Some Close operations can fail and should be checked:\n   182→\n   183→```go\n   184→// ✅ GOOD: Check close error for writers\n   185→func WriteData(filename string, data []byte) error {\n   186→    file, err := os.Create(filename)\n   187→    if err != nil {\n   188→        return err\n   189→    }\n   190→    defer func() {\n   191→        if cerr := file.Close(); cerr != nil && err == nil {\n   192→            err = cerr // Capture close error if no other error\n   193→        }\n   194→    }()\n   195→\n   196→    _, err = file.Write(data)\n   197→    return err\n   198→}\n   199→```\n   200→\n   201→## Testing\n   202→\n   203→### Table-Driven Tests\n   204→\n   205→```go\n   206→func TestCalculatePositionSize(t *testing.T) {\n   207→    tests := []struct {\n   208→        name     string\n   209→        balance  decimal.Decimal\n   210→        risk     decimal.Decimal\n   211→        stopLoss decimal.Decimal\n   212→        want     decimal.Decimal\n   213→        wantErr  bool\n   214→    }{\n   215→        {\n   216→            name:     \"valid inputs\",\n   217→            balance:  decimal.NewFromInt(10000),\n   218→            risk:     decimal.NewFromFloat(0.02),\n   219→            stopLoss: decimal.NewFromInt(100),\n   220→            want:     decimal.NewFromInt(200),\n   221→            wantErr:  false,\n   222→        },\n   223→        {\n   224→            name:     \"negative balance\",\n   225→            balance:  decimal.NewFromInt(-1000),\n   226→            risk:     decimal.NewFromFloat(0.02),\n   227→            stopLoss: decimal.NewFromInt(100),\n   228→            want:     decimal.Zero,\n   229→            wantErr:  true,\n   230→        },\n   231→    }\n   232→\n   233→    for _, tt := range tests {\n   234→        t.Run(tt.name, func(t *testing.T) {\n   235→            got, err := CalculatePositionSize(tt.balance, tt.risk, tt.stopLoss)\n   236→            if (err != nil) != tt.wantErr {\n   237→                t.Errorf(\"error = %v, wantErr %v\", err, tt.wantErr)\n   238→                return\n   239→            }\n   240→            if !got.Equal(tt.want) {\n   241→                t.Errorf(\"got = %v, want %v\", got, tt.want)\n   242→            }\n   243→        })\n   244→    }\n   245→}\n   246→```\n   247→\n   248→### Test Naming\n   249→\n   250→```go\n   251→// Test function names should describe what is being tested\n   252→func TestCalculatePositionSize_WithValidInputs(t *testing.T)\n   253→func TestCalculatePositionSize_WithNegativeBalance(t *testing.T)\n   254→func TestCalculatePositionSize_WithZeroStopLoss(t *testing.T)\n   255→```\n   256→\n   257→## Package Design\n   258→\n   259→### Package Names\n   260→\n   261→- Use singular, lowercase names: `order` not `orders`\n   262→- Avoid generic names like `util`, `common`, `helpers`\n   263→- Package name should describe its purpose\n   264→\n   265→### Package Organization\n   266→\n   267→```\n   268→internal/\n   269→├── trading/          # Domain logic\n   270→│   ├── order.go     # Core types\n   271→│   ├── engine.go    # Business logic\n   272→│   └── order_test.go # Tests next to code\n   273→├── api/             # External integrations\n   274→└── models/          # Data models\n   275→```\n   276→\n   277→## Comments and Documentation\n   278→\n   279→### Package Comments\n   280→\n   281→Every package should have a package comment:\n   282→\n   283→```go\n   284→// Package trading implements the core trading engine.\n   285→// It provides order execution, position management, and risk controls.\n   286→package trading\n   287→```\n   288→\n   289→### Exported Functions\n   290→\n   291→Document all exported functions:\n   292→\n   293→```go\n   294→// CalculatePositionSize determines the appropriate position size based on\n   295→// account balance, risk percentage, and stop loss distance.\n   296→// It returns an error if any input is invalid (negative or zero).\n   297→func CalculatePositionSize(balance, riskPct, stopLoss decimal.Decimal) (decimal.Decimal, error) {\n   298→    // Implementation\n   299→}\n   300→```\n   301→\n   302→## Performance\n   303→\n   304→### Preallocate Slices\n   305→\n   306→When size is known, preallocate:\n   307→\n   308→```go\n   309→// ❌ BAD: Growing slice\n   310→var results []Result\n   311→for _, item := range items {\n   312→    results = append(results, process(item))\n   313→}\n   314→\n   315→// ✅ GOOD: Preallocated\n   316→results := make([]Result, 0, len(items))\n   317→for _, item := range items {\n   318→    results = append(results, process(item))\n   319→}\n   320→```\n   321→\n   322→### String Building\n   323→\n   324→Use strings.Builder for concatenation:\n   325→\n   326→```go\n   327→// ❌ BAD: String concatenation in loop\n   328→var result string\n   329→for _, s := range strings {\n   330→    result += s\n   331→}\n   332→\n   333→// ✅ GOOD: strings.Builder\n   334→var builder strings.Builder\n   335→for _, s := range strings {\n   336→    builder.WriteString(s)\n   337→}\n   338→result := builder.String()\n   339→```\n   340→\n   341→## Common Pitfalls\n   342→\n   343→### Range Variable Capture\n   344→\n   345→```go\n   346→// ❌ BAD: Captures loop variable\n   347→for _, item := range items {\n   348→    go func() {\n   349→        process(item) // Bug: all goroutines get last item\n   350→    }()\n   351→}\n   352→\n   353→// ✅ GOOD: Copy variable\n   354→for _, item := range items {\n   355→    itemCopy := item\n   356→    go func() {\n   357→        process(itemCopy)\n   358→    }()\n   359→}\n   360→```\n   361→\n   362→### Nil Interface Values\n   363→\n   364→```go\n   365→// ❌ BAD: Can cause nil pointer panic\n   366→var err *MyError\n   367→if condition {\n   368→    err = &MyError{\"something went wrong\"}\n   369→}\n   370→return err // Returns non-nil interface with nil value\n   371→\n   372→// ✅ GOOD: Return explicit nil\n   373→if condition {\n   374→    return &MyError{\"something went wrong\"}\n   375→}\n   376→return nil\n   377→```\n   378→\n   379→### Logger and Error Framework\n   380→```go\n   381→// Initialize logger at application start\n   382→func main() {\n   383→    if err := logger.InitZap(os.Getenv(\"LOG_LEVEL\"), os.Getenv(\"BIGMEANIE_DEV\") == \"true\"); err != nil {\n   384→        panic(fmt.Sprintf(\"failed to initialize logger: %v\", err))\n   385→    }\n   386→    defer logger.Sync() // Flush any buffered logs on exit\n   387→\n   388→    // Component-specific loggers\n   389→    log := logger.Component(\"main\")\n   390→    log.Info(\"Starting BigMeanie trading system\")\n   391→}\n   392→\n   393→// Structured error handling\n   394→func LoadCandles(symbol string, timeframe string) ([]Candle, error) {\n   395→    log := logger.Data()\n   396→\n   397→    candles, err := db.Query(\"SELECT * FROM candles WHERE symbol = ? AND timeframe = ?\", symbol, timeframe)\n   398→    if err != nil {\n   399→        return nil, errors.Wrap(\"LoadCandles\", errors.ErrTypeData, err).\n   400→            WithSymbol(symbol).\n   401→            WithContext(\"timeframe\", timeframe)\n   402→    }\n   403→\n   404→    log.LogDataOperation(\"candles_loaded\", len(candles),\n   405→        \"symbol\", symbol,\n   406→        \"timeframe\", timeframe)\n   407→\n   408→    return candles, nil\n   409→}\n   410→```\n   411→\n   412→### Worker Pool Pattern\n   413→```go\n   414→// Go way: channels ARE the queue\n   415→func RunWorkerPool(ctx context.Context, numWorkers int) {\n   416→    jobs := make(chan Job, 100)\n   417→    results := make(chan Result, 100)\n   418→\n   419→    // Start workers\n   420→    var wg sync.WaitGroup\n   421→    for i := 0; i < numWorkers; i++ {\n   422→        wg.Add(1)\n   423→        go func(id int) {\n   424→            defer wg.Done()\n   425→            runWorker(ctx, id, jobs, results)\n   426→        }(i)\n   427→    }\n   428→\n   429→    // Feed jobs\n   430→    go func() {\n   431→        for _, job := range getAllJobs() {\n   432→            select {\n   433→            case jobs <- job:\n   434→            case <-ctx.Done():\n   435→                return\n   436→            }\n   437→        }\n   438→        close(jobs)\n   439→    }()\n   440→\n   441→    wg.Wait()\n   442→    close(results)\n   443→}\n   444→```\n   445→\n   446→### Options Pattern\n   447→```go\n   448→// Functional options for clean APIs\n   449→type WorkerOption func(*Worker)\n   450→\n   451→func WithRetries(max int) WorkerOption {\n   452→    return func(w *Worker) {\n   453→        w.maxRetries = max\n   454→    }\n   455→}\n   456→\n   457→func WithTimeout(d time.Duration) WorkerOption {\n   458→    return func(w *Worker) {\n   459→        w.timeout = d\n   460→    }\n   461→}\n   462→\n   463→func NewWorker(id string, opts ...WorkerOption) *Worker {\n   464→    // Defaults\n   465→    w := &Worker{\n   466→        id:         id,\n   467→        maxRetries: 3,\n   468→        timeout:    5 * time.Minute,\n   469→    }\n   470→\n   471→    // Apply options\n   472→    for _, opt := range opts {\n   473→        opt(w)\n   474→    }\n   475→\n   476→    return w\n   477→}\n   478→\n   479→// Clean usage\n   480→worker := NewWorker(\"worker-1\",\n   481→    WithRetries(5),\n   482→    WithTimeout(10*time.Minute))\n   483→```\n   484→\n   485→### Table-Driven Tests\n   486→```go\n   487→func TestParameterGeneration(t *testing.T) {\n   488→    tests := []struct {\n   489→        name     string\n   490→        strategy string\n   491→        markets  []string\n   492→        want     int\n   493→        wantErr  bool\n   494→    }{\n   495→        {\n   496→            name:     \"simple strategy\",\n   497→            strategy: \"surfer\",\n   498→            markets:  []string{\"BTC-USD\"},\n   499→            want:     10,\n   500→        },\n   501→        {\n   502→            name:     \"multiple markets\",\n   503→            strategy: \"surfer\",\n   504→            markets:  []string{\"BTC-USD\", \"ETH-USD\"},\n   505→            want:     20,\n   506→        },\n   507→        {\n   508→            name:     \"invalid strategy\",\n   509→            strategy: \"unknown\",\n   510→            wantErr:  true,\n   511→        },\n   512→    }\n   513→\n   514→    for _, tt := range tests {\n   515→        t.Run(tt.name, func(t *testing.T) {\n   516→            got, err := GenerateParameters(tt.strategy, tt.markets)\n   517→            if (err != nil) != tt.wantErr {\n   518→                t.Errorf(\"GenerateParameters() error = %v, wantErr %v\", err, tt.wantErr)\n   519→                return\n   520→            }\n   521→            if len(got) != tt.want {\n   522→                t.Errorf(\"GenerateParameters() returned %d combinations, want %d\", len(got), tt.want)\n   523→            }\n   524→        })\n   525→    }\n   526→}\n   527→```\n   528→\n   529→### Error Handling\n   530→```go\n   531→// Wrap errors with context\n   532→func processJob(job Job) (Result, error) {\n   533→    if err := validateJob(job); err != nil {\n   534→        return Result{}, fmt.Errorf(\"validation failed: %w\", err)\n   535→    }\n   536→\n   537→    data, err := fetchData(job.Symbol, job.Timeframe)\n   538→    if err != nil {\n   539→        return Result{}, fmt.Errorf(\"fetch data for %s: %w\", job.Symbol, err)\n   540→    }\n   541→\n   542→    result, err := runBacktest(data, job.Parameters)\n   543→    if err != nil {\n   544→        return Result{}, fmt.Errorf(\"backtest failed: %w\", err)\n   545→    }\n   546→\n   547→    return result, nil\n   548→}\n   549→\n   550→// Check errors immediately\n   551→if err := processJob(job); err != nil {\n   552→    log.LogError(\"Job failed\", err, \"job_id\", job.ID)\n   553→    return\n   554→}\n   555→```\n   556→\n   557→### Resource Management with Defer\n   558→```go\n   559→func (w *Worker) Execute(ctx context.Context, job Job) error {\n   560→    // Acquire resources\n   561→    conn := dbPool.Get()\n   562→    defer dbPool.Put(conn)  // Always return to pool\n   563→\n   564→    // Create checkpoint\n   565→    checkpoint := newCheckpoint(w.id)\n   566→    defer func() {\n   567→        if err := checkpoint.Save(); err != nil {\n   568→            log.LogError(\"Failed to save checkpoint\", err)\n   569→        }\n   570→    }()\n   571→\n   572→    // Do actual work\n   573→    return w.process(ctx, job)\n   574→}\n   575→```\n   576→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"06a41f28-51f1-424d-9ae4-f5a7d42011c8","timestamp":"2025-08-13T07:06:13.064Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md","content":"# Go Best Practices\n\n## Overview\n\nGo-specific best practices and patterns following Go idioms and community standards.\n\n### Core Go Principles\n- **Simplicity over abstraction** - Start simple, add complexity only when needed\n- **Channels for communication** - Don't communicate by sharing memory, share memory by communicating\n- **Errors as values** - Return errors, don't panic\n- **Small interfaces** - The bigger the interface, the weaker the abstraction\n- **Composition over inheritance** - Embed types, don't create hierarchies\n- **Context for cancellation** - Pass context.Context for cancellation and timeouts\n\n## Interface Design\n\n### Small, Focused Interfaces\n\nFollow the Go proverb: \"The bigger the interface, the weaker the abstraction.\"\n\n```go\n// ✅ GOOD: Small interfaces are easier to implement and test\ntype PriceProvider interface {\n    GetPrice(symbol string) (decimal.Decimal, error)\n}\n\ntype OrderPlacer interface {\n    PlaceOrder(order *Order) (*OrderResult, error)\n}\n\n// ❌ BAD: Large interface with many responsibilities\ntype TradingService interface {\n    GetPrice(symbol string) (decimal.Decimal, error)\n    PlaceOrder(order *Order) (*OrderResult, error)\n    CancelOrder(id string) error\n    GetOrderStatus(id string) (*OrderStatus, error)\n    GetBalance(currency string) (decimal.Decimal, error)\n    // ... 20 more methods\n}\n```\n\n## Naming Conventions\n\n### Clear Names Without Unnecessary Abbreviations\n\n```go\n// ❌ BAD: Unclear abbreviations\ncfg, mgr, svc, calc, resp, req\n\n// ✅ GOOD: Clear, full names\nconfig, manager, service, calculate, response, request\n\n// Exception: Well-known abbreviations are acceptable\nctx context.Context  // Standard Go abbreviation\ndb *sql.DB          // Widely understood\nerr error           // Go convention\n```\n\n### Function and Method Names\n\n```go\n// Function names should be self-explanatory\nfunc CalculatePositionSize(balance, riskPercentage decimal.Decimal) decimal.Decimal\n\n// Avoid redundant package names in functions\n// ❌ BAD\npackage order\nfunc OrderValidator() // order.OrderValidator is redundant\n\n// ✅ GOOD\npackage order\nfunc Validator() // order.Validator is clear\n```\n\n### Receiver Names\n\nUse single-letter receivers for methods:\n\n```go\n// ✅ GOOD: Single letter that represents the type\nfunc (s *Strategy) Analyze(data MarketData) Signal\nfunc (c *Config) Validate() error\nfunc (o *Order) Execute() error\n\n// ❌ BAD: Long receiver names\nfunc (strategy *Strategy) Analyze(data MarketData) Signal\nfunc (config *Config) Validate() error\n```\n\n## Error Handling\n\n### Always Check Errors\n\nNever ignore errors, even in deferred functions:\n\n```go\n// ❌ BAD: Ignoring error\ndefer file.Close()\n\n// ✅ GOOD: Check error even in defer\ndefer func() {\n    if err := file.Close(); err != nil {\n        log.Printf(\"failed to close file: %v\", err)\n    }\n}()\n```\n\n## Concurrency Patterns\n\n### Don't Communicate by Sharing Memory\n\nFollow Go's concurrency philosophy:\n\n```go\n// ❌ BAD: Shared memory with mutex\ntype Counter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    c.value++\n    c.mu.Unlock()\n}\n\n// ✅ GOOD: Communicate via channels\ntype Counter struct {\n    inc chan int\n    get chan int\n}\n\nfunc (c *Counter) run() {\n    value := 0\n    for {\n        select {\n        case <-c.inc:\n            value++\n        case c.get <- value:\n        }\n    }\n}\n```\n\n### Context for Cancellation\n\nAlways use context for cancellation and timeouts:\n\n```go\n// ✅ GOOD: Respecting context\nfunc FetchData(ctx context.Context, symbol string) (*Data, error) {\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n\n    resp, err := client.Do(req)\n    // ... handle response\n}\n```\n\n## Resource Management\n\n### Defer Cleanup\n\nAlways defer cleanup immediately after acquiring resources:\n\n```go\n// ✅ GOOD: Immediate defer\nfile, err := os.Open(\"data.txt\")\nif err != nil {\n    return err\n}\ndefer file.Close() // Immediately after successful open\n\n// Process file...\n```\n\n### Check Close Errors\n\nSome Close operations can fail and should be checked:\n\n```go\n// ✅ GOOD: Check close error for writers\nfunc WriteData(filename string, data []byte) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if cerr := file.Close(); cerr != nil && err == nil {\n            err = cerr // Capture close error if no other error\n        }\n    }()\n\n    _, err = file.Write(data)\n    return err\n}\n```\n\n## Testing\n\n### Table-Driven Tests\n\n```go\nfunc TestCalculatePositionSize(t *testing.T) {\n    tests := []struct {\n        name     string\n        balance  decimal.Decimal\n        risk     decimal.Decimal\n        stopLoss decimal.Decimal\n        want     decimal.Decimal\n        wantErr  bool\n    }{\n        {\n            name:     \"valid inputs\",\n            balance:  decimal.NewFromInt(10000),\n            risk:     decimal.NewFromFloat(0.02),\n            stopLoss: decimal.NewFromInt(100),\n            want:     decimal.NewFromInt(200),\n            wantErr:  false,\n        },\n        {\n            name:     \"negative balance\",\n            balance:  decimal.NewFromInt(-1000),\n            risk:     decimal.NewFromFloat(0.02),\n            stopLoss: decimal.NewFromInt(100),\n            want:     decimal.Zero,\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := CalculatePositionSize(tt.balance, tt.risk, tt.stopLoss)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if !got.Equal(tt.want) {\n                t.Errorf(\"got = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\n### Test Naming\n\n```go\n// Test function names should describe what is being tested\nfunc TestCalculatePositionSize_WithValidInputs(t *testing.T)\nfunc TestCalculatePositionSize_WithNegativeBalance(t *testing.T)\nfunc TestCalculatePositionSize_WithZeroStopLoss(t *testing.T)\n```\n\n## Package Design\n\n### Package Names\n\n- Use singular, lowercase names: `order` not `orders`\n- Avoid generic names like `util`, `common`, `helpers`\n- Package name should describe its purpose\n\n### Package Organization\n\n```\ninternal/\n├── trading/          # Domain logic\n│   ├── order.go     # Core types\n│   ├── engine.go    # Business logic\n│   └── order_test.go # Tests next to code\n├── api/             # External integrations\n└── models/          # Data models\n```\n\n## Comments and Documentation\n\n### Package Comments\n\nEvery package should have a package comment:\n\n```go\n// Package trading implements the core trading engine.\n// It provides order execution, position management, and risk controls.\npackage trading\n```\n\n### Exported Functions\n\nDocument all exported functions:\n\n```go\n// CalculatePositionSize determines the appropriate position size based on\n// account balance, risk percentage, and stop loss distance.\n// It returns an error if any input is invalid (negative or zero).\nfunc CalculatePositionSize(balance, riskPct, stopLoss decimal.Decimal) (decimal.Decimal, error) {\n    // Implementation\n}\n```\n\n## Performance\n\n### Preallocate Slices\n\nWhen size is known, preallocate:\n\n```go\n// ❌ BAD: Growing slice\nvar results []Result\nfor _, item := range items {\n    results = append(results, process(item))\n}\n\n// ✅ GOOD: Preallocated\nresults := make([]Result, 0, len(items))\nfor _, item := range items {\n    results = append(results, process(item))\n}\n```\n\n### String Building\n\nUse strings.Builder for concatenation:\n\n```go\n// ❌ BAD: String concatenation in loop\nvar result string\nfor _, s := range strings {\n    result += s\n}\n\n// ✅ GOOD: strings.Builder\nvar builder strings.Builder\nfor _, s := range strings {\n    builder.WriteString(s)\n}\nresult := builder.String()\n```\n\n## Common Pitfalls\n\n### Range Variable Capture\n\n```go\n// ❌ BAD: Captures loop variable\nfor _, item := range items {\n    go func() {\n        process(item) // Bug: all goroutines get last item\n    }()\n}\n\n// ✅ GOOD: Copy variable\nfor _, item := range items {\n    itemCopy := item\n    go func() {\n        process(itemCopy)\n    }()\n}\n```\n\n### Nil Interface Values\n\n```go\n// ❌ BAD: Can cause nil pointer panic\nvar err *MyError\nif condition {\n    err = &MyError{\"something went wrong\"}\n}\nreturn err // Returns non-nil interface with nil value\n\n// ✅ GOOD: Return explicit nil\nif condition {\n    return &MyError{\"something went wrong\"}\n}\nreturn nil\n```\n\n### Logger and Error Framework\n```go\n// Initialize logger at application start\nfunc main() {\n    if err := logger.InitZap(os.Getenv(\"LOG_LEVEL\"), os.Getenv(\"BIGMEANIE_DEV\") == \"true\"); err != nil {\n        panic(fmt.Sprintf(\"failed to initialize logger: %v\", err))\n    }\n    defer logger.Sync() // Flush any buffered logs on exit\n\n    // Component-specific loggers\n    log := logger.Component(\"main\")\n    log.Info(\"Starting BigMeanie trading system\")\n}\n\n// Structured error handling\nfunc LoadCandles(symbol string, timeframe string) ([]Candle, error) {\n    log := logger.Data()\n\n    candles, err := db.Query(\"SELECT * FROM candles WHERE symbol = ? AND timeframe = ?\", symbol, timeframe)\n    if err != nil {\n        return nil, errors.Wrap(\"LoadCandles\", errors.ErrTypeData, err).\n            WithSymbol(symbol).\n            WithContext(\"timeframe\", timeframe)\n    }\n\n    log.LogDataOperation(\"candles_loaded\", len(candles),\n        \"symbol\", symbol,\n        \"timeframe\", timeframe)\n\n    return candles, nil\n}\n```\n\n### Worker Pool Pattern\n```go\n// Go way: channels ARE the queue\nfunc RunWorkerPool(ctx context.Context, numWorkers int) {\n    jobs := make(chan Job, 100)\n    results := make(chan Result, 100)\n\n    // Start workers\n    var wg sync.WaitGroup\n    for i := 0; i < numWorkers; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            runWorker(ctx, id, jobs, results)\n        }(i)\n    }\n\n    // Feed jobs\n    go func() {\n        for _, job := range getAllJobs() {\n            select {\n            case jobs <- job:\n            case <-ctx.Done():\n                return\n            }\n        }\n        close(jobs)\n    }()\n\n    wg.Wait()\n    close(results)\n}\n```\n\n### Options Pattern\n```go\n// Functional options for clean APIs\ntype WorkerOption func(*Worker)\n\nfunc WithRetries(max int) WorkerOption {\n    return func(w *Worker) {\n        w.maxRetries = max\n    }\n}\n\nfunc WithTimeout(d time.Duration) WorkerOption {\n    return func(w *Worker) {\n        w.timeout = d\n    }\n}\n\nfunc NewWorker(id string, opts ...WorkerOption) *Worker {\n    // Defaults\n    w := &Worker{\n        id:         id,\n        maxRetries: 3,\n        timeout:    5 * time.Minute,\n    }\n\n    // Apply options\n    for _, opt := range opts {\n        opt(w)\n    }\n\n    return w\n}\n\n// Clean usage\nworker := NewWorker(\"worker-1\",\n    WithRetries(5),\n    WithTimeout(10*time.Minute))\n```\n\n### Table-Driven Tests\n```go\nfunc TestParameterGeneration(t *testing.T) {\n    tests := []struct {\n        name     string\n        strategy string\n        markets  []string\n        want     int\n        wantErr  bool\n    }{\n        {\n            name:     \"simple strategy\",\n            strategy: \"surfer\",\n            markets:  []string{\"BTC-USD\"},\n            want:     10,\n        },\n        {\n            name:     \"multiple markets\",\n            strategy: \"surfer\",\n            markets:  []string{\"BTC-USD\", \"ETH-USD\"},\n            want:     20,\n        },\n        {\n            name:     \"invalid strategy\",\n            strategy: \"unknown\",\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := GenerateParameters(tt.strategy, tt.markets)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"GenerateParameters() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if len(got) != tt.want {\n                t.Errorf(\"GenerateParameters() returned %d combinations, want %d\", len(got), tt.want)\n            }\n        })\n    }\n}\n```\n\n### Error Handling\n```go\n// Wrap errors with context\nfunc processJob(job Job) (Result, error) {\n    if err := validateJob(job); err != nil {\n        return Result{}, fmt.Errorf(\"validation failed: %w\", err)\n    }\n\n    data, err := fetchData(job.Symbol, job.Timeframe)\n    if err != nil {\n        return Result{}, fmt.Errorf(\"fetch data for %s: %w\", job.Symbol, err)\n    }\n\n    result, err := runBacktest(data, job.Parameters)\n    if err != nil {\n        return Result{}, fmt.Errorf(\"backtest failed: %w\", err)\n    }\n\n    return result, nil\n}\n\n// Check errors immediately\nif err := processJob(job); err != nil {\n    log.LogError(\"Job failed\", err, \"job_id\", job.ID)\n    return\n}\n```\n\n### Resource Management with Defer\n```go\nfunc (w *Worker) Execute(ctx context.Context, job Job) error {\n    // Acquire resources\n    conn := dbPool.Get()\n    defer dbPool.Put(conn)  // Always return to pool\n\n    // Create checkpoint\n    checkpoint := newCheckpoint(w.id)\n    defer func() {\n        if err := checkpoint.Save(); err != nil {\n            log.LogError(\"Failed to save checkpoint\", err)\n        }\n    }()\n\n    // Do actual work\n    return w.process(ctx, job)\n}\n```\n","numLines":576,"startLine":1,"totalLines":576}}}
{"parentUuid":"06a41f28-51f1-424d-9ae4-f5a7d42011c8","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01WCffqvjgBJnpxe42xVApnU","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now I'll create the comprehensive Go documentation files. I'll output each one to the terminal as I create them.\n\n## 1. Go Fundamentals"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5941,"cache_read_input_tokens":32283,"output_tokens":8249,"service_tier":"standard"}},"requestId":"req_011CS5HWAp3fRVXUcEMRvfTw","type":"assistant","uuid":"a22108f3-5dca-4e4c-af11-9b99c6e4cd81","timestamp":"2025-08-13T07:06:17.215Z"}
{"parentUuid":"a22108f3-5dca-4e4c-af11-9b99c6e4cd81","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01WCffqvjgBJnpxe42xVApnU","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01BuDg7bEBjZbU19EXrBwfzz","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md","content":"# Go Fundamentals - Complete Language Reference\n\n## Table of Contents\n1. [Basic Syntax](#basic-syntax)\n2. [Types and Variables](#types-and-variables)\n3. [Control Flow](#control-flow)\n4. [Functions](#functions)\n5. [Methods](#methods)\n6. [Structs](#structs)\n7. [Interfaces](#interfaces)\n8. [Error Handling Basics](#error-handling-basics)\n9. [Pointers](#pointers)\n10. [Arrays and Slices](#arrays-and-slices)\n11. [Maps](#maps)\n12. [Type Assertions and Type Switches](#type-assertions-and-type-switches)\n\n## Basic Syntax\n\n### Package Declaration\nEvery Go file starts with a package declaration:\n\n```go\npackage main  // Executable programs use package main\npackage trading  // Library packages use lowercase names\n```\n\n### Import Statements\n```go\nimport \"fmt\"  // Single import\n\n// Multiple imports (preferred style)\nimport (\n    \"fmt\"\n    \"strings\"\n    \"time\"\n    \n    // Third-party packages\n    \"github.com/shopspring/decimal\"\n    \n    // Internal packages\n    \"myproject/internal/trading\"\n)\n\n// Aliased imports\nimport (\n    stdlog \"log\"  // Alias to avoid naming conflicts\n    _ \"github.com/lib/pq\"  // Import for side effects only\n    . \"math\"  // Dot import (use sparingly)\n)\n```\n\n### Comments\n```go\n// Single-line comment\n\n/*\nMulti-line comment\nUsed for longer explanations\n*/\n\n// Package comments precede package declaration\n// Package trading provides core trading functionality.\npackage trading\n\n// Function comments precede the function\n// CalculateProfit returns the profit from a trade.\nfunc CalculateProfit(entry, exit decimal.Decimal) decimal.Decimal {\n    return exit.Sub(entry)\n}\n```\n\n## Types and Variables\n\n### Basic Types\n```go\n// Boolean\nvar isActive bool = true\nvar isEnabled = false  // Type inference\n\n// Numeric Types\nvar count int = 42        // Platform-dependent size (32 or 64 bits)\nvar port int64 = 8080     // Explicit 64-bit integer\nvar smallNum int8 = 127   // 8-bit integer (-128 to 127)\nvar byteVal byte = 255    // Alias for uint8\nvar runeVal rune = 'A'    // Alias for int32, represents Unicode code point\n\n// Floating-point\nvar price float64 = 99.99\nvar rate float32 = 0.05\n\n// Complex numbers\nvar c complex128 = 1 + 2i\nvar c64 complex64 = complex(1, 2)\n\n// String\nvar message string = \"Hello, Go!\"\nvar multiline = `This is a\nmulti-line string\nwith backticks`\n```\n\n### Variable Declaration\n```go\n// var keyword with type\nvar x int\nvar y int = 10\n\n// var with type inference\nvar z = 20  // int inferred\n\n// Short declaration (only inside functions)\nw := 30  // Same as: var w = 30\n\n// Multiple variables\nvar a, b, c int\nvar d, e = 1, \"hello\"\nf, g := true, 3.14\n\n// Grouped declaration\nvar (\n    name   string = \"Alice\"\n    age    int    = 30\n    active bool   = true\n)\n\n// Constants\nconst pi = 3.14159\nconst (\n    StatusOK    = 200\n    StatusError = 500\n)\n\n// Typed constants\nconst typedConst int64 = 1234\n\n// iota for enumerations\nconst (\n    Sunday = iota  // 0\n    Monday         // 1\n    Tuesday        // 2\n    Wednesday      // 3\n)\n\n// Complex iota usage\nconst (\n    _  = iota             // Skip 0\n    KB = 1 << (10 * iota) // 1024\n    MB                    // 1048576\n    GB                    // 1073741824\n)\n```\n\n### Zero Values\n```go\nvar i int        // 0\nvar f float64    // 0.0\nvar b bool       // false\nvar s string     // \"\"\nvar p *int       // nil\nvar a []int      // nil\nvar m map[string]int  // nil\nvar ch chan int  // nil\nvar fn func()    // nil\nvar inf interface{}  // nil\n```\n\n### Type Conversions\n```go\n// Explicit conversion required\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(i)\n\n// String conversions\nvar s string = string(65)  // \"A\" (from ASCII/Unicode)\nvar bytes = []byte(\"hello\")  // String to byte slice\nvar str = string(bytes)      // Byte slice to string\n\n// Numeric parsing\nimport \"strconv\"\ni, err := strconv.Atoi(\"123\")  // String to int\ns := strconv.Itoa(123)          // Int to string\nf, err := strconv.ParseFloat(\"3.14\", 64)  // String to float64\n```\n\n## Control Flow\n\n### If Statements\n```go\n// Basic if\nif x > 0 {\n    fmt.Println(\"Positive\")\n}\n\n// If-else\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else if x < 0 {\n    fmt.Println(\"Negative\")\n} else {\n    fmt.Println(\"Zero\")\n}\n\n// If with initialization\nif err := doSomething(); err != nil {\n    return err  // err is scoped to if block\n}\n\n// Common patterns\nif val, ok := m[key]; ok {\n    // Use val - key exists in map\n}\n\nif v, err := getValue(); err == nil {\n    // Use v - no error occurred\n}\n```\n\n### For Loops\n```go\n// Traditional for loop\nfor i := 0; i < 10; i++ {\n    fmt.Println(i)\n}\n\n// While-style loop\ni := 0\nfor i < 10 {\n    fmt.Println(i)\n    i++\n}\n\n// Infinite loop\nfor {\n    // Break or return to exit\n    if condition {\n        break\n    }\n}\n\n// Range over slice/array\nnumbers := []int{1, 2, 3, 4, 5}\nfor index, value := range numbers {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n\n// Ignore index with blank identifier\nfor _, value := range numbers {\n    fmt.Println(value)\n}\n\n// Range over map\nm := map[string]int{\"a\": 1, \"b\": 2}\nfor key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Range over string (iterates over runes)\nfor index, runeValue := range \"Hello, 世界\" {\n    fmt.Printf(\"%d: %c\\n\", index, runeValue)\n}\n\n// Range over channel\nfor msg := range ch {\n    fmt.Println(msg)  // Receives until channel is closed\n}\n\n// Continue and break with labels\nouter:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        if i == j {\n            continue outer  // Continue outer loop\n        }\n        if i+j > 3 {\n            break outer  // Break from outer loop\n        }\n    }\n}\n```\n\n### Switch Statements\n```go\n// Basic switch\nswitch day {\ncase \"Monday\":\n    fmt.Println(\"Start of work week\")\ncase \"Friday\":\n    fmt.Println(\"TGIF\")\ncase \"Saturday\", \"Sunday\":  // Multiple cases\n    fmt.Println(\"Weekend!\")\ndefault:\n    fmt.Println(\"Midweek\")\n}\n\n// Switch with initialization\nswitch hour := time.Now().Hour(); {\ncase hour < 12:\n    fmt.Println(\"Morning\")\ncase hour < 18:\n    fmt.Println(\"Afternoon\")\ndefault:\n    fmt.Println(\"Evening\")\n}\n\n// Switch without expression (replaces if-else chains)\nswitch {\ncase x < 0:\n    fmt.Println(\"Negative\")\ncase x == 0:\n    fmt.Println(\"Zero\")\ncase x > 0:\n    fmt.Println(\"Positive\")\n}\n\n// Fallthrough (rarely used)\nswitch n {\ncase 0:\n    fmt.Println(\"Zero\")\n    fallthrough  // Continue to next case\ncase 1:\n    fmt.Println(\"One or fallthrough from Zero\")\n}\n\n// Type switch (covered in detail later)\nswitch v := x.(type) {\ncase int:\n    fmt.Printf(\"Integer: %d\\n\", v)\ncase string:\n    fmt.Printf(\"String: %s\\n\", v)\ndefault:\n    fmt.Printf(\"Unknown type: %T\\n\", v)\n}\n```\n\n### Defer, Panic, and Recover\n```go\n// Defer - executes at function exit (LIFO order)\nfunc readFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()  // Ensures file is closed\n    \n    // Read file...\n    return nil\n}\n\n// Multiple defers execute in reverse order\nfunc example() {\n    defer fmt.Println(\"Third\")\n    defer fmt.Println(\"Second\")\n    defer fmt.Println(\"First\")\n    // Prints: First, Second, Third\n}\n\n// Defer with function values\nfunc measure(name string) func() {\n    start := time.Now()\n    return func() {\n        fmt.Printf(\"%s took %v\\n\", name, time.Since(start))\n    }\n}\n\nfunc slowOperation() {\n    defer measure(\"slowOperation\")()  // Note the extra ()\n    time.Sleep(1 * time.Second)\n}\n\n// Panic - for unrecoverable errors\nfunc mustNotBeZero(x int) {\n    if x == 0 {\n        panic(\"x cannot be zero\")\n    }\n}\n\n// Recover - catch panics\nfunc safeExecute(fn func()) (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    fn()  // May panic\n    return nil\n}\n```\n\n## Functions\n\n### Function Declaration\n```go\n// Basic function\nfunc add(x int, y int) int {\n    return x + y\n}\n\n// Shortened parameter types\nfunc add2(x, y int) int {  // Both x and y are int\n    return x + y\n}\n\n// Multiple return values\nfunc divide(x, y float64) (float64, error) {\n    if y == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return x / y, nil\n}\n\n// Named return values\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return  // Naked return (use sparingly)\n}\n\n// Variadic functions\nfunc sum(nums ...int) int {\n    total := 0\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n\n// Call variadic function\nresult := sum(1, 2, 3, 4, 5)\nnumbers := []int{1, 2, 3}\nresult2 := sum(numbers...)  // Spread slice\n```\n\n### Function Types and Values\n```go\n// Function as type\ntype Calculator func(int, int) int\n\n// Function as variable\nvar operation Calculator = add\n\n// Anonymous functions\nmultiply := func(x, y int) int {\n    return x * y\n}\n\n// Immediately invoked function\nresult := func(x, y int) int {\n    return x + y\n}(5, 3)\n\n// Functions as parameters\nfunc apply(fn func(int, int) int, x, y int) int {\n    return fn(x, y)\n}\n\nresult := apply(add, 10, 5)\n\n// Functions returning functions\nfunc makeAdder(x int) func(int) int {\n    return func(y int) int {\n        return x + y  // Closure captures x\n    }\n}\n\nadd5 := makeAdder(5)\nresult := add5(3)  // 8\n```\n\n### Closures\n```go\n// Closure captures variables from outer scope\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nc := counter()\nfmt.Println(c())  // 1\nfmt.Println(c())  // 2\nfmt.Println(c())  // 3\n\n// Common pitfall with closures in loops\n// BAD:\nvar funcs []func()\nfor i := 0; i < 3; i++ {\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // Captures loop variable\n    })\n}\n// All functions print 3\n\n// GOOD:\nfor i := 0; i < 3; i++ {\n    i := i  // Create new variable\n    funcs = append(funcs, func() {\n        fmt.Println(i)\n    })\n}\n// Functions print 0, 1, 2\n```\n\n## Methods\n\n### Method Declaration\n```go\n// Methods are functions with a receiver\ntype Point struct {\n    X, Y float64\n}\n\n// Value receiver\nfunc (p Point) Distance() float64 {\n    return math.Sqrt(p.X*p.X + p.Y*p.Y)\n}\n\n// Pointer receiver (can modify the receiver)\nfunc (p *Point) Scale(factor float64) {\n    p.X *= factor\n    p.Y *= factor\n}\n\n// Using methods\np := Point{3, 4}\nfmt.Println(p.Distance())  // 5\np.Scale(2)  // p is now {6, 8}\n\n// Methods on non-struct types\ntype MyInt int\n\nfunc (i MyInt) IsPositive() bool {\n    return i > 0\n}\n\nvar num MyInt = 10\nfmt.Println(num.IsPositive())  // true\n```\n\n### Value vs Pointer Receivers\n```go\n// Guidelines for choosing receiver type:\n\n// Use pointer receiver when:\n// 1. Method needs to modify the receiver\nfunc (u *User) SetName(name string) {\n    u.Name = name\n}\n\n// 2. Struct is large (avoid copying)\nfunc (d *LargeData) Process() {\n    // Processing large struct\n}\n\n// 3. Consistency - if one method needs pointer, use for all\ntype Account struct {\n    balance decimal.Decimal\n}\n\nfunc (a *Account) Deposit(amount decimal.Decimal) {\n    a.balance = a.balance.Add(amount)\n}\n\nfunc (a *Account) Balance() decimal.Decimal {\n    return a.balance  // Pointer receiver for consistency\n}\n\n// Use value receiver when:\n// 1. Method doesn't modify receiver\n// 2. Type is small and copying is cheap\n// 3. You want immutability\nfunc (p Point) DistanceTo(other Point) float64 {\n    dx := p.X - other.X\n    dy := p.Y - other.Y\n    return math.Sqrt(dx*dx + dy*dy)\n}\n```\n\n## Structs\n\n### Struct Declaration and Usage\n```go\n// Basic struct\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// Creating structs\np1 := Person{Name: \"Alice\", Age: 30}\np2 := Person{\"Bob\", 25}  // Positional (not recommended)\np3 := Person{Name: \"Charlie\"}  // Partial initialization\nvar p4 Person  // Zero value\n\n// Accessing fields\nfmt.Println(p1.Name)\np1.Age = 31\n\n// Struct pointers\nptr := &Person{Name: \"Dave\", Age: 40}\nptr.Age = 41  // Same as (*ptr).Age = 41\n\n// Anonymous structs\npoint := struct {\n    X, Y int\n}{10, 20}\n\n// Struct tags\ntype User struct {\n    ID       int    `json:\"id\" db:\"user_id\"`\n    Username string `json:\"username\" db:\"user_name\"`\n    Password string `json:\"-\"` // Omit from JSON\n    Admin    bool   `json:\"is_admin,omitempty\"`\n}\n\n// Accessing tags via reflection\nimport \"reflect\"\nt := reflect.TypeOf(User{})\nfield, _ := t.FieldByName(\"ID\")\nfmt.Println(field.Tag.Get(\"json\"))  // \"id\"\n\n// Embedded structs (composition)\ntype Employee struct {\n    Person  // Embedded\n    ID      int\n    Manager *Employee\n}\n\nemp := Employee{\n    Person: Person{Name: \"Eve\", Age: 28},\n    ID:     12345,\n}\nfmt.Println(emp.Name)  // Promoted field\n\n// Field alignment and memory optimization\n// Bad: 24 bytes on 64-bit systems\ntype Inefficient struct {\n    a bool   // 1 byte + 7 padding\n    b int64  // 8 bytes\n    c bool   // 1 byte + 7 padding\n}\n\n// Good: 16 bytes on 64-bit systems\ntype Efficient struct {\n    b int64  // 8 bytes\n    a bool   // 1 byte\n    c bool   // 1 byte + 6 padding\n}\n```\n\n### Struct Methods and Composition\n```go\n// Composition for code reuse\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\n// Composed interface\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\n// Struct embedding for composition\ntype Base struct {\n    ID   int\n    Name string\n}\n\nfunc (b *Base) SetName(name string) {\n    b.Name = name\n}\n\ntype Derived struct {\n    Base  // Embed Base\n    Extra string\n}\n\nd := Derived{\n    Base:  Base{ID: 1, Name: \"Test\"},\n    Extra: \"additional\",\n}\nd.SetName(\"New Name\")  // Call Base method\n```\n\n## Interfaces\n\n### Interface Declaration and Implementation\n```go\n// Interface definition\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\n// Implementation is implicit\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n    return 2 * (r.Width + r.Height)\n}\n\n// Rectangle implements Shape implicitly\nvar s Shape = Rectangle{Width: 10, Height: 5}\n\n// Empty interface (accepts any type)\nvar anything interface{}\nanything = 42\nanything = \"hello\"\nanything = Rectangle{10, 5}\n\n// Interface satisfaction\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\n// Any type with Write method satisfies Writer\ntype File struct{}\nfunc (f *File) Write(data []byte) (int, error) {\n    return len(data), nil\n}\n\nvar w Writer = &File{}  // Note: pointer type\n\n// Interface values\ntype Stringer interface {\n    String() string\n}\n\ntype Person struct {\n    Name string\n}\n\nfunc (p Person) String() string {\n    return p.Name\n}\n\nvar s Stringer = Person{\"Alice\"}\n// Interface value has (value, type) = (Person{\"Alice\"}, Person)\n\n// Nil interface gotcha\nvar p *Person = nil\nvar s Stringer = p  // s is not nil!\nif s == nil {\n    // This won't execute\n}\n// s has (value, type) = (nil, *Person)\n```\n\n### Common Interface Patterns\n```go\n// Small interfaces (Go philosophy)\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Composed interfaces\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Accept interfaces, return structs\nfunc process(r Reader) error {\n    // Accept any Reader\n    data := make([]byte, 1024)\n    _, err := r.Read(data)\n    return err\n}\n\nfunc newBuffer() *bytes.Buffer {\n    // Return concrete type\n    return &bytes.Buffer{}\n}\n\n// Interface guards (compile-time check)\nvar _ Shape = (*Rectangle)(nil)  // Ensures Rectangle implements Shape\nvar _ Shape = Rectangle{}        // Alternative syntax\n```\n\n## Error Handling Basics\n\n### Error Interface\n```go\n// Error is a built-in interface\ntype error interface {\n    Error() string\n}\n\n// Creating errors\nimport \"errors\"\nerr := errors.New(\"something went wrong\")\n\n// Formatted errors\nerr := fmt.Errorf(\"failed to process %s: %v\", filename, originalErr)\n\n// Custom error types\ntype ValidationError struct {\n    Field string\n    Value interface{}\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for field %s: invalid value %v\", \n        e.Field, e.Value)\n}\n\n// Returning errors\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// Checking errors\nresult, err := divide(10, 0)\nif err != nil {\n    log.Printf(\"Error: %v\", err)\n    return err\n}\n\n// Error wrapping (Go 1.13+)\nerr := doSomething()\nif err != nil {\n    return fmt.Errorf(\"operation failed: %w\", err)\n}\n\n// Error unwrapping\nvar pathError *os.PathError\nif errors.As(err, &pathError) {\n    fmt.Printf(\"Path error: %s\\n\", pathError.Path)\n}\n\n// Checking error types\nif errors.Is(err, os.ErrNotExist) {\n    // Handle file not found\n}\n\n// Sentinel errors\nvar (\n    ErrNotFound = errors.New(\"not found\")\n    ErrInvalid  = errors.New(\"invalid input\")\n)\n\n// Multiple error handling patterns\n// Pattern 1: Return immediately\nif err := step1(); err != nil {\n    return fmt.Errorf(\"step1 failed: %w\", err)\n}\n\n// Pattern 2: Accumulate errors\nvar errs []error\nif err := step1(); err != nil {\n    errs = append(errs, err)\n}\nif err := step2(); err != nil {\n    errs = append(errs, err)\n}\nif len(errs) > 0 {\n    return fmt.Errorf(\"multiple errors: %v\", errs)\n}\n```\n\n## Pointers\n\n### Pointer Basics\n```go\n// Pointer declaration\nvar p *int  // Pointer to int\n\n// Address operator &\nx := 42\np = &x  // p points to x\n\n// Dereference operator *\nfmt.Println(*p)  // 42\n*p = 100  // x is now 100\n\n// Pointer zero value is nil\nvar ptr *string\nif ptr == nil {\n    fmt.Println(\"Pointer is nil\")\n}\n\n// Allocating memory\np1 := new(int)  // Allocates zeroed int, returns *int\n*p1 = 42\n\n// Pointers to structs\ntype Person struct {\n    Name string\n    Age  int\n}\n\nperson := &Person{Name: \"Alice\", Age: 30}\nperson.Age = 31  // Automatic dereferencing\n\n// Pointer receivers\nfunc (p *Person) Birthday() {\n    p.Age++  // Modifies the original\n}\n\n// When to use pointers:\n// 1. Large structs (avoid copying)\n// 2. Need to modify the original\n// 3. Optional values (nil represents absence)\n// 4. Implementing interfaces with pointer receivers\n```\n\n## Arrays and Slices\n\n### Arrays\n```go\n// Arrays have fixed size\nvar arr [5]int  // Array of 5 ints\narr[0] = 10\narr[4] = 50\n\n// Array literals\nprimes := [5]int{2, 3, 5, 7, 11}\npartial := [5]int{1, 2}  // Rest are zeros\n\n// Size inference\nauto := [...]int{1, 2, 3, 4, 5}  // Size 5\n\n// Arrays are values (copied on assignment)\narr2 := arr  // Full copy\narr2[0] = 100  // Doesn't affect arr\n\n// Multidimensional arrays\nvar matrix [3][3]int\nmatrix[1][1] = 5\n```\n\n### Slices\n```go\n// Slices are dynamic references to arrays\nvar slice []int  // nil slice\n\n// Creating slices\nslice1 := []int{1, 2, 3, 4, 5}  // Slice literal\nslice2 := make([]int, 5)        // Length 5, capacity 5\nslice3 := make([]int, 5, 10)    // Length 5, capacity 10\n\n// Slicing operations\narr := [5]int{1, 2, 3, 4, 5}\ns1 := arr[1:4]  // [2, 3, 4]\ns2 := arr[:3]   // [1, 2, 3]\ns3 := arr[2:]   // [3, 4, 5]\ns4 := arr[:]    // [1, 2, 3, 4, 5]\n\n// Slice properties\nfmt.Println(len(s1))  // 3\nfmt.Println(cap(s1))  // 4 (capacity from underlying array)\n\n// Appending to slices\nslice = append(slice, 6)\nslice = append(slice, 7, 8, 9)\nslice = append(slice, anotherSlice...)\n\n// Copy slices\nsrc := []int{1, 2, 3}\ndst := make([]int, len(src))\ncopy(dst, src)\n\n// Slice tricks\n// Remove element at index i\nslice = append(slice[:i], slice[i+1:]...)\n\n// Insert element at index i\nslice = append(slice[:i], append([]int{x}, slice[i:]...)...)\n\n// Filter in place\nn := 0\nfor _, x := range slice {\n    if keepCondition(x) {\n        slice[n] = x\n        n++\n    }\n}\nslice = slice[:n]\n\n// Nil vs empty slice\nvar nilSlice []int      // nil\nemptySlice := []int{}   // Not nil, but empty\nemptyMake := make([]int, 0)  // Not nil, but empty\n\n// Slice internals\n// A slice is a struct with:\n// - Pointer to underlying array\n// - Length\n// - Capacity\n\n// Growing slices efficiently\n// Preallocate when size is known\nresult := make([]int, 0, expectedSize)\nfor i := 0; i < expectedSize; i++ {\n    result = append(result, process(i))\n}\n```\n\n## Maps\n\n### Map Operations\n```go\n// Map declaration\nvar m map[string]int  // nil map (read-only)\n\n// Creating maps\nm1 := make(map[string]int)\nm2 := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\n\n// Map operations\nm1[\"key\"] = 42          // Set\nvalue := m1[\"key\"]      // Get\ndelete(m1, \"key\")       // Delete\n\n// Check if key exists\nvalue, exists := m1[\"key\"]\nif exists {\n    fmt.Println(\"Value:\", value)\n}\n\n// Common pattern\nif val, ok := m[\"key\"]; ok {\n    // Use val\n}\n\n// Iterate over map\nfor key, value := range m2 {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Keys only\nfor key := range m2 {\n    fmt.Println(key)\n}\n\n// Map of slices\ngroups := make(map[string][]string)\ngroups[\"admins\"] = append(groups[\"admins\"], \"alice\")\n\n// Map of maps\nnested := make(map[string]map[string]int)\nif nested[\"outer\"] == nil {\n    nested[\"outer\"] = make(map[string]int)\n}\nnested[\"outer\"][\"inner\"] = 42\n\n// Maps are reference types\nm3 := m2  // Both reference same map\nm3[\"charlie\"] = 35  // Affects m2\n\n// Zero value for map values\ncounts := make(map[string]int)\ncounts[\"new\"]++  // Works! int zero value is 0\n\n// Map as set\nset := make(map[string]struct{})\nset[\"item\"] = struct{}{}  // Add to set\nif _, exists := set[\"item\"]; exists {\n    // Item in set\n}\ndelete(set, \"item\")  // Remove from set\n\n// Concurrent map access needs synchronization\ntype SafeMap struct {\n    mu sync.RWMutex\n    m  map[string]int\n}\n\nfunc (sm *SafeMap) Get(key string) (int, bool) {\n    sm.mu.RLock()\n    defer sm.mu.RUnlock()\n    val, ok := sm.m[key]\n    return val, ok\n}\n\nfunc (sm *SafeMap) Set(key string, value int) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    sm.m[key] = value\n}\n```\n\n## Type Assertions and Type Switches\n\n### Type Assertions\n```go\n// Type assertion from interface\nvar i interface{} = \"hello\"\n\n// Simple assertion (panics if wrong type)\ns := i.(string)\n\n// Safe assertion with ok check\ns, ok := i.(string)\nif ok {\n    fmt.Printf(\"String: %s\\n\", s)\n} else {\n    fmt.Println(\"Not a string\")\n}\n\n// Common pattern with error checking\nif str, ok := i.(string); ok {\n    // Use str\n}\n\n// Asserting to interface\ntype Stringer interface {\n    String() string\n}\n\nif s, ok := i.(Stringer); ok {\n    fmt.Println(s.String())\n}\n```\n\n### Type Switches\n```go\n// Type switch for multiple type checks\nfunc describe(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"Boolean: %t\\n\", v)\n    case []int:\n        fmt.Printf(\"Slice of ints: %v\\n\", v)\n    case map[string]int:\n        fmt.Printf(\"Map: %v\\n\", v)\n    case func():\n        fmt.Println(\"Function\")\n        v()  // Can call it\n    case nil:\n        fmt.Println(\"nil\")\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\n// Type switch with multiple cases\nswitch v := i.(type) {\ncase int, int32, int64:\n    fmt.Println(\"Some integer type\")\ncase string, []byte:\n    fmt.Println(\"String-like type\")\n}\n\n// Type switch in error handling\nfunc handleError(err error) {\n    switch e := err.(type) {\n    case *os.PathError:\n        fmt.Printf(\"Path error: %s\\n\", e.Path)\n    case *json.SyntaxError:\n        fmt.Printf(\"JSON syntax error at offset %d\\n\", e.Offset)\n    default:\n        fmt.Printf(\"Generic error: %v\\n\", err)\n    }\n}\n```\n\n## Best Practices Summary\n\n1. **Naming**: Use clear, descriptive names. Short names for short-lived variables.\n2. **Error Handling**: Always check errors, wrap with context\n3. **Interfaces**: Keep them small and focused\n4. **Zero Values**: Design types to be useful at their zero value\n5. **Channels**: Use for communication between goroutines\n6. **Defer**: Use for cleanup, runs in LIFO order\n7. **Pointers**: Use when modifying or avoiding copies\n8. **Slices**: Prefer over arrays for flexibility\n9. **Maps**: Remember they're not thread-safe\n10. **Type Assertions**: Always use the two-value form for safety"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5941,"cache_read_input_tokens":32283,"output_tokens":8249,"service_tier":"standard"}},"requestId":"req_011CS5HWAp3fRVXUcEMRvfTw","type":"assistant","uuid":"12dce85e-1923-48c2-8aa2-c32413c0c4b3","timestamp":"2025-08-13T07:09:46.523Z"}
{"parentUuid":"12dce85e-1923-48c2-8aa2-c32413c0c4b3","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BuDg7bEBjZbU19EXrBwfzz","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md"}]},"uuid":"da68cc7e-e06e-4929-9135-20252f596269","timestamp":"2025-08-13T07:09:46.580Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md","content":"# Go Fundamentals - Complete Language Reference\n\n## Table of Contents\n1. [Basic Syntax](#basic-syntax)\n2. [Types and Variables](#types-and-variables)\n3. [Control Flow](#control-flow)\n4. [Functions](#functions)\n5. [Methods](#methods)\n6. [Structs](#structs)\n7. [Interfaces](#interfaces)\n8. [Error Handling Basics](#error-handling-basics)\n9. [Pointers](#pointers)\n10. [Arrays and Slices](#arrays-and-slices)\n11. [Maps](#maps)\n12. [Type Assertions and Type Switches](#type-assertions-and-type-switches)\n\n## Basic Syntax\n\n### Package Declaration\nEvery Go file starts with a package declaration:\n\n```go\npackage main  // Executable programs use package main\npackage trading  // Library packages use lowercase names\n```\n\n### Import Statements\n```go\nimport \"fmt\"  // Single import\n\n// Multiple imports (preferred style)\nimport (\n    \"fmt\"\n    \"strings\"\n    \"time\"\n    \n    // Third-party packages\n    \"github.com/shopspring/decimal\"\n    \n    // Internal packages\n    \"myproject/internal/trading\"\n)\n\n// Aliased imports\nimport (\n    stdlog \"log\"  // Alias to avoid naming conflicts\n    _ \"github.com/lib/pq\"  // Import for side effects only\n    . \"math\"  // Dot import (use sparingly)\n)\n```\n\n### Comments\n```go\n// Single-line comment\n\n/*\nMulti-line comment\nUsed for longer explanations\n*/\n\n// Package comments precede package declaration\n// Package trading provides core trading functionality.\npackage trading\n\n// Function comments precede the function\n// CalculateProfit returns the profit from a trade.\nfunc CalculateProfit(entry, exit decimal.Decimal) decimal.Decimal {\n    return exit.Sub(entry)\n}\n```\n\n## Types and Variables\n\n### Basic Types\n```go\n// Boolean\nvar isActive bool = true\nvar isEnabled = false  // Type inference\n\n// Numeric Types\nvar count int = 42        // Platform-dependent size (32 or 64 bits)\nvar port int64 = 8080     // Explicit 64-bit integer\nvar smallNum int8 = 127   // 8-bit integer (-128 to 127)\nvar byteVal byte = 255    // Alias for uint8\nvar runeVal rune = 'A'    // Alias for int32, represents Unicode code point\n\n// Floating-point\nvar price float64 = 99.99\nvar rate float32 = 0.05\n\n// Complex numbers\nvar c complex128 = 1 + 2i\nvar c64 complex64 = complex(1, 2)\n\n// String\nvar message string = \"Hello, Go!\"\nvar multiline = `This is a\nmulti-line string\nwith backticks`\n```\n\n### Variable Declaration\n```go\n// var keyword with type\nvar x int\nvar y int = 10\n\n// var with type inference\nvar z = 20  // int inferred\n\n// Short declaration (only inside functions)\nw := 30  // Same as: var w = 30\n\n// Multiple variables\nvar a, b, c int\nvar d, e = 1, \"hello\"\nf, g := true, 3.14\n\n// Grouped declaration\nvar (\n    name   string = \"Alice\"\n    age    int    = 30\n    active bool   = true\n)\n\n// Constants\nconst pi = 3.14159\nconst (\n    StatusOK    = 200\n    StatusError = 500\n)\n\n// Typed constants\nconst typedConst int64 = 1234\n\n// iota for enumerations\nconst (\n    Sunday = iota  // 0\n    Monday         // 1\n    Tuesday        // 2\n    Wednesday      // 3\n)\n\n// Complex iota usage\nconst (\n    _  = iota             // Skip 0\n    KB = 1 << (10 * iota) // 1024\n    MB                    // 1048576\n    GB                    // 1073741824\n)\n```\n\n### Zero Values\n```go\nvar i int        // 0\nvar f float64    // 0.0\nvar b bool       // false\nvar s string     // \"\"\nvar p *int       // nil\nvar a []int      // nil\nvar m map[string]int  // nil\nvar ch chan int  // nil\nvar fn func()    // nil\nvar inf interface{}  // nil\n```\n\n### Type Conversions\n```go\n// Explicit conversion required\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(i)\n\n// String conversions\nvar s string = string(65)  // \"A\" (from ASCII/Unicode)\nvar bytes = []byte(\"hello\")  // String to byte slice\nvar str = string(bytes)      // Byte slice to string\n\n// Numeric parsing\nimport \"strconv\"\ni, err := strconv.Atoi(\"123\")  // String to int\ns := strconv.Itoa(123)          // Int to string\nf, err := strconv.ParseFloat(\"3.14\", 64)  // String to float64\n```\n\n## Control Flow\n\n### If Statements\n```go\n// Basic if\nif x > 0 {\n    fmt.Println(\"Positive\")\n}\n\n// If-else\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else if x < 0 {\n    fmt.Println(\"Negative\")\n} else {\n    fmt.Println(\"Zero\")\n}\n\n// If with initialization\nif err := doSomething(); err != nil {\n    return err  // err is scoped to if block\n}\n\n// Common patterns\nif val, ok := m[key]; ok {\n    // Use val - key exists in map\n}\n\nif v, err := getValue(); err == nil {\n    // Use v - no error occurred\n}\n```\n\n### For Loops\n```go\n// Traditional for loop\nfor i := 0; i < 10; i++ {\n    fmt.Println(i)\n}\n\n// While-style loop\ni := 0\nfor i < 10 {\n    fmt.Println(i)\n    i++\n}\n\n// Infinite loop\nfor {\n    // Break or return to exit\n    if condition {\n        break\n    }\n}\n\n// Range over slice/array\nnumbers := []int{1, 2, 3, 4, 5}\nfor index, value := range numbers {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n\n// Ignore index with blank identifier\nfor _, value := range numbers {\n    fmt.Println(value)\n}\n\n// Range over map\nm := map[string]int{\"a\": 1, \"b\": 2}\nfor key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Range over string (iterates over runes)\nfor index, runeValue := range \"Hello, 世界\" {\n    fmt.Printf(\"%d: %c\\n\", index, runeValue)\n}\n\n// Range over channel\nfor msg := range ch {\n    fmt.Println(msg)  // Receives until channel is closed\n}\n\n// Continue and break with labels\nouter:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        if i == j {\n            continue outer  // Continue outer loop\n        }\n        if i+j > 3 {\n            break outer  // Break from outer loop\n        }\n    }\n}\n```\n\n### Switch Statements\n```go\n// Basic switch\nswitch day {\ncase \"Monday\":\n    fmt.Println(\"Start of work week\")\ncase \"Friday\":\n    fmt.Println(\"TGIF\")\ncase \"Saturday\", \"Sunday\":  // Multiple cases\n    fmt.Println(\"Weekend!\")\ndefault:\n    fmt.Println(\"Midweek\")\n}\n\n// Switch with initialization\nswitch hour := time.Now().Hour(); {\ncase hour < 12:\n    fmt.Println(\"Morning\")\ncase hour < 18:\n    fmt.Println(\"Afternoon\")\ndefault:\n    fmt.Println(\"Evening\")\n}\n\n// Switch without expression (replaces if-else chains)\nswitch {\ncase x < 0:\n    fmt.Println(\"Negative\")\ncase x == 0:\n    fmt.Println(\"Zero\")\ncase x > 0:\n    fmt.Println(\"Positive\")\n}\n\n// Fallthrough (rarely used)\nswitch n {\ncase 0:\n    fmt.Println(\"Zero\")\n    fallthrough  // Continue to next case\ncase 1:\n    fmt.Println(\"One or fallthrough from Zero\")\n}\n\n// Type switch (covered in detail later)\nswitch v := x.(type) {\ncase int:\n    fmt.Printf(\"Integer: %d\\n\", v)\ncase string:\n    fmt.Printf(\"String: %s\\n\", v)\ndefault:\n    fmt.Printf(\"Unknown type: %T\\n\", v)\n}\n```\n\n### Defer, Panic, and Recover\n```go\n// Defer - executes at function exit (LIFO order)\nfunc readFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()  // Ensures file is closed\n    \n    // Read file...\n    return nil\n}\n\n// Multiple defers execute in reverse order\nfunc example() {\n    defer fmt.Println(\"Third\")\n    defer fmt.Println(\"Second\")\n    defer fmt.Println(\"First\")\n    // Prints: First, Second, Third\n}\n\n// Defer with function values\nfunc measure(name string) func() {\n    start := time.Now()\n    return func() {\n        fmt.Printf(\"%s took %v\\n\", name, time.Since(start))\n    }\n}\n\nfunc slowOperation() {\n    defer measure(\"slowOperation\")()  // Note the extra ()\n    time.Sleep(1 * time.Second)\n}\n\n// Panic - for unrecoverable errors\nfunc mustNotBeZero(x int) {\n    if x == 0 {\n        panic(\"x cannot be zero\")\n    }\n}\n\n// Recover - catch panics\nfunc safeExecute(fn func()) (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    fn()  // May panic\n    return nil\n}\n```\n\n## Functions\n\n### Function Declaration\n```go\n// Basic function\nfunc add(x int, y int) int {\n    return x + y\n}\n\n// Shortened parameter types\nfunc add2(x, y int) int {  // Both x and y are int\n    return x + y\n}\n\n// Multiple return values\nfunc divide(x, y float64) (float64, error) {\n    if y == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return x / y, nil\n}\n\n// Named return values\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return  // Naked return (use sparingly)\n}\n\n// Variadic functions\nfunc sum(nums ...int) int {\n    total := 0\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n\n// Call variadic function\nresult := sum(1, 2, 3, 4, 5)\nnumbers := []int{1, 2, 3}\nresult2 := sum(numbers...)  // Spread slice\n```\n\n### Function Types and Values\n```go\n// Function as type\ntype Calculator func(int, int) int\n\n// Function as variable\nvar operation Calculator = add\n\n// Anonymous functions\nmultiply := func(x, y int) int {\n    return x * y\n}\n\n// Immediately invoked function\nresult := func(x, y int) int {\n    return x + y\n}(5, 3)\n\n// Functions as parameters\nfunc apply(fn func(int, int) int, x, y int) int {\n    return fn(x, y)\n}\n\nresult := apply(add, 10, 5)\n\n// Functions returning functions\nfunc makeAdder(x int) func(int) int {\n    return func(y int) int {\n        return x + y  // Closure captures x\n    }\n}\n\nadd5 := makeAdder(5)\nresult := add5(3)  // 8\n```\n\n### Closures\n```go\n// Closure captures variables from outer scope\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nc := counter()\nfmt.Println(c())  // 1\nfmt.Println(c())  // 2\nfmt.Println(c())  // 3\n\n// Common pitfall with closures in loops\n// BAD:\nvar funcs []func()\nfor i := 0; i < 3; i++ {\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // Captures loop variable\n    })\n}\n// All functions print 3\n\n// GOOD:\nfor i := 0; i < 3; i++ {\n    i := i  // Create new variable\n    funcs = append(funcs, func() {\n        fmt.Println(i)\n    })\n}\n// Functions print 0, 1, 2\n```\n\n## Methods\n\n### Method Declaration\n```go\n// Methods are functions with a receiver\ntype Point struct {\n    X, Y float64\n}\n\n// Value receiver\nfunc (p Point) Distance() float64 {\n    return math.Sqrt(p.X*p.X + p.Y*p.Y)\n}\n\n// Pointer receiver (can modify the receiver)\nfunc (p *Point) Scale(factor float64) {\n    p.X *= factor\n    p.Y *= factor\n}\n\n// Using methods\np := Point{3, 4}\nfmt.Println(p.Distance())  // 5\np.Scale(2)  // p is now {6, 8}\n\n// Methods on non-struct types\ntype MyInt int\n\nfunc (i MyInt) IsPositive() bool {\n    return i > 0\n}\n\nvar num MyInt = 10\nfmt.Println(num.IsPositive())  // true\n```\n\n### Value vs Pointer Receivers\n```go\n// Guidelines for choosing receiver type:\n\n// Use pointer receiver when:\n// 1. Method needs to modify the receiver\nfunc (u *User) SetName(name string) {\n    u.Name = name\n}\n\n// 2. Struct is large (avoid copying)\nfunc (d *LargeData) Process() {\n    // Processing large struct\n}\n\n// 3. Consistency - if one method needs pointer, use for all\ntype Account struct {\n    balance decimal.Decimal\n}\n\nfunc (a *Account) Deposit(amount decimal.Decimal) {\n    a.balance = a.balance.Add(amount)\n}\n\nfunc (a *Account) Balance() decimal.Decimal {\n    return a.balance  // Pointer receiver for consistency\n}\n\n// Use value receiver when:\n// 1. Method doesn't modify receiver\n// 2. Type is small and copying is cheap\n// 3. You want immutability\nfunc (p Point) DistanceTo(other Point) float64 {\n    dx := p.X - other.X\n    dy := p.Y - other.Y\n    return math.Sqrt(dx*dx + dy*dy)\n}\n```\n\n## Structs\n\n### Struct Declaration and Usage\n```go\n// Basic struct\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// Creating structs\np1 := Person{Name: \"Alice\", Age: 30}\np2 := Person{\"Bob\", 25}  // Positional (not recommended)\np3 := Person{Name: \"Charlie\"}  // Partial initialization\nvar p4 Person  // Zero value\n\n// Accessing fields\nfmt.Println(p1.Name)\np1.Age = 31\n\n// Struct pointers\nptr := &Person{Name: \"Dave\", Age: 40}\nptr.Age = 41  // Same as (*ptr).Age = 41\n\n// Anonymous structs\npoint := struct {\n    X, Y int\n}{10, 20}\n\n// Struct tags\ntype User struct {\n    ID       int    `json:\"id\" db:\"user_id\"`\n    Username string `json:\"username\" db:\"user_name\"`\n    Password string `json:\"-\"` // Omit from JSON\n    Admin    bool   `json:\"is_admin,omitempty\"`\n}\n\n// Accessing tags via reflection\nimport \"reflect\"\nt := reflect.TypeOf(User{})\nfield, _ := t.FieldByName(\"ID\")\nfmt.Println(field.Tag.Get(\"json\"))  // \"id\"\n\n// Embedded structs (composition)\ntype Employee struct {\n    Person  // Embedded\n    ID      int\n    Manager *Employee\n}\n\nemp := Employee{\n    Person: Person{Name: \"Eve\", Age: 28},\n    ID:     12345,\n}\nfmt.Println(emp.Name)  // Promoted field\n\n// Field alignment and memory optimization\n// Bad: 24 bytes on 64-bit systems\ntype Inefficient struct {\n    a bool   // 1 byte + 7 padding\n    b int64  // 8 bytes\n    c bool   // 1 byte + 7 padding\n}\n\n// Good: 16 bytes on 64-bit systems\ntype Efficient struct {\n    b int64  // 8 bytes\n    a bool   // 1 byte\n    c bool   // 1 byte + 6 padding\n}\n```\n\n### Struct Methods and Composition\n```go\n// Composition for code reuse\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\n// Composed interface\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\n// Struct embedding for composition\ntype Base struct {\n    ID   int\n    Name string\n}\n\nfunc (b *Base) SetName(name string) {\n    b.Name = name\n}\n\ntype Derived struct {\n    Base  // Embed Base\n    Extra string\n}\n\nd := Derived{\n    Base:  Base{ID: 1, Name: \"Test\"},\n    Extra: \"additional\",\n}\nd.SetName(\"New Name\")  // Call Base method\n```\n\n## Interfaces\n\n### Interface Declaration and Implementation\n```go\n// Interface definition\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\n// Implementation is implicit\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n    return 2 * (r.Width + r.Height)\n}\n\n// Rectangle implements Shape implicitly\nvar s Shape = Rectangle{Width: 10, Height: 5}\n\n// Empty interface (accepts any type)\nvar anything interface{}\nanything = 42\nanything = \"hello\"\nanything = Rectangle{10, 5}\n\n// Interface satisfaction\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\n// Any type with Write method satisfies Writer\ntype File struct{}\nfunc (f *File) Write(data []byte) (int, error) {\n    return len(data), nil\n}\n\nvar w Writer = &File{}  // Note: pointer type\n\n// Interface values\ntype Stringer interface {\n    String() string\n}\n\ntype Person struct {\n    Name string\n}\n\nfunc (p Person) String() string {\n    return p.Name\n}\n\nvar s Stringer = Person{\"Alice\"}\n// Interface value has (value, type) = (Person{\"Alice\"}, Person)\n\n// Nil interface gotcha\nvar p *Person = nil\nvar s Stringer = p  // s is not nil!\nif s == nil {\n    // This won't execute\n}\n// s has (value, type) = (nil, *Person)\n```\n\n### Common Interface Patterns\n```go\n// Small interfaces (Go philosophy)\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Composed interfaces\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Accept interfaces, return structs\nfunc process(r Reader) error {\n    // Accept any Reader\n    data := make([]byte, 1024)\n    _, err := r.Read(data)\n    return err\n}\n\nfunc newBuffer() *bytes.Buffer {\n    // Return concrete type\n    return &bytes.Buffer{}\n}\n\n// Interface guards (compile-time check)\nvar _ Shape = (*Rectangle)(nil)  // Ensures Rectangle implements Shape\nvar _ Shape = Rectangle{}        // Alternative syntax\n```\n\n## Error Handling Basics\n\n### Error Interface\n```go\n// Error is a built-in interface\ntype error interface {\n    Error() string\n}\n\n// Creating errors\nimport \"errors\"\nerr := errors.New(\"something went wrong\")\n\n// Formatted errors\nerr := fmt.Errorf(\"failed to process %s: %v\", filename, originalErr)\n\n// Custom error types\ntype ValidationError struct {\n    Field string\n    Value interface{}\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for field %s: invalid value %v\", \n        e.Field, e.Value)\n}\n\n// Returning errors\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// Checking errors\nresult, err := divide(10, 0)\nif err != nil {\n    log.Printf(\"Error: %v\", err)\n    return err\n}\n\n// Error wrapping (Go 1.13+)\nerr := doSomething()\nif err != nil {\n    return fmt.Errorf(\"operation failed: %w\", err)\n}\n\n// Error unwrapping\nvar pathError *os.PathError\nif errors.As(err, &pathError) {\n    fmt.Printf(\"Path error: %s\\n\", pathError.Path)\n}\n\n// Checking error types\nif errors.Is(err, os.ErrNotExist) {\n    // Handle file not found\n}\n\n// Sentinel errors\nvar (\n    ErrNotFound = errors.New(\"not found\")\n    ErrInvalid  = errors.New(\"invalid input\")\n)\n\n// Multiple error handling patterns\n// Pattern 1: Return immediately\nif err := step1(); err != nil {\n    return fmt.Errorf(\"step1 failed: %w\", err)\n}\n\n// Pattern 2: Accumulate errors\nvar errs []error\nif err := step1(); err != nil {\n    errs = append(errs, err)\n}\nif err := step2(); err != nil {\n    errs = append(errs, err)\n}\nif len(errs) > 0 {\n    return fmt.Errorf(\"multiple errors: %v\", errs)\n}\n```\n\n## Pointers\n\n### Pointer Basics\n```go\n// Pointer declaration\nvar p *int  // Pointer to int\n\n// Address operator &\nx := 42\np = &x  // p points to x\n\n// Dereference operator *\nfmt.Println(*p)  // 42\n*p = 100  // x is now 100\n\n// Pointer zero value is nil\nvar ptr *string\nif ptr == nil {\n    fmt.Println(\"Pointer is nil\")\n}\n\n// Allocating memory\np1 := new(int)  // Allocates zeroed int, returns *int\n*p1 = 42\n\n// Pointers to structs\ntype Person struct {\n    Name string\n    Age  int\n}\n\nperson := &Person{Name: \"Alice\", Age: 30}\nperson.Age = 31  // Automatic dereferencing\n\n// Pointer receivers\nfunc (p *Person) Birthday() {\n    p.Age++  // Modifies the original\n}\n\n// When to use pointers:\n// 1. Large structs (avoid copying)\n// 2. Need to modify the original\n// 3. Optional values (nil represents absence)\n// 4. Implementing interfaces with pointer receivers\n```\n\n## Arrays and Slices\n\n### Arrays\n```go\n// Arrays have fixed size\nvar arr [5]int  // Array of 5 ints\narr[0] = 10\narr[4] = 50\n\n// Array literals\nprimes := [5]int{2, 3, 5, 7, 11}\npartial := [5]int{1, 2}  // Rest are zeros\n\n// Size inference\nauto := [...]int{1, 2, 3, 4, 5}  // Size 5\n\n// Arrays are values (copied on assignment)\narr2 := arr  // Full copy\narr2[0] = 100  // Doesn't affect arr\n\n// Multidimensional arrays\nvar matrix [3][3]int\nmatrix[1][1] = 5\n```\n\n### Slices\n```go\n// Slices are dynamic references to arrays\nvar slice []int  // nil slice\n\n// Creating slices\nslice1 := []int{1, 2, 3, 4, 5}  // Slice literal\nslice2 := make([]int, 5)        // Length 5, capacity 5\nslice3 := make([]int, 5, 10)    // Length 5, capacity 10\n\n// Slicing operations\narr := [5]int{1, 2, 3, 4, 5}\ns1 := arr[1:4]  // [2, 3, 4]\ns2 := arr[:3]   // [1, 2, 3]\ns3 := arr[2:]   // [3, 4, 5]\ns4 := arr[:]    // [1, 2, 3, 4, 5]\n\n// Slice properties\nfmt.Println(len(s1))  // 3\nfmt.Println(cap(s1))  // 4 (capacity from underlying array)\n\n// Appending to slices\nslice = append(slice, 6)\nslice = append(slice, 7, 8, 9)\nslice = append(slice, anotherSlice...)\n\n// Copy slices\nsrc := []int{1, 2, 3}\ndst := make([]int, len(src))\ncopy(dst, src)\n\n// Slice tricks\n// Remove element at index i\nslice = append(slice[:i], slice[i+1:]...)\n\n// Insert element at index i\nslice = append(slice[:i], append([]int{x}, slice[i:]...)...)\n\n// Filter in place\nn := 0\nfor _, x := range slice {\n    if keepCondition(x) {\n        slice[n] = x\n        n++\n    }\n}\nslice = slice[:n]\n\n// Nil vs empty slice\nvar nilSlice []int      // nil\nemptySlice := []int{}   // Not nil, but empty\nemptyMake := make([]int, 0)  // Not nil, but empty\n\n// Slice internals\n// A slice is a struct with:\n// - Pointer to underlying array\n// - Length\n// - Capacity\n\n// Growing slices efficiently\n// Preallocate when size is known\nresult := make([]int, 0, expectedSize)\nfor i := 0; i < expectedSize; i++ {\n    result = append(result, process(i))\n}\n```\n\n## Maps\n\n### Map Operations\n```go\n// Map declaration\nvar m map[string]int  // nil map (read-only)\n\n// Creating maps\nm1 := make(map[string]int)\nm2 := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\n\n// Map operations\nm1[\"key\"] = 42          // Set\nvalue := m1[\"key\"]      // Get\ndelete(m1, \"key\")       // Delete\n\n// Check if key exists\nvalue, exists := m1[\"key\"]\nif exists {\n    fmt.Println(\"Value:\", value)\n}\n\n// Common pattern\nif val, ok := m[\"key\"]; ok {\n    // Use val\n}\n\n// Iterate over map\nfor key, value := range m2 {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Keys only\nfor key := range m2 {\n    fmt.Println(key)\n}\n\n// Map of slices\ngroups := make(map[string][]string)\ngroups[\"admins\"] = append(groups[\"admins\"], \"alice\")\n\n// Map of maps\nnested := make(map[string]map[string]int)\nif nested[\"outer\"] == nil {\n    nested[\"outer\"] = make(map[string]int)\n}\nnested[\"outer\"][\"inner\"] = 42\n\n// Maps are reference types\nm3 := m2  // Both reference same map\nm3[\"charlie\"] = 35  // Affects m2\n\n// Zero value for map values\ncounts := make(map[string]int)\ncounts[\"new\"]++  // Works! int zero value is 0\n\n// Map as set\nset := make(map[string]struct{})\nset[\"item\"] = struct{}{}  // Add to set\nif _, exists := set[\"item\"]; exists {\n    // Item in set\n}\ndelete(set, \"item\")  // Remove from set\n\n// Concurrent map access needs synchronization\ntype SafeMap struct {\n    mu sync.RWMutex\n    m  map[string]int\n}\n\nfunc (sm *SafeMap) Get(key string) (int, bool) {\n    sm.mu.RLock()\n    defer sm.mu.RUnlock()\n    val, ok := sm.m[key]\n    return val, ok\n}\n\nfunc (sm *SafeMap) Set(key string, value int) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    sm.m[key] = value\n}\n```\n\n## Type Assertions and Type Switches\n\n### Type Assertions\n```go\n// Type assertion from interface\nvar i interface{} = \"hello\"\n\n// Simple assertion (panics if wrong type)\ns := i.(string)\n\n// Safe assertion with ok check\ns, ok := i.(string)\nif ok {\n    fmt.Printf(\"String: %s\\n\", s)\n} else {\n    fmt.Println(\"Not a string\")\n}\n\n// Common pattern with error checking\nif str, ok := i.(string); ok {\n    // Use str\n}\n\n// Asserting to interface\ntype Stringer interface {\n    String() string\n}\n\nif s, ok := i.(Stringer); ok {\n    fmt.Println(s.String())\n}\n```\n\n### Type Switches\n```go\n// Type switch for multiple type checks\nfunc describe(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"Boolean: %t\\n\", v)\n    case []int:\n        fmt.Printf(\"Slice of ints: %v\\n\", v)\n    case map[string]int:\n        fmt.Printf(\"Map: %v\\n\", v)\n    case func():\n        fmt.Println(\"Function\")\n        v()  // Can call it\n    case nil:\n        fmt.Println(\"nil\")\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\n// Type switch with multiple cases\nswitch v := i.(type) {\ncase int, int32, int64:\n    fmt.Println(\"Some integer type\")\ncase string, []byte:\n    fmt.Println(\"String-like type\")\n}\n\n// Type switch in error handling\nfunc handleError(err error) {\n    switch e := err.(type) {\n    case *os.PathError:\n        fmt.Printf(\"Path error: %s\\n\", e.Path)\n    case *json.SyntaxError:\n        fmt.Printf(\"JSON syntax error at offset %d\\n\", e.Offset)\n    default:\n        fmt.Printf(\"Generic error: %v\\n\", err)\n    }\n}\n```\n\n## Best Practices Summary\n\n1. **Naming**: Use clear, descriptive names. Short names for short-lived variables.\n2. **Error Handling**: Always check errors, wrap with context\n3. **Interfaces**: Keep them small and focused\n4. **Zero Values**: Design types to be useful at their zero value\n5. **Channels**: Use for communication between goroutines\n6. **Defer**: Use for cleanup, runs in LIFO order\n7. **Pointers**: Use when modifying or avoiding copies\n8. **Slices**: Prefer over arrays for flexibility\n9. **Maps**: Remember they're not thread-safe\n10. **Type Assertions**: Always use the two-value form for safety","structuredPatch":[]}}
{"parentUuid":"da68cc7e-e06e-4929-9135-20252f596269","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_019wVP12rQbHvCoNgkervDci","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"## 2. Go Concurrency"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8289,"cache_read_input_tokens":38224,"output_tokens":11146,"service_tier":"standard"}},"requestId":"req_011CS5Hmu4CuuJ9tUqwZHr4L","type":"assistant","uuid":"37bdd12d-4fc3-40a3-9f09-c0dfed28c10a","timestamp":"2025-08-13T07:09:50.101Z"}
{"parentUuid":"37bdd12d-4fc3-40a3-9f09-c0dfed28c10a","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_019wVP12rQbHvCoNgkervDci","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01HV5eqNqMRpFuh1Lw1RprCs","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-concurrency.md","content":"# Go Concurrency - Mastering Concurrent Programming\n\n## Table of Contents\n1. [Goroutines](#goroutines)\n2. [Channels](#channels)\n3. [Select Statement](#select-statement)\n4. [Sync Package](#sync-package)\n5. [Atomic Operations](#atomic-operations)\n6. [Concurrency Patterns](#concurrency-patterns)\n7. [Context Package](#context-package)\n8. [Race Conditions](#race-conditions)\n9. [Deadlocks](#deadlocks)\n10. [Performance and Optimization](#performance-and-optimization)\n\n## Goroutines\n\n### Goroutine Basics\n```go\n// Starting a goroutine\ngo functionName()\ngo func() {\n    // Anonymous function as goroutine\n}()\n\n// Goroutines with parameters\ngo processItem(item)\n\n// Common mistake: loop variable capture\n// WRONG:\nfor _, item := range items {\n    go func() {\n        process(item)  // All goroutines get last item!\n    }()\n}\n\n// CORRECT:\nfor _, item := range items {\n    item := item  // Create new variable\n    go func() {\n        process(item)\n    }()\n}\n\n// Alternative: pass as parameter\nfor _, item := range items {\n    go func(i Item) {\n        process(i)\n    }(item)\n}\n\n// Waiting for goroutines to complete\nvar wg sync.WaitGroup\n\nfor i := 0; i < 10; i++ {\n    wg.Add(1)\n    go func(id int) {\n        defer wg.Done()\n        doWork(id)\n    }(i)\n}\n\nwg.Wait()  // Block until all complete\n\n// Goroutine lifecycle management\ntype Worker struct {\n    done chan struct{}\n}\n\nfunc (w *Worker) Start() {\n    go w.run()\n}\n\nfunc (w *Worker) run() {\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case <-ticker.C:\n            w.doWork()\n        case <-w.done:\n            return\n        }\n    }\n}\n\nfunc (w *Worker) Stop() {\n    close(w.done)\n}\n```\n\n### Goroutine Patterns\n```go\n// Limiting concurrent goroutines\nconst maxWorkers = 10\nsem := make(chan struct{}, maxWorkers)\n\nfor _, item := range items {\n    sem <- struct{}{}  // Acquire\n    go func(i Item) {\n        defer func() { <-sem }()  // Release\n        process(i)\n    }(item)\n}\n\n// Wait for all to complete\nfor i := 0; i < maxWorkers; i++ {\n    sem <- struct{}{}\n}\n\n// Error handling in goroutines\ntype Result struct {\n    Value interface{}\n    Err   error\n}\n\nresults := make(chan Result, len(items))\n\nfor _, item := range items {\n    go func(i Item) {\n        value, err := process(i)\n        results <- Result{Value: value, Err: err}\n    }(item)\n}\n\n// Collect results\nfor i := 0; i < len(items); i++ {\n    result := <-results\n    if result.Err != nil {\n        log.Printf(\"Error: %v\", result.Err)\n    }\n}\n\n// Goroutine pool pattern\ntype Pool struct {\n    work chan func()\n    wg   sync.WaitGroup\n}\n\nfunc NewPool(workers int) *Pool {\n    p := &Pool{\n        work: make(chan func(), 100),\n    }\n    \n    p.wg.Add(workers)\n    for i := 0; i < workers; i++ {\n        go p.worker()\n    }\n    \n    return p\n}\n\nfunc (p *Pool) worker() {\n    defer p.wg.Done()\n    for fn := range p.work {\n        fn()\n    }\n}\n\nfunc (p *Pool) Submit(fn func()) {\n    p.work <- fn\n}\n\nfunc (p *Pool) Shutdown() {\n    close(p.work)\n    p.wg.Wait()\n}\n```\n\n## Channels\n\n### Channel Basics\n```go\n// Creating channels\nch := make(chan int)       // Unbuffered\nch := make(chan int, 10)   // Buffered with capacity 10\n\n// Channel operations\nch <- 42        // Send\nvalue := <-ch   // Receive\nvalue, ok := <-ch  // Receive with closed check\n\n// Closing channels\nclose(ch)\n\n// Check if channel is closed\nif v, ok := <-ch; !ok {\n    // Channel is closed\n}\n\n// Directional channels\nfunc send(ch chan<- int) {  // Send-only\n    ch <- 42\n}\n\nfunc receive(ch <-chan int) {  // Receive-only\n    value := <-ch\n}\n\n// Channel zero value is nil\nvar ch chan int\n// ch <- 1  // Blocks forever!\n// <-ch     // Blocks forever!\n\n// Range over channel\nch := make(chan int)\ngo func() {\n    for i := 0; i < 5; i++ {\n        ch <- i\n    }\n    close(ch)\n}()\n\nfor value := range ch {\n    fmt.Println(value)\n}\n```\n\n### Buffered vs Unbuffered Channels\n```go\n// Unbuffered channels - synchronous\nch := make(chan int)\ngo func() {\n    ch <- 42  // Blocks until someone receives\n}()\nvalue := <-ch  // Blocks until someone sends\n\n// Buffered channels - asynchronous up to capacity\nch := make(chan int, 3)\nch <- 1  // Doesn't block\nch <- 2  // Doesn't block\nch <- 3  // Doesn't block\n// ch <- 4  // Would block!\n\n// Using buffered channels as semaphores\ntype Semaphore chan struct{}\n\nfunc NewSemaphore(n int) Semaphore {\n    return make(Semaphore, n)\n}\n\nfunc (s Semaphore) Acquire() {\n    s <- struct{}{}\n}\n\nfunc (s Semaphore) Release() {\n    <-s\n}\n\n// Channel of channels\ntype Request struct {\n    data  string\n    reply chan Response\n}\n\nrequests := make(chan Request)\n\n// Server\ngo func() {\n    for req := range requests {\n        response := processRequest(req.data)\n        req.reply <- response\n    }\n}()\n\n// Client\nreply := make(chan Response)\nrequests <- Request{data: \"hello\", reply: reply}\nresponse := <-reply\n```\n\n### Channel Patterns\n```go\n// Fan-in: Merge multiple channels\nfunc fanIn(channels ...<-chan int) <-chan int {\n    out := make(chan int)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan int) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n\n// Fan-out: Distribute work\nfunc fanOut(in <-chan int, workers int) []<-chan int {\n    channels := make([]<-chan int, workers)\n    \n    for i := 0; i < workers; i++ {\n        ch := make(chan int)\n        channels[i] = ch\n        \n        go func(out chan int) {\n            for val := range in {\n                out <- process(val)\n            }\n            close(out)\n        }(ch)\n    }\n    \n    return channels\n}\n\n// Pipeline pattern\nfunc pipeline() {\n    // Stage 1: Generate numbers\n    numbers := make(chan int)\n    go func() {\n        for i := 1; i <= 100; i++ {\n            numbers <- i\n        }\n        close(numbers)\n    }()\n    \n    // Stage 2: Square numbers\n    squares := make(chan int)\n    go func() {\n        for n := range numbers {\n            squares <- n * n\n        }\n        close(squares)\n    }()\n    \n    // Stage 3: Filter even\n    evens := make(chan int)\n    go func() {\n        for sq := range squares {\n            if sq%2 == 0 {\n                evens <- sq\n            }\n        }\n        close(evens)\n    }()\n    \n    // Consume\n    for even := range evens {\n        fmt.Println(even)\n    }\n}\n\n// Timeout pattern\nfunc timeoutExample() {\n    ch := make(chan string)\n    \n    go func() {\n        time.Sleep(2 * time.Second)\n        ch <- \"result\"\n    }()\n    \n    select {\n    case result := <-ch:\n        fmt.Println(\"Got:\", result)\n    case <-time.After(1 * time.Second):\n        fmt.Println(\"Timeout!\")\n    }\n}\n```\n\n## Select Statement\n\n### Select Basics\n```go\n// Basic select\nselect {\ncase v1 := <-ch1:\n    fmt.Println(\"Received from ch1:\", v1)\ncase v2 := <-ch2:\n    fmt.Println(\"Received from ch2:\", v2)\ncase ch3 <- 42:\n    fmt.Println(\"Sent to ch3\")\ndefault:\n    fmt.Println(\"No channels ready\")\n}\n\n// Non-blocking receive\nselect {\ncase msg := <-ch:\n    fmt.Println(\"Received:\", msg)\ndefault:\n    fmt.Println(\"No message available\")\n}\n\n// Non-blocking send\nselect {\ncase ch <- msg:\n    fmt.Println(\"Sent message\")\ndefault:\n    fmt.Println(\"Channel full or not ready\")\n}\n\n// Timeout with select\nselect {\ncase result := <-ch:\n    fmt.Println(\"Got result:\", result)\ncase <-time.After(5 * time.Second):\n    fmt.Println(\"Timeout after 5 seconds\")\n}\n\n// Ticker with select\nticker := time.NewTicker(1 * time.Second)\ndefer ticker.Stop()\n\ndone := make(chan bool)\ngo func() {\n    time.Sleep(5 * time.Second)\n    done <- true\n}()\n\nfor {\n    select {\n    case <-ticker.C:\n        fmt.Println(\"Tick\")\n    case <-done:\n        fmt.Println(\"Done!\")\n        return\n    }\n}\n```\n\n### Advanced Select Patterns\n```go\n// Priority select using default\nfunc prioritySelect(high, low <-chan int) int {\n    select {\n    case val := <-high:\n        return val\n    default:\n        select {\n        case val := <-high:\n            return val\n        case val := <-low:\n            return val\n        }\n    }\n}\n\n// Quit channel pattern\nfunc worker(work <-chan int, quit <-chan struct{}) {\n    for {\n        select {\n        case w := <-work:\n            process(w)\n        case <-quit:\n            cleanup()\n            return\n        }\n    }\n}\n\n// Multiple return channels\nfunc multiReturn() (chan int, chan error) {\n    results := make(chan int)\n    errors := make(chan error)\n    \n    go func() {\n        defer close(results)\n        defer close(errors)\n        \n        for i := 0; i < 10; i++ {\n            if i%3 == 0 {\n                errors <- fmt.Errorf(\"error at %d\", i)\n            } else {\n                results <- i * i\n            }\n        }\n    }()\n    \n    return results, errors\n}\n\n// Using nil channels in select\nfunc dynamicSelect() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    \n    go func() {\n        for i := 0; i < 5; i++ {\n            ch1 <- i\n            time.Sleep(100 * time.Millisecond)\n        }\n        close(ch1)\n    }()\n    \n    go func() {\n        for i := 5; i < 10; i++ {\n            ch2 <- i\n            time.Sleep(150 * time.Millisecond)\n        }\n        close(ch2)\n    }()\n    \n    for ch1 != nil || ch2 != nil {\n        select {\n        case v, ok := <-ch1:\n            if !ok {\n                ch1 = nil  // Disable this case\n                continue\n            }\n            fmt.Println(\"ch1:\", v)\n        case v, ok := <-ch2:\n            if !ok {\n                ch2 = nil  // Disable this case\n                continue\n            }\n            fmt.Println(\"ch2:\", v)\n        }\n    }\n}\n```\n\n## Sync Package\n\n### WaitGroup\n```go\nvar wg sync.WaitGroup\n\n// Basic usage\nfor i := 0; i < 5; i++ {\n    wg.Add(1)\n    go func(id int) {\n        defer wg.Done()\n        doWork(id)\n    }(i)\n}\nwg.Wait()\n\n// Reusable WaitGroup\ntype Task struct {\n    wg sync.WaitGroup\n}\n\nfunc (t *Task) Run(workers int) {\n    t.wg.Add(workers)\n    for i := 0; i < workers; i++ {\n        go t.worker(i)\n    }\n    t.wg.Wait()\n}\n\nfunc (t *Task) worker(id int) {\n    defer t.wg.Done()\n    // Do work\n}\n```\n\n### Mutex\n```go\n// Basic mutex\ntype Counter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.value++\n}\n\nfunc (c *Counter) Value() int {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    return c.value\n}\n\n// RWMutex for read-heavy workloads\ntype Cache struct {\n    mu    sync.RWMutex\n    data  map[string]string\n}\n\nfunc (c *Cache) Get(key string) (string, bool) {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    val, ok := c.data[key]\n    return val, ok\n}\n\nfunc (c *Cache) Set(key, value string) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.data[key] = value\n}\n\n// Mutex embedding pattern\ntype SafeMap struct {\n    sync.RWMutex\n    m map[string]int\n}\n\nfunc (sm *SafeMap) Load(key string) (int, bool) {\n    sm.RLock()\n    defer sm.RUnlock()\n    val, ok := sm.m[key]\n    return val, ok\n}\n```\n\n### Once\n```go\nvar once sync.Once\nvar instance *Singleton\n\ntype Singleton struct {\n    // fields\n}\n\nfunc GetInstance() *Singleton {\n    once.Do(func() {\n        instance = &Singleton{}\n        // Initialize\n    })\n    return instance\n}\n\n// Once for expensive initialization\ntype Service struct {\n    once   sync.Once\n    client *http.Client\n}\n\nfunc (s *Service) getClient() *http.Client {\n    s.once.Do(func() {\n        s.client = &http.Client{\n            Timeout: 30 * time.Second,\n            Transport: &http.Transport{\n                MaxIdleConns:    100,\n                IdleConnTimeout: 90 * time.Second,\n            },\n        }\n    })\n    return s.client\n}\n```\n\n### Cond\n```go\n// Condition variable for signaling\ntype Queue struct {\n    mu    sync.Mutex\n    cond  *sync.Cond\n    items []interface{}\n}\n\nfunc NewQueue() *Queue {\n    q := &Queue{}\n    q.cond = sync.NewCond(&q.mu)\n    return q\n}\n\nfunc (q *Queue) Put(item interface{}) {\n    q.mu.Lock()\n    defer q.mu.Unlock()\n    q.items = append(q.items, item)\n    q.cond.Signal()  // Wake one waiter\n}\n\nfunc (q *Queue) Get() interface{} {\n    q.mu.Lock()\n    defer q.mu.Unlock()\n    \n    for len(q.items) == 0 {\n        q.cond.Wait()  // Releases lock while waiting\n    }\n    \n    item := q.items[0]\n    q.items = q.items[1:]\n    return item\n}\n\n// Broadcast to all waiters\nfunc (q *Queue) Close() {\n    q.mu.Lock()\n    defer q.mu.Unlock()\n    q.cond.Broadcast()  // Wake all waiters\n}\n```\n\n### Pool\n```go\n// Object pool for reuse\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processData(data []byte) {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    // Process buffer\n}\n\n// Connection pool pattern\ntype ConnPool struct {\n    pool chan net.Conn\n}\n\nfunc NewConnPool(size int, dial func() (net.Conn, error)) (*ConnPool, error) {\n    pool := make(chan net.Conn, size)\n    for i := 0; i < size; i++ {\n        conn, err := dial()\n        if err != nil {\n            return nil, err\n        }\n        pool <- conn\n    }\n    return &ConnPool{pool: pool}, nil\n}\n\nfunc (p *ConnPool) Get() net.Conn {\n    return <-p.pool\n}\n\nfunc (p *ConnPool) Put(conn net.Conn) {\n    p.pool <- conn\n}\n```\n\n### Map (sync.Map)\n```go\n// Thread-safe map without explicit locking\nvar m sync.Map\n\n// Store\nm.Store(\"key\", \"value\")\nm.Store(123, \"numeric key\")\n\n// Load\nif val, ok := m.Load(\"key\"); ok {\n    fmt.Println(val.(string))\n}\n\n// LoadOrStore\nactual, loaded := m.LoadOrStore(\"key\", \"new value\")\nif loaded {\n    fmt.Println(\"Key existed:\", actual)\n}\n\n// Delete\nm.Delete(\"key\")\n\n// Range\nm.Range(func(key, value interface{}) bool {\n    fmt.Printf(\"%v: %v\\n\", key, value)\n    return true  // Continue iteration\n})\n\n// Use cases for sync.Map:\n// 1. Keys are written once but read many times\n// 2. Different goroutines read/write disjoint key sets\n// 3. When lock contention would be a problem\n```\n\n## Atomic Operations\n\n### Atomic Package\n```go\nimport \"sync/atomic\"\n\n// Atomic integers\nvar counter int64\n\natomic.AddInt64(&counter, 1)           // Increment\natomic.AddInt64(&counter, -1)          // Decrement\nval := atomic.LoadInt64(&counter)      // Read\natomic.StoreInt64(&counter, 100)       // Write\nold := atomic.SwapInt64(&counter, 200) // Swap\n\n// Compare and swap (CAS)\nif atomic.CompareAndSwapInt64(&counter, 100, 200) {\n    // Successfully changed from 100 to 200\n}\n\n// Atomic boolean using int32\ntype AtomicBool struct {\n    flag int32\n}\n\nfunc (b *AtomicBool) Set(value bool) {\n    var i int32\n    if value {\n        i = 1\n    }\n    atomic.StoreInt32(&b.flag, i)\n}\n\nfunc (b *AtomicBool) Get() bool {\n    return atomic.LoadInt32(&b.flag) != 0\n}\n\n// Atomic pointer\ntype Config struct {\n    // fields\n}\n\nvar config atomic.Value\n\n// Store new config\nconfig.Store(&Config{})\n\n// Load config\ncfg := config.Load().(*Config)\n\n// Atomic counter implementation\ntype Counter struct {\n    value int64\n}\n\nfunc (c *Counter) Inc() int64 {\n    return atomic.AddInt64(&c.value, 1)\n}\n\nfunc (c *Counter) Dec() int64 {\n    return atomic.AddInt64(&c.value, -1)\n}\n\nfunc (c *Counter) Value() int64 {\n    return atomic.LoadInt64(&c.value)\n}\n\nfunc (c *Counter) Reset() {\n    atomic.StoreInt64(&c.value, 0)\n}\n```\n\n### Atomic Patterns\n```go\n// Lock-free stack\ntype Stack struct {\n    head atomic.Value\n}\n\ntype node struct {\n    value interface{}\n    next  *node\n}\n\nfunc (s *Stack) Push(v interface{}) {\n    n := &node{value: v}\n    for {\n        head := s.head.Load()\n        if head != nil {\n            n.next = head.(*node)\n        }\n        if s.head.CompareAndSwap(head, n) {\n            return\n        }\n    }\n}\n\nfunc (s *Stack) Pop() interface{} {\n    for {\n        head := s.head.Load()\n        if head == nil {\n            return nil\n        }\n        n := head.(*node)\n        if s.head.CompareAndSwap(head, n.next) {\n            return n.value\n        }\n    }\n}\n\n// Atomic statistics collector\ntype Stats struct {\n    requests  int64\n    errors    int64\n    totalTime int64\n}\n\nfunc (s *Stats) RecordRequest(duration time.Duration, err error) {\n    atomic.AddInt64(&s.requests, 1)\n    atomic.AddInt64(&s.totalTime, int64(duration))\n    if err != nil {\n        atomic.AddInt64(&s.errors, 1)\n    }\n}\n\nfunc (s *Stats) Snapshot() (requests, errors, avgTime int64) {\n    requests = atomic.LoadInt64(&s.requests)\n    errors = atomic.LoadInt64(&s.errors)\n    totalTime := atomic.LoadInt64(&s.totalTime)\n    if requests > 0 {\n        avgTime = totalTime / requests\n    }\n    return\n}\n```\n\n## Concurrency Patterns\n\n### Worker Pool\n```go\ntype Job struct {\n    ID   int\n    Data string\n}\n\ntype Result struct {\n    JobID  int\n    Output string\n    Err    error\n}\n\nfunc workerPool(jobs <-chan Job, results chan<- Result, workers int) {\n    var wg sync.WaitGroup\n    \n    for i := 0; i < workers; i++ {\n        wg.Add(1)\n        go func(workerID int) {\n            defer wg.Done()\n            for job := range jobs {\n                output, err := processJob(job)\n                results <- Result{\n                    JobID:  job.ID,\n                    Output: output,\n                    Err:    err,\n                }\n            }\n        }(i)\n    }\n    \n    wg.Wait()\n    close(results)\n}\n\n// Usage\njobs := make(chan Job, 100)\nresults := make(chan Result, 100)\n\ngo workerPool(jobs, results, 10)\n\n// Send jobs\ngo func() {\n    for i := 0; i < 1000; i++ {\n        jobs <- Job{ID: i, Data: fmt.Sprintf(\"job-%d\", i)}\n    }\n    close(jobs)\n}()\n\n// Collect results\nfor result := range results {\n    if result.Err != nil {\n        log.Printf(\"Job %d failed: %v\", result.JobID, result.Err)\n    } else {\n        fmt.Printf(\"Job %d completed: %s\\n\", result.JobID, result.Output)\n    }\n}\n```\n\n### Rate Limiting\n```go\n// Simple rate limiter\nfunc rateLimiter() {\n    rate := time.Second / 10  // 10 requests per second\n    ticker := time.NewTicker(rate)\n    defer ticker.Stop()\n    \n    requests := make(chan int, 100)\n    \n    go func() {\n        for i := 0; i < 100; i++ {\n            requests <- i\n        }\n        close(requests)\n    }()\n    \n    for req := range requests {\n        <-ticker.C  // Wait for tick\n        go process(req)\n    }\n}\n\n// Token bucket rate limiter\ntype RateLimiter struct {\n    tokens chan struct{}\n}\n\nfunc NewRateLimiter(rate int, burst int) *RateLimiter {\n    rl := &RateLimiter{\n        tokens: make(chan struct{}, burst),\n    }\n    \n    // Fill bucket\n    for i := 0; i < burst; i++ {\n        rl.tokens <- struct{}{}\n    }\n    \n    // Refill tokens\n    go func() {\n        ticker := time.NewTicker(time.Second / time.Duration(rate))\n        defer ticker.Stop()\n        \n        for range ticker.C {\n            select {\n            case rl.tokens <- struct{}{}:\n            default:\n                // Bucket full\n            }\n        }\n    }()\n    \n    return rl\n}\n\nfunc (rl *RateLimiter) Allow() bool {\n    select {\n    case <-rl.tokens:\n        return true\n    default:\n        return false\n    }\n}\n\nfunc (rl *RateLimiter) Wait() {\n    <-rl.tokens\n}\n```\n\n### Circuit Breaker\n```go\ntype CircuitBreaker struct {\n    mu            sync.RWMutex\n    failures      int\n    lastFailTime  time.Time\n    state         string // \"closed\", \"open\", \"half-open\"\n    maxFailures   int\n    resetTimeout  time.Duration\n}\n\nfunc NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {\n    return &CircuitBreaker{\n        maxFailures:  maxFailures,\n        resetTimeout: resetTimeout,\n        state:        \"closed\",\n    }\n}\n\nfunc (cb *CircuitBreaker) Call(fn func() error) error {\n    cb.mu.RLock()\n    state := cb.state\n    cb.mu.RUnlock()\n    \n    if state == \"open\" {\n        cb.mu.RLock()\n        if time.Since(cb.lastFailTime) > cb.resetTimeout {\n            cb.mu.RUnlock()\n            cb.mu.Lock()\n            cb.state = \"half-open\"\n            cb.failures = 0\n            cb.mu.Unlock()\n        } else {\n            cb.mu.RUnlock()\n            return errors.New(\"circuit breaker is open\")\n        }\n    }\n    \n    err := fn()\n    \n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n    \n    if err != nil {\n        cb.failures++\n        cb.lastFailTime = time.Now()\n        \n        if cb.failures >= cb.maxFailures {\n            cb.state = \"open\"\n        }\n        return err\n    }\n    \n    if cb.state == \"half-open\" {\n        cb.state = \"closed\"\n    }\n    cb.failures = 0\n    return nil\n}\n```\n\n### Pub-Sub Pattern\n```go\ntype PubSub struct {\n    mu   sync.RWMutex\n    subs map[string][]chan interface{}\n}\n\nfunc NewPubSub() *PubSub {\n    return &PubSub{\n        subs: make(map[string][]chan interface{}),\n    }\n}\n\nfunc (ps *PubSub) Subscribe(topic string) <-chan interface{} {\n    ps.mu.Lock()\n    defer ps.mu.Unlock()\n    \n    ch := make(chan interface{}, 10)\n    ps.subs[topic] = append(ps.subs[topic], ch)\n    return ch\n}\n\nfunc (ps *PubSub) Publish(topic string, msg interface{}) {\n    ps.mu.RLock()\n    defer ps.mu.RUnlock()\n    \n    for _, ch := range ps.subs[topic] {\n        select {\n        case ch <- msg:\n        default:\n            // Subscriber is slow, skip\n        }\n    }\n}\n\nfunc (ps *PubSub) Unsubscribe(topic string, sub <-chan interface{}) {\n    ps.mu.Lock()\n    defer ps.mu.Unlock()\n    \n    subscribers := ps.subs[topic]\n    for i, ch := range subscribers {\n        if ch == sub {\n            close(ch)\n            ps.subs[topic] = append(subscribers[:i], subscribers[i+1:]...)\n            break\n        }\n    }\n}\n```\n\n## Context Package\n\n### Context Basics\n```go\n// Creating contexts\nctx := context.Background()  // Root context\nctx := context.TODO()        // When unsure what to use\n\n// With cancel\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()  // Always call cancel\n\n// With timeout\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\n// With deadline\ndeadline := time.Now().Add(5 * time.Second)\nctx, cancel := context.WithDeadline(context.Background(), deadline)\ndefer cancel()\n\n// With value\nctx := context.WithValue(context.Background(), \"userID\", 123)\n\n// Using context\nfunc doWork(ctx context.Context) error {\n    select {\n    case <-time.After(2 * time.Second):\n        return nil\n    case <-ctx.Done():\n        return ctx.Err()\n    }\n}\n\n// HTTP request with context\nfunc fetchData(ctx context.Context, url string) (*http.Response, error) {\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n    \n    return http.DefaultClient.Do(req)\n}\n```\n\n### Context Patterns\n```go\n// Propagating cancellation\nfunc pipeline(ctx context.Context) error {\n    ctx, cancel := context.WithCancel(ctx)\n    defer cancel()\n    \n    errc := make(chan error, 3)\n    \n    go func() {\n        errc <- stage1(ctx)\n    }()\n    \n    go func() {\n        errc <- stage2(ctx)\n    }()\n    \n    go func() {\n        errc <- stage3(ctx)\n    }()\n    \n    // Wait for first error or all complete\n    for i := 0; i < 3; i++ {\n        if err := <-errc; err != nil {\n            return err  // Cancel will stop other stages\n        }\n    }\n    \n    return nil\n}\n\n// Request scoped values\ntype contextKey string\n\nconst (\n    userIDKey contextKey = \"userID\"\n    traceIDKey contextKey = \"traceID\"\n)\n\nfunc WithUserID(ctx context.Context, userID string) context.Context {\n    return context.WithValue(ctx, userIDKey, userID)\n}\n\nfunc GetUserID(ctx context.Context) (string, bool) {\n    userID, ok := ctx.Value(userIDKey).(string)\n    return userID, ok\n}\n\n// Graceful shutdown\nfunc server(ctx context.Context) error {\n    srv := &http.Server{Addr: \":8080\"}\n    \n    go func() {\n        <-ctx.Done()\n        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n        defer cancel()\n        srv.Shutdown(shutdownCtx)\n    }()\n    \n    return srv.ListenAndServe()\n}\n```\n\n## Race Conditions\n\n### Detecting Race Conditions\n```go\n// Run with race detector: go run -race main.go\n// Test with race detector: go test -race ./...\n\n// Common race condition\ntype Counter struct {\n    value int  // Not protected!\n}\n\nfunc (c *Counter) Inc() {\n    c.value++  // Race condition!\n}\n\n// Fixed version\ntype SafeCounter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *SafeCounter) Inc() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.value++\n}\n\n// Race on map\nm := make(map[string]int)\n\ngo func() {\n    m[\"key\"] = 1  // Write\n}()\n\ngo func() {\n    _ = m[\"key\"]  // Read - RACE!\n}()\n\n// Race on slice append\nvar slice []int\n\ngo func() {\n    slice = append(slice, 1)  // Race!\n}()\n\ngo func() {\n    slice = append(slice, 2)  // Race!\n}()\n```\n\n### Preventing Race Conditions\n```go\n// Use channels instead of shared memory\ntype SafeCounter struct {\n    ch chan int\n}\n\nfunc NewSafeCounter() *SafeCounter {\n    c := &SafeCounter{\n        ch: make(chan int),\n    }\n    go c.run()\n    return c\n}\n\nfunc (c *SafeCounter) run() {\n    var value int\n    for delta := range c.ch {\n        value += delta\n    }\n}\n\nfunc (c *SafeCounter) Inc() {\n    c.ch <- 1\n}\n\n// Immutability pattern\ntype Config struct {\n    values map[string]string\n}\n\nfunc (c *Config) With(key, value string) *Config {\n    newValues := make(map[string]string)\n    for k, v := range c.values {\n        newValues[k] = v\n    }\n    newValues[key] = value\n    return &Config{values: newValues}\n}\n\n// Copy-on-write pattern\ntype Data struct {\n    mu    sync.RWMutex\n    items []Item\n}\n\nfunc (d *Data) Append(item Item) {\n    d.mu.Lock()\n    defer d.mu.Unlock()\n    \n    // Create new slice\n    newItems := make([]Item, len(d.items)+1)\n    copy(newItems, d.items)\n    newItems[len(newItems)-1] = item\n    d.items = newItems\n}\n\nfunc (d *Data) Items() []Item {\n    d.mu.RLock()\n    defer d.mu.RUnlock()\n    return d.items  // Safe because we copy on write\n}\n```\n\n## Deadlocks\n\n### Common Deadlock Patterns\n```go\n// Deadlock: Circular wait\nvar mu1, mu2 sync.Mutex\n\n// Goroutine 1\ngo func() {\n    mu1.Lock()\n    time.Sleep(10 * time.Millisecond)\n    mu2.Lock()  // Waits for mu2\n    // ...\n    mu2.Unlock()\n    mu1.Unlock()\n}()\n\n// Goroutine 2\ngo func() {\n    mu2.Lock()\n    time.Sleep(10 * time.Millisecond)\n    mu1.Lock()  // Waits for mu1 - DEADLOCK!\n    // ...\n    mu1.Unlock()\n    mu2.Unlock()\n}()\n\n// Fix: Always acquire locks in same order\nfunc transfer(from, to *Account, amount int) {\n    // Order accounts by ID to prevent deadlock\n    if from.ID < to.ID {\n        from.mu.Lock()\n        defer from.mu.Unlock()\n        to.mu.Lock()\n        defer to.mu.Unlock()\n    } else {\n        to.mu.Lock()\n        defer to.mu.Unlock()\n        from.mu.Lock()\n        defer from.mu.Unlock()\n    }\n    // Transfer logic\n}\n\n// Deadlock: Channel misuse\nch := make(chan int)\nch <- 42  // Blocks forever - no receiver!\n\n// Deadlock: Waiting for yourself\nch := make(chan int)\nval := <-ch  // Blocks forever\nch <- val    // Never reached\n\n// Deadlock: Select without default\nch1 := make(chan int)\nch2 := make(chan int)\n\nselect {\ncase <-ch1:\ncase <-ch2:\n// No default case - blocks forever if neither ready\n}\n```\n\n### Preventing Deadlocks\n```go\n// Use timeouts\nfunc safeLock(mu *sync.Mutex, timeout time.Duration) bool {\n    done := make(chan struct{})\n    go func() {\n        mu.Lock()\n        close(done)\n    }()\n    \n    select {\n    case <-done:\n        return true\n    case <-time.After(timeout):\n        return false\n    }\n}\n\n// Try-lock pattern\ntype TryMutex struct {\n    ch chan struct{}\n}\n\nfunc NewTryMutex() *TryMutex {\n    ch := make(chan struct{}, 1)\n    ch <- struct{}{}\n    return &TryMutex{ch: ch}\n}\n\nfunc (m *TryMutex) Lock() {\n    <-m.ch\n}\n\nfunc (m *TryMutex) Unlock() {\n    m.ch <- struct{}{}\n}\n\nfunc (m *TryMutex) TryLock() bool {\n    select {\n    case <-m.ch:\n        return true\n    default:\n        return false\n    }\n}\n\n// Deadlock detection\ntype DeadlockDetector struct {\n    mu       sync.Mutex\n    holding  map[string]string  // goroutine -> resource\n    waiting  map[string]string  // goroutine -> resource\n}\n\nfunc (d *DeadlockDetector) BeforeLock(goroutine, resource string) {\n    d.mu.Lock()\n    defer d.mu.Unlock()\n    \n    d.waiting[goroutine] = resource\n    // Check for cycle in wait graph\n    if d.hasCycle() {\n        panic(\"Potential deadlock detected!\")\n    }\n}\n\nfunc (d *DeadlockDetector) AfterLock(goroutine, resource string) {\n    d.mu.Lock()\n    defer d.mu.Unlock()\n    \n    delete(d.waiting, goroutine)\n    d.holding[goroutine] = resource\n}\n```\n\n## Performance and Optimization\n\n### Goroutine Performance\n```go\n// Limiting goroutines\nconst maxGoroutines = 100\nsem := make(chan struct{}, maxGoroutines)\n\nfor i := 0; i < 10000; i++ {\n    sem <- struct{}{}\n    go func(id int) {\n        defer func() { <-sem }()\n        process(id)\n    }(i)\n}\n\n// Reusing goroutines (worker pool)\ntype WorkerPool struct {\n    workers int\n    jobs    chan func()\n    wg      sync.WaitGroup\n}\n\nfunc NewWorkerPool(workers int) *WorkerPool {\n    pool := &WorkerPool{\n        workers: workers,\n        jobs:    make(chan func(), workers*2),\n    }\n    pool.start()\n    return pool\n}\n\nfunc (p *WorkerPool) start() {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go func() {\n            defer p.wg.Done()\n            for job := range p.jobs {\n                job()\n            }\n        }()\n    }\n}\n\nfunc (p *WorkerPool) Submit(job func()) {\n    p.jobs <- job\n}\n\nfunc (p *WorkerPool) Stop() {\n    close(p.jobs)\n    p.wg.Wait()\n}\n\n// Batching for efficiency\nfunc batchProcessor(items <-chan Item) {\n    batch := make([]Item, 0, 100)\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case item, ok := <-items:\n            if !ok {\n                if len(batch) > 0 {\n                    processBatch(batch)\n                }\n                return\n            }\n            batch = append(batch, item)\n            if len(batch) >= 100 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n        case <-ticker.C:\n            if len(batch) > 0 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n        }\n    }\n}\n```\n\n### Channel Performance\n```go\n// Buffered channels for performance\nch := make(chan int, 1000)  // Reduce blocking\n\n// Channel direction for optimization\nfunc producer() <-chan int {  // Read-only return\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < 100; i++ {\n            ch <- i\n        }\n    }()\n    return ch\n}\n\n// Avoid channel operations in hot paths\n// Bad:\nfor i := 0; i < 1000000; i++ {\n    ch <- i  // Channel operation in tight loop\n}\n\n// Good:\nbatch := make([]int, 0, 1000)\nfor i := 0; i < 1000000; i++ {\n    batch = append(batch, i)\n    if len(batch) >= 1000 {\n        ch <- batch\n        batch = make([]int, 0, 1000)\n    }\n}\n\n// Select with default for non-blocking\nselect {\ncase ch <- value:\n    // Sent\ndefault:\n    // Channel full, handle accordingly\n}\n```\n\n### Memory and Lock Optimization\n```go\n// Reduce lock contention with sharding\ntype ShardedMap struct {\n    shards [16]struct {\n        sync.RWMutex\n        m map[string]interface{}\n    }\n}\n\nfunc (sm *ShardedMap) getShard(key string) *struct {\n    sync.RWMutex\n    m map[string]interface{}\n} {\n    hash := fnv32(key)\n    return &sm.shards[hash%16]\n}\n\nfunc (sm *ShardedMap) Get(key string) (interface{}, bool) {\n    shard := sm.getShard(key)\n    shard.RLock()\n    defer shard.RUnlock()\n    val, ok := shard.m[key]\n    return val, ok\n}\n\n// Lock-free with atomic\ntype Config struct {\n    v atomic.Value\n}\n\nfunc (c *Config) Load() *ConfigData {\n    return c.v.Load().(*ConfigData)\n}\n\nfunc (c *Config) Store(cfg *ConfigData) {\n    c.v.Store(cfg)\n}\n\n// Reduce allocations\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 1024)\n    },\n}\n\nfunc process() {\n    buf := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buf)\n    // Use buf\n}\n```\n\n## Best Practices Summary\n\n1. **Start goroutines responsibly** - Always know how they'll stop\n2. **Don't leak goroutines** - Ensure cleanup with context or channels\n3. **Prefer channels over shared memory** - But use sync primitives when appropriate\n4. **Always handle context cancellation** - Check ctx.Done() in loops\n5. **Close channels from sender side only** - Never close from receiver\n6. **Use buffered channels thoughtfully** - Not just to \"fix\" synchronization\n7. **Protect shared state** - Use mutex, channels, or atomic operations\n8. **Run with -race during development** - Catch races early\n9. **Design for graceful shutdown** - Handle signals and cleanup\n10. **Profile before optimizing** - Measure, don't guess performance issues"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8289,"cache_read_input_tokens":38224,"output_tokens":11146,"service_tier":"standard"}},"requestId":"req_011CS5Hmu4CuuJ9tUqwZHr4L","type":"assistant","uuid":"1f1db1cb-4479-47c0-afaa-b8a604ce7d91","timestamp":"2025-08-13T07:14:20.514Z"}
{"parentUuid":"1f1db1cb-4479-47c0-afaa-b8a604ce7d91","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HV5eqNqMRpFuh1Lw1RprCs","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/go-concurrency.md"}]},"uuid":"f63c9fd4-a3e2-4a76-900a-f651652894d7","timestamp":"2025-08-13T07:14:20.570Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-concurrency.md","content":"# Go Concurrency - Mastering Concurrent Programming\n\n## Table of Contents\n1. [Goroutines](#goroutines)\n2. [Channels](#channels)\n3. [Select Statement](#select-statement)\n4. [Sync Package](#sync-package)\n5. [Atomic Operations](#atomic-operations)\n6. [Concurrency Patterns](#concurrency-patterns)\n7. [Context Package](#context-package)\n8. [Race Conditions](#race-conditions)\n9. [Deadlocks](#deadlocks)\n10. [Performance and Optimization](#performance-and-optimization)\n\n## Goroutines\n\n### Goroutine Basics\n```go\n// Starting a goroutine\ngo functionName()\ngo func() {\n    // Anonymous function as goroutine\n}()\n\n// Goroutines with parameters\ngo processItem(item)\n\n// Common mistake: loop variable capture\n// WRONG:\nfor _, item := range items {\n    go func() {\n        process(item)  // All goroutines get last item!\n    }()\n}\n\n// CORRECT:\nfor _, item := range items {\n    item := item  // Create new variable\n    go func() {\n        process(item)\n    }()\n}\n\n// Alternative: pass as parameter\nfor _, item := range items {\n    go func(i Item) {\n        process(i)\n    }(item)\n}\n\n// Waiting for goroutines to complete\nvar wg sync.WaitGroup\n\nfor i := 0; i < 10; i++ {\n    wg.Add(1)\n    go func(id int) {\n        defer wg.Done()\n        doWork(id)\n    }(i)\n}\n\nwg.Wait()  // Block until all complete\n\n// Goroutine lifecycle management\ntype Worker struct {\n    done chan struct{}\n}\n\nfunc (w *Worker) Start() {\n    go w.run()\n}\n\nfunc (w *Worker) run() {\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case <-ticker.C:\n            w.doWork()\n        case <-w.done:\n            return\n        }\n    }\n}\n\nfunc (w *Worker) Stop() {\n    close(w.done)\n}\n```\n\n### Goroutine Patterns\n```go\n// Limiting concurrent goroutines\nconst maxWorkers = 10\nsem := make(chan struct{}, maxWorkers)\n\nfor _, item := range items {\n    sem <- struct{}{}  // Acquire\n    go func(i Item) {\n        defer func() { <-sem }()  // Release\n        process(i)\n    }(item)\n}\n\n// Wait for all to complete\nfor i := 0; i < maxWorkers; i++ {\n    sem <- struct{}{}\n}\n\n// Error handling in goroutines\ntype Result struct {\n    Value interface{}\n    Err   error\n}\n\nresults := make(chan Result, len(items))\n\nfor _, item := range items {\n    go func(i Item) {\n        value, err := process(i)\n        results <- Result{Value: value, Err: err}\n    }(item)\n}\n\n// Collect results\nfor i := 0; i < len(items); i++ {\n    result := <-results\n    if result.Err != nil {\n        log.Printf(\"Error: %v\", result.Err)\n    }\n}\n\n// Goroutine pool pattern\ntype Pool struct {\n    work chan func()\n    wg   sync.WaitGroup\n}\n\nfunc NewPool(workers int) *Pool {\n    p := &Pool{\n        work: make(chan func(), 100),\n    }\n    \n    p.wg.Add(workers)\n    for i := 0; i < workers; i++ {\n        go p.worker()\n    }\n    \n    return p\n}\n\nfunc (p *Pool) worker() {\n    defer p.wg.Done()\n    for fn := range p.work {\n        fn()\n    }\n}\n\nfunc (p *Pool) Submit(fn func()) {\n    p.work <- fn\n}\n\nfunc (p *Pool) Shutdown() {\n    close(p.work)\n    p.wg.Wait()\n}\n```\n\n## Channels\n\n### Channel Basics\n```go\n// Creating channels\nch := make(chan int)       // Unbuffered\nch := make(chan int, 10)   // Buffered with capacity 10\n\n// Channel operations\nch <- 42        // Send\nvalue := <-ch   // Receive\nvalue, ok := <-ch  // Receive with closed check\n\n// Closing channels\nclose(ch)\n\n// Check if channel is closed\nif v, ok := <-ch; !ok {\n    // Channel is closed\n}\n\n// Directional channels\nfunc send(ch chan<- int) {  // Send-only\n    ch <- 42\n}\n\nfunc receive(ch <-chan int) {  // Receive-only\n    value := <-ch\n}\n\n// Channel zero value is nil\nvar ch chan int\n// ch <- 1  // Blocks forever!\n// <-ch     // Blocks forever!\n\n// Range over channel\nch := make(chan int)\ngo func() {\n    for i := 0; i < 5; i++ {\n        ch <- i\n    }\n    close(ch)\n}()\n\nfor value := range ch {\n    fmt.Println(value)\n}\n```\n\n### Buffered vs Unbuffered Channels\n```go\n// Unbuffered channels - synchronous\nch := make(chan int)\ngo func() {\n    ch <- 42  // Blocks until someone receives\n}()\nvalue := <-ch  // Blocks until someone sends\n\n// Buffered channels - asynchronous up to capacity\nch := make(chan int, 3)\nch <- 1  // Doesn't block\nch <- 2  // Doesn't block\nch <- 3  // Doesn't block\n// ch <- 4  // Would block!\n\n// Using buffered channels as semaphores\ntype Semaphore chan struct{}\n\nfunc NewSemaphore(n int) Semaphore {\n    return make(Semaphore, n)\n}\n\nfunc (s Semaphore) Acquire() {\n    s <- struct{}{}\n}\n\nfunc (s Semaphore) Release() {\n    <-s\n}\n\n// Channel of channels\ntype Request struct {\n    data  string\n    reply chan Response\n}\n\nrequests := make(chan Request)\n\n// Server\ngo func() {\n    for req := range requests {\n        response := processRequest(req.data)\n        req.reply <- response\n    }\n}()\n\n// Client\nreply := make(chan Response)\nrequests <- Request{data: \"hello\", reply: reply}\nresponse := <-reply\n```\n\n### Channel Patterns\n```go\n// Fan-in: Merge multiple channels\nfunc fanIn(channels ...<-chan int) <-chan int {\n    out := make(chan int)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan int) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n\n// Fan-out: Distribute work\nfunc fanOut(in <-chan int, workers int) []<-chan int {\n    channels := make([]<-chan int, workers)\n    \n    for i := 0; i < workers; i++ {\n        ch := make(chan int)\n        channels[i] = ch\n        \n        go func(out chan int) {\n            for val := range in {\n                out <- process(val)\n            }\n            close(out)\n        }(ch)\n    }\n    \n    return channels\n}\n\n// Pipeline pattern\nfunc pipeline() {\n    // Stage 1: Generate numbers\n    numbers := make(chan int)\n    go func() {\n        for i := 1; i <= 100; i++ {\n            numbers <- i\n        }\n        close(numbers)\n    }()\n    \n    // Stage 2: Square numbers\n    squares := make(chan int)\n    go func() {\n        for n := range numbers {\n            squares <- n * n\n        }\n        close(squares)\n    }()\n    \n    // Stage 3: Filter even\n    evens := make(chan int)\n    go func() {\n        for sq := range squares {\n            if sq%2 == 0 {\n                evens <- sq\n            }\n        }\n        close(evens)\n    }()\n    \n    // Consume\n    for even := range evens {\n        fmt.Println(even)\n    }\n}\n\n// Timeout pattern\nfunc timeoutExample() {\n    ch := make(chan string)\n    \n    go func() {\n        time.Sleep(2 * time.Second)\n        ch <- \"result\"\n    }()\n    \n    select {\n    case result := <-ch:\n        fmt.Println(\"Got:\", result)\n    case <-time.After(1 * time.Second):\n        fmt.Println(\"Timeout!\")\n    }\n}\n```\n\n## Select Statement\n\n### Select Basics\n```go\n// Basic select\nselect {\ncase v1 := <-ch1:\n    fmt.Println(\"Received from ch1:\", v1)\ncase v2 := <-ch2:\n    fmt.Println(\"Received from ch2:\", v2)\ncase ch3 <- 42:\n    fmt.Println(\"Sent to ch3\")\ndefault:\n    fmt.Println(\"No channels ready\")\n}\n\n// Non-blocking receive\nselect {\ncase msg := <-ch:\n    fmt.Println(\"Received:\", msg)\ndefault:\n    fmt.Println(\"No message available\")\n}\n\n// Non-blocking send\nselect {\ncase ch <- msg:\n    fmt.Println(\"Sent message\")\ndefault:\n    fmt.Println(\"Channel full or not ready\")\n}\n\n// Timeout with select\nselect {\ncase result := <-ch:\n    fmt.Println(\"Got result:\", result)\ncase <-time.After(5 * time.Second):\n    fmt.Println(\"Timeout after 5 seconds\")\n}\n\n// Ticker with select\nticker := time.NewTicker(1 * time.Second)\ndefer ticker.Stop()\n\ndone := make(chan bool)\ngo func() {\n    time.Sleep(5 * time.Second)\n    done <- true\n}()\n\nfor {\n    select {\n    case <-ticker.C:\n        fmt.Println(\"Tick\")\n    case <-done:\n        fmt.Println(\"Done!\")\n        return\n    }\n}\n```\n\n### Advanced Select Patterns\n```go\n// Priority select using default\nfunc prioritySelect(high, low <-chan int) int {\n    select {\n    case val := <-high:\n        return val\n    default:\n        select {\n        case val := <-high:\n            return val\n        case val := <-low:\n            return val\n        }\n    }\n}\n\n// Quit channel pattern\nfunc worker(work <-chan int, quit <-chan struct{}) {\n    for {\n        select {\n        case w := <-work:\n            process(w)\n        case <-quit:\n            cleanup()\n            return\n        }\n    }\n}\n\n// Multiple return channels\nfunc multiReturn() (chan int, chan error) {\n    results := make(chan int)\n    errors := make(chan error)\n    \n    go func() {\n        defer close(results)\n        defer close(errors)\n        \n        for i := 0; i < 10; i++ {\n            if i%3 == 0 {\n                errors <- fmt.Errorf(\"error at %d\", i)\n            } else {\n                results <- i * i\n            }\n        }\n    }()\n    \n    return results, errors\n}\n\n// Using nil channels in select\nfunc dynamicSelect() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    \n    go func() {\n        for i := 0; i < 5; i++ {\n            ch1 <- i\n            time.Sleep(100 * time.Millisecond)\n        }\n        close(ch1)\n    }()\n    \n    go func() {\n        for i := 5; i < 10; i++ {\n            ch2 <- i\n            time.Sleep(150 * time.Millisecond)\n        }\n        close(ch2)\n    }()\n    \n    for ch1 != nil || ch2 != nil {\n        select {\n        case v, ok := <-ch1:\n            if !ok {\n                ch1 = nil  // Disable this case\n                continue\n            }\n            fmt.Println(\"ch1:\", v)\n        case v, ok := <-ch2:\n            if !ok {\n                ch2 = nil  // Disable this case\n                continue\n            }\n            fmt.Println(\"ch2:\", v)\n        }\n    }\n}\n```\n\n## Sync Package\n\n### WaitGroup\n```go\nvar wg sync.WaitGroup\n\n// Basic usage\nfor i := 0; i < 5; i++ {\n    wg.Add(1)\n    go func(id int) {\n        defer wg.Done()\n        doWork(id)\n    }(i)\n}\nwg.Wait()\n\n// Reusable WaitGroup\ntype Task struct {\n    wg sync.WaitGroup\n}\n\nfunc (t *Task) Run(workers int) {\n    t.wg.Add(workers)\n    for i := 0; i < workers; i++ {\n        go t.worker(i)\n    }\n    t.wg.Wait()\n}\n\nfunc (t *Task) worker(id int) {\n    defer t.wg.Done()\n    // Do work\n}\n```\n\n### Mutex\n```go\n// Basic mutex\ntype Counter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.value++\n}\n\nfunc (c *Counter) Value() int {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    return c.value\n}\n\n// RWMutex for read-heavy workloads\ntype Cache struct {\n    mu    sync.RWMutex\n    data  map[string]string\n}\n\nfunc (c *Cache) Get(key string) (string, bool) {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    val, ok := c.data[key]\n    return val, ok\n}\n\nfunc (c *Cache) Set(key, value string) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.data[key] = value\n}\n\n// Mutex embedding pattern\ntype SafeMap struct {\n    sync.RWMutex\n    m map[string]int\n}\n\nfunc (sm *SafeMap) Load(key string) (int, bool) {\n    sm.RLock()\n    defer sm.RUnlock()\n    val, ok := sm.m[key]\n    return val, ok\n}\n```\n\n### Once\n```go\nvar once sync.Once\nvar instance *Singleton\n\ntype Singleton struct {\n    // fields\n}\n\nfunc GetInstance() *Singleton {\n    once.Do(func() {\n        instance = &Singleton{}\n        // Initialize\n    })\n    return instance\n}\n\n// Once for expensive initialization\ntype Service struct {\n    once   sync.Once\n    client *http.Client\n}\n\nfunc (s *Service) getClient() *http.Client {\n    s.once.Do(func() {\n        s.client = &http.Client{\n            Timeout: 30 * time.Second,\n            Transport: &http.Transport{\n                MaxIdleConns:    100,\n                IdleConnTimeout: 90 * time.Second,\n            },\n        }\n    })\n    return s.client\n}\n```\n\n### Cond\n```go\n// Condition variable for signaling\ntype Queue struct {\n    mu    sync.Mutex\n    cond  *sync.Cond\n    items []interface{}\n}\n\nfunc NewQueue() *Queue {\n    q := &Queue{}\n    q.cond = sync.NewCond(&q.mu)\n    return q\n}\n\nfunc (q *Queue) Put(item interface{}) {\n    q.mu.Lock()\n    defer q.mu.Unlock()\n    q.items = append(q.items, item)\n    q.cond.Signal()  // Wake one waiter\n}\n\nfunc (q *Queue) Get() interface{} {\n    q.mu.Lock()\n    defer q.mu.Unlock()\n    \n    for len(q.items) == 0 {\n        q.cond.Wait()  // Releases lock while waiting\n    }\n    \n    item := q.items[0]\n    q.items = q.items[1:]\n    return item\n}\n\n// Broadcast to all waiters\nfunc (q *Queue) Close() {\n    q.mu.Lock()\n    defer q.mu.Unlock()\n    q.cond.Broadcast()  // Wake all waiters\n}\n```\n\n### Pool\n```go\n// Object pool for reuse\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processData(data []byte) {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    // Process buffer\n}\n\n// Connection pool pattern\ntype ConnPool struct {\n    pool chan net.Conn\n}\n\nfunc NewConnPool(size int, dial func() (net.Conn, error)) (*ConnPool, error) {\n    pool := make(chan net.Conn, size)\n    for i := 0; i < size; i++ {\n        conn, err := dial()\n        if err != nil {\n            return nil, err\n        }\n        pool <- conn\n    }\n    return &ConnPool{pool: pool}, nil\n}\n\nfunc (p *ConnPool) Get() net.Conn {\n    return <-p.pool\n}\n\nfunc (p *ConnPool) Put(conn net.Conn) {\n    p.pool <- conn\n}\n```\n\n### Map (sync.Map)\n```go\n// Thread-safe map without explicit locking\nvar m sync.Map\n\n// Store\nm.Store(\"key\", \"value\")\nm.Store(123, \"numeric key\")\n\n// Load\nif val, ok := m.Load(\"key\"); ok {\n    fmt.Println(val.(string))\n}\n\n// LoadOrStore\nactual, loaded := m.LoadOrStore(\"key\", \"new value\")\nif loaded {\n    fmt.Println(\"Key existed:\", actual)\n}\n\n// Delete\nm.Delete(\"key\")\n\n// Range\nm.Range(func(key, value interface{}) bool {\n    fmt.Printf(\"%v: %v\\n\", key, value)\n    return true  // Continue iteration\n})\n\n// Use cases for sync.Map:\n// 1. Keys are written once but read many times\n// 2. Different goroutines read/write disjoint key sets\n// 3. When lock contention would be a problem\n```\n\n## Atomic Operations\n\n### Atomic Package\n```go\nimport \"sync/atomic\"\n\n// Atomic integers\nvar counter int64\n\natomic.AddInt64(&counter, 1)           // Increment\natomic.AddInt64(&counter, -1)          // Decrement\nval := atomic.LoadInt64(&counter)      // Read\natomic.StoreInt64(&counter, 100)       // Write\nold := atomic.SwapInt64(&counter, 200) // Swap\n\n// Compare and swap (CAS)\nif atomic.CompareAndSwapInt64(&counter, 100, 200) {\n    // Successfully changed from 100 to 200\n}\n\n// Atomic boolean using int32\ntype AtomicBool struct {\n    flag int32\n}\n\nfunc (b *AtomicBool) Set(value bool) {\n    var i int32\n    if value {\n        i = 1\n    }\n    atomic.StoreInt32(&b.flag, i)\n}\n\nfunc (b *AtomicBool) Get() bool {\n    return atomic.LoadInt32(&b.flag) != 0\n}\n\n// Atomic pointer\ntype Config struct {\n    // fields\n}\n\nvar config atomic.Value\n\n// Store new config\nconfig.Store(&Config{})\n\n// Load config\ncfg := config.Load().(*Config)\n\n// Atomic counter implementation\ntype Counter struct {\n    value int64\n}\n\nfunc (c *Counter) Inc() int64 {\n    return atomic.AddInt64(&c.value, 1)\n}\n\nfunc (c *Counter) Dec() int64 {\n    return atomic.AddInt64(&c.value, -1)\n}\n\nfunc (c *Counter) Value() int64 {\n    return atomic.LoadInt64(&c.value)\n}\n\nfunc (c *Counter) Reset() {\n    atomic.StoreInt64(&c.value, 0)\n}\n```\n\n### Atomic Patterns\n```go\n// Lock-free stack\ntype Stack struct {\n    head atomic.Value\n}\n\ntype node struct {\n    value interface{}\n    next  *node\n}\n\nfunc (s *Stack) Push(v interface{}) {\n    n := &node{value: v}\n    for {\n        head := s.head.Load()\n        if head != nil {\n            n.next = head.(*node)\n        }\n        if s.head.CompareAndSwap(head, n) {\n            return\n        }\n    }\n}\n\nfunc (s *Stack) Pop() interface{} {\n    for {\n        head := s.head.Load()\n        if head == nil {\n            return nil\n        }\n        n := head.(*node)\n        if s.head.CompareAndSwap(head, n.next) {\n            return n.value\n        }\n    }\n}\n\n// Atomic statistics collector\ntype Stats struct {\n    requests  int64\n    errors    int64\n    totalTime int64\n}\n\nfunc (s *Stats) RecordRequest(duration time.Duration, err error) {\n    atomic.AddInt64(&s.requests, 1)\n    atomic.AddInt64(&s.totalTime, int64(duration))\n    if err != nil {\n        atomic.AddInt64(&s.errors, 1)\n    }\n}\n\nfunc (s *Stats) Snapshot() (requests, errors, avgTime int64) {\n    requests = atomic.LoadInt64(&s.requests)\n    errors = atomic.LoadInt64(&s.errors)\n    totalTime := atomic.LoadInt64(&s.totalTime)\n    if requests > 0 {\n        avgTime = totalTime / requests\n    }\n    return\n}\n```\n\n## Concurrency Patterns\n\n### Worker Pool\n```go\ntype Job struct {\n    ID   int\n    Data string\n}\n\ntype Result struct {\n    JobID  int\n    Output string\n    Err    error\n}\n\nfunc workerPool(jobs <-chan Job, results chan<- Result, workers int) {\n    var wg sync.WaitGroup\n    \n    for i := 0; i < workers; i++ {\n        wg.Add(1)\n        go func(workerID int) {\n            defer wg.Done()\n            for job := range jobs {\n                output, err := processJob(job)\n                results <- Result{\n                    JobID:  job.ID,\n                    Output: output,\n                    Err:    err,\n                }\n            }\n        }(i)\n    }\n    \n    wg.Wait()\n    close(results)\n}\n\n// Usage\njobs := make(chan Job, 100)\nresults := make(chan Result, 100)\n\ngo workerPool(jobs, results, 10)\n\n// Send jobs\ngo func() {\n    for i := 0; i < 1000; i++ {\n        jobs <- Job{ID: i, Data: fmt.Sprintf(\"job-%d\", i)}\n    }\n    close(jobs)\n}()\n\n// Collect results\nfor result := range results {\n    if result.Err != nil {\n        log.Printf(\"Job %d failed: %v\", result.JobID, result.Err)\n    } else {\n        fmt.Printf(\"Job %d completed: %s\\n\", result.JobID, result.Output)\n    }\n}\n```\n\n### Rate Limiting\n```go\n// Simple rate limiter\nfunc rateLimiter() {\n    rate := time.Second / 10  // 10 requests per second\n    ticker := time.NewTicker(rate)\n    defer ticker.Stop()\n    \n    requests := make(chan int, 100)\n    \n    go func() {\n        for i := 0; i < 100; i++ {\n            requests <- i\n        }\n        close(requests)\n    }()\n    \n    for req := range requests {\n        <-ticker.C  // Wait for tick\n        go process(req)\n    }\n}\n\n// Token bucket rate limiter\ntype RateLimiter struct {\n    tokens chan struct{}\n}\n\nfunc NewRateLimiter(rate int, burst int) *RateLimiter {\n    rl := &RateLimiter{\n        tokens: make(chan struct{}, burst),\n    }\n    \n    // Fill bucket\n    for i := 0; i < burst; i++ {\n        rl.tokens <- struct{}{}\n    }\n    \n    // Refill tokens\n    go func() {\n        ticker := time.NewTicker(time.Second / time.Duration(rate))\n        defer ticker.Stop()\n        \n        for range ticker.C {\n            select {\n            case rl.tokens <- struct{}{}:\n            default:\n                // Bucket full\n            }\n        }\n    }()\n    \n    return rl\n}\n\nfunc (rl *RateLimiter) Allow() bool {\n    select {\n    case <-rl.tokens:\n        return true\n    default:\n        return false\n    }\n}\n\nfunc (rl *RateLimiter) Wait() {\n    <-rl.tokens\n}\n```\n\n### Circuit Breaker\n```go\ntype CircuitBreaker struct {\n    mu            sync.RWMutex\n    failures      int\n    lastFailTime  time.Time\n    state         string // \"closed\", \"open\", \"half-open\"\n    maxFailures   int\n    resetTimeout  time.Duration\n}\n\nfunc NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {\n    return &CircuitBreaker{\n        maxFailures:  maxFailures,\n        resetTimeout: resetTimeout,\n        state:        \"closed\",\n    }\n}\n\nfunc (cb *CircuitBreaker) Call(fn func() error) error {\n    cb.mu.RLock()\n    state := cb.state\n    cb.mu.RUnlock()\n    \n    if state == \"open\" {\n        cb.mu.RLock()\n        if time.Since(cb.lastFailTime) > cb.resetTimeout {\n            cb.mu.RUnlock()\n            cb.mu.Lock()\n            cb.state = \"half-open\"\n            cb.failures = 0\n            cb.mu.Unlock()\n        } else {\n            cb.mu.RUnlock()\n            return errors.New(\"circuit breaker is open\")\n        }\n    }\n    \n    err := fn()\n    \n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n    \n    if err != nil {\n        cb.failures++\n        cb.lastFailTime = time.Now()\n        \n        if cb.failures >= cb.maxFailures {\n            cb.state = \"open\"\n        }\n        return err\n    }\n    \n    if cb.state == \"half-open\" {\n        cb.state = \"closed\"\n    }\n    cb.failures = 0\n    return nil\n}\n```\n\n### Pub-Sub Pattern\n```go\ntype PubSub struct {\n    mu   sync.RWMutex\n    subs map[string][]chan interface{}\n}\n\nfunc NewPubSub() *PubSub {\n    return &PubSub{\n        subs: make(map[string][]chan interface{}),\n    }\n}\n\nfunc (ps *PubSub) Subscribe(topic string) <-chan interface{} {\n    ps.mu.Lock()\n    defer ps.mu.Unlock()\n    \n    ch := make(chan interface{}, 10)\n    ps.subs[topic] = append(ps.subs[topic], ch)\n    return ch\n}\n\nfunc (ps *PubSub) Publish(topic string, msg interface{}) {\n    ps.mu.RLock()\n    defer ps.mu.RUnlock()\n    \n    for _, ch := range ps.subs[topic] {\n        select {\n        case ch <- msg:\n        default:\n            // Subscriber is slow, skip\n        }\n    }\n}\n\nfunc (ps *PubSub) Unsubscribe(topic string, sub <-chan interface{}) {\n    ps.mu.Lock()\n    defer ps.mu.Unlock()\n    \n    subscribers := ps.subs[topic]\n    for i, ch := range subscribers {\n        if ch == sub {\n            close(ch)\n            ps.subs[topic] = append(subscribers[:i], subscribers[i+1:]...)\n            break\n        }\n    }\n}\n```\n\n## Context Package\n\n### Context Basics\n```go\n// Creating contexts\nctx := context.Background()  // Root context\nctx := context.TODO()        // When unsure what to use\n\n// With cancel\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()  // Always call cancel\n\n// With timeout\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\n// With deadline\ndeadline := time.Now().Add(5 * time.Second)\nctx, cancel := context.WithDeadline(context.Background(), deadline)\ndefer cancel()\n\n// With value\nctx := context.WithValue(context.Background(), \"userID\", 123)\n\n// Using context\nfunc doWork(ctx context.Context) error {\n    select {\n    case <-time.After(2 * time.Second):\n        return nil\n    case <-ctx.Done():\n        return ctx.Err()\n    }\n}\n\n// HTTP request with context\nfunc fetchData(ctx context.Context, url string) (*http.Response, error) {\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n    \n    return http.DefaultClient.Do(req)\n}\n```\n\n### Context Patterns\n```go\n// Propagating cancellation\nfunc pipeline(ctx context.Context) error {\n    ctx, cancel := context.WithCancel(ctx)\n    defer cancel()\n    \n    errc := make(chan error, 3)\n    \n    go func() {\n        errc <- stage1(ctx)\n    }()\n    \n    go func() {\n        errc <- stage2(ctx)\n    }()\n    \n    go func() {\n        errc <- stage3(ctx)\n    }()\n    \n    // Wait for first error or all complete\n    for i := 0; i < 3; i++ {\n        if err := <-errc; err != nil {\n            return err  // Cancel will stop other stages\n        }\n    }\n    \n    return nil\n}\n\n// Request scoped values\ntype contextKey string\n\nconst (\n    userIDKey contextKey = \"userID\"\n    traceIDKey contextKey = \"traceID\"\n)\n\nfunc WithUserID(ctx context.Context, userID string) context.Context {\n    return context.WithValue(ctx, userIDKey, userID)\n}\n\nfunc GetUserID(ctx context.Context) (string, bool) {\n    userID, ok := ctx.Value(userIDKey).(string)\n    return userID, ok\n}\n\n// Graceful shutdown\nfunc server(ctx context.Context) error {\n    srv := &http.Server{Addr: \":8080\"}\n    \n    go func() {\n        <-ctx.Done()\n        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n        defer cancel()\n        srv.Shutdown(shutdownCtx)\n    }()\n    \n    return srv.ListenAndServe()\n}\n```\n\n## Race Conditions\n\n### Detecting Race Conditions\n```go\n// Run with race detector: go run -race main.go\n// Test with race detector: go test -race ./...\n\n// Common race condition\ntype Counter struct {\n    value int  // Not protected!\n}\n\nfunc (c *Counter) Inc() {\n    c.value++  // Race condition!\n}\n\n// Fixed version\ntype SafeCounter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *SafeCounter) Inc() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.value++\n}\n\n// Race on map\nm := make(map[string]int)\n\ngo func() {\n    m[\"key\"] = 1  // Write\n}()\n\ngo func() {\n    _ = m[\"key\"]  // Read - RACE!\n}()\n\n// Race on slice append\nvar slice []int\n\ngo func() {\n    slice = append(slice, 1)  // Race!\n}()\n\ngo func() {\n    slice = append(slice, 2)  // Race!\n}()\n```\n\n### Preventing Race Conditions\n```go\n// Use channels instead of shared memory\ntype SafeCounter struct {\n    ch chan int\n}\n\nfunc NewSafeCounter() *SafeCounter {\n    c := &SafeCounter{\n        ch: make(chan int),\n    }\n    go c.run()\n    return c\n}\n\nfunc (c *SafeCounter) run() {\n    var value int\n    for delta := range c.ch {\n        value += delta\n    }\n}\n\nfunc (c *SafeCounter) Inc() {\n    c.ch <- 1\n}\n\n// Immutability pattern\ntype Config struct {\n    values map[string]string\n}\n\nfunc (c *Config) With(key, value string) *Config {\n    newValues := make(map[string]string)\n    for k, v := range c.values {\n        newValues[k] = v\n    }\n    newValues[key] = value\n    return &Config{values: newValues}\n}\n\n// Copy-on-write pattern\ntype Data struct {\n    mu    sync.RWMutex\n    items []Item\n}\n\nfunc (d *Data) Append(item Item) {\n    d.mu.Lock()\n    defer d.mu.Unlock()\n    \n    // Create new slice\n    newItems := make([]Item, len(d.items)+1)\n    copy(newItems, d.items)\n    newItems[len(newItems)-1] = item\n    d.items = newItems\n}\n\nfunc (d *Data) Items() []Item {\n    d.mu.RLock()\n    defer d.mu.RUnlock()\n    return d.items  // Safe because we copy on write\n}\n```\n\n## Deadlocks\n\n### Common Deadlock Patterns\n```go\n// Deadlock: Circular wait\nvar mu1, mu2 sync.Mutex\n\n// Goroutine 1\ngo func() {\n    mu1.Lock()\n    time.Sleep(10 * time.Millisecond)\n    mu2.Lock()  // Waits for mu2\n    // ...\n    mu2.Unlock()\n    mu1.Unlock()\n}()\n\n// Goroutine 2\ngo func() {\n    mu2.Lock()\n    time.Sleep(10 * time.Millisecond)\n    mu1.Lock()  // Waits for mu1 - DEADLOCK!\n    // ...\n    mu1.Unlock()\n    mu2.Unlock()\n}()\n\n// Fix: Always acquire locks in same order\nfunc transfer(from, to *Account, amount int) {\n    // Order accounts by ID to prevent deadlock\n    if from.ID < to.ID {\n        from.mu.Lock()\n        defer from.mu.Unlock()\n        to.mu.Lock()\n        defer to.mu.Unlock()\n    } else {\n        to.mu.Lock()\n        defer to.mu.Unlock()\n        from.mu.Lock()\n        defer from.mu.Unlock()\n    }\n    // Transfer logic\n}\n\n// Deadlock: Channel misuse\nch := make(chan int)\nch <- 42  // Blocks forever - no receiver!\n\n// Deadlock: Waiting for yourself\nch := make(chan int)\nval := <-ch  // Blocks forever\nch <- val    // Never reached\n\n// Deadlock: Select without default\nch1 := make(chan int)\nch2 := make(chan int)\n\nselect {\ncase <-ch1:\ncase <-ch2:\n// No default case - blocks forever if neither ready\n}\n```\n\n### Preventing Deadlocks\n```go\n// Use timeouts\nfunc safeLock(mu *sync.Mutex, timeout time.Duration) bool {\n    done := make(chan struct{})\n    go func() {\n        mu.Lock()\n        close(done)\n    }()\n    \n    select {\n    case <-done:\n        return true\n    case <-time.After(timeout):\n        return false\n    }\n}\n\n// Try-lock pattern\ntype TryMutex struct {\n    ch chan struct{}\n}\n\nfunc NewTryMutex() *TryMutex {\n    ch := make(chan struct{}, 1)\n    ch <- struct{}{}\n    return &TryMutex{ch: ch}\n}\n\nfunc (m *TryMutex) Lock() {\n    <-m.ch\n}\n\nfunc (m *TryMutex) Unlock() {\n    m.ch <- struct{}{}\n}\n\nfunc (m *TryMutex) TryLock() bool {\n    select {\n    case <-m.ch:\n        return true\n    default:\n        return false\n    }\n}\n\n// Deadlock detection\ntype DeadlockDetector struct {\n    mu       sync.Mutex\n    holding  map[string]string  // goroutine -> resource\n    waiting  map[string]string  // goroutine -> resource\n}\n\nfunc (d *DeadlockDetector) BeforeLock(goroutine, resource string) {\n    d.mu.Lock()\n    defer d.mu.Unlock()\n    \n    d.waiting[goroutine] = resource\n    // Check for cycle in wait graph\n    if d.hasCycle() {\n        panic(\"Potential deadlock detected!\")\n    }\n}\n\nfunc (d *DeadlockDetector) AfterLock(goroutine, resource string) {\n    d.mu.Lock()\n    defer d.mu.Unlock()\n    \n    delete(d.waiting, goroutine)\n    d.holding[goroutine] = resource\n}\n```\n\n## Performance and Optimization\n\n### Goroutine Performance\n```go\n// Limiting goroutines\nconst maxGoroutines = 100\nsem := make(chan struct{}, maxGoroutines)\n\nfor i := 0; i < 10000; i++ {\n    sem <- struct{}{}\n    go func(id int) {\n        defer func() { <-sem }()\n        process(id)\n    }(i)\n}\n\n// Reusing goroutines (worker pool)\ntype WorkerPool struct {\n    workers int\n    jobs    chan func()\n    wg      sync.WaitGroup\n}\n\nfunc NewWorkerPool(workers int) *WorkerPool {\n    pool := &WorkerPool{\n        workers: workers,\n        jobs:    make(chan func(), workers*2),\n    }\n    pool.start()\n    return pool\n}\n\nfunc (p *WorkerPool) start() {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go func() {\n            defer p.wg.Done()\n            for job := range p.jobs {\n                job()\n            }\n        }()\n    }\n}\n\nfunc (p *WorkerPool) Submit(job func()) {\n    p.jobs <- job\n}\n\nfunc (p *WorkerPool) Stop() {\n    close(p.jobs)\n    p.wg.Wait()\n}\n\n// Batching for efficiency\nfunc batchProcessor(items <-chan Item) {\n    batch := make([]Item, 0, 100)\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case item, ok := <-items:\n            if !ok {\n                if len(batch) > 0 {\n                    processBatch(batch)\n                }\n                return\n            }\n            batch = append(batch, item)\n            if len(batch) >= 100 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n        case <-ticker.C:\n            if len(batch) > 0 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n        }\n    }\n}\n```\n\n### Channel Performance\n```go\n// Buffered channels for performance\nch := make(chan int, 1000)  // Reduce blocking\n\n// Channel direction for optimization\nfunc producer() <-chan int {  // Read-only return\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < 100; i++ {\n            ch <- i\n        }\n    }()\n    return ch\n}\n\n// Avoid channel operations in hot paths\n// Bad:\nfor i := 0; i < 1000000; i++ {\n    ch <- i  // Channel operation in tight loop\n}\n\n// Good:\nbatch := make([]int, 0, 1000)\nfor i := 0; i < 1000000; i++ {\n    batch = append(batch, i)\n    if len(batch) >= 1000 {\n        ch <- batch\n        batch = make([]int, 0, 1000)\n    }\n}\n\n// Select with default for non-blocking\nselect {\ncase ch <- value:\n    // Sent\ndefault:\n    // Channel full, handle accordingly\n}\n```\n\n### Memory and Lock Optimization\n```go\n// Reduce lock contention with sharding\ntype ShardedMap struct {\n    shards [16]struct {\n        sync.RWMutex\n        m map[string]interface{}\n    }\n}\n\nfunc (sm *ShardedMap) getShard(key string) *struct {\n    sync.RWMutex\n    m map[string]interface{}\n} {\n    hash := fnv32(key)\n    return &sm.shards[hash%16]\n}\n\nfunc (sm *ShardedMap) Get(key string) (interface{}, bool) {\n    shard := sm.getShard(key)\n    shard.RLock()\n    defer shard.RUnlock()\n    val, ok := shard.m[key]\n    return val, ok\n}\n\n// Lock-free with atomic\ntype Config struct {\n    v atomic.Value\n}\n\nfunc (c *Config) Load() *ConfigData {\n    return c.v.Load().(*ConfigData)\n}\n\nfunc (c *Config) Store(cfg *ConfigData) {\n    c.v.Store(cfg)\n}\n\n// Reduce allocations\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 1024)\n    },\n}\n\nfunc process() {\n    buf := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buf)\n    // Use buf\n}\n```\n\n## Best Practices Summary\n\n1. **Start goroutines responsibly** - Always know how they'll stop\n2. **Don't leak goroutines** - Ensure cleanup with context or channels\n3. **Prefer channels over shared memory** - But use sync primitives when appropriate\n4. **Always handle context cancellation** - Check ctx.Done() in loops\n5. **Close channels from sender side only** - Never close from receiver\n6. **Use buffered channels thoughtfully** - Not just to \"fix\" synchronization\n7. **Protect shared state** - Use mutex, channels, or atomic operations\n8. **Run with -race during development** - Catch races early\n9. **Design for graceful shutdown** - Handle signals and cleanup\n10. **Profile before optimizing** - Measure, don't guess performance issues","structuredPatch":[]}}
{"parentUuid":"f63c9fd4-a3e2-4a76-900a-f651652894d7","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01FxxVLwvLEaLzwCiMPT9Kvz","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"## 3. Go Patterns"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":11187,"cache_read_input_tokens":46513,"output_tokens":13123,"service_tier":"standard"}},"requestId":"req_011CS5J86hFf92LuzxEFruCQ","type":"assistant","uuid":"9ce72650-1f26-4464-b53f-44f10730d34c","timestamp":"2025-08-13T07:14:23.963Z"}
{"parentUuid":"9ce72650-1f26-4464-b53f-44f10730d34c","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01FxxVLwvLEaLzwCiMPT9Kvz","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_011ayPVLQSEgMi84DexhQXzR","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-patterns.md","content":"# Go Design Patterns - Comprehensive Pattern Guide\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Concurrency Patterns](#concurrency-patterns)\n5. [Go Idioms](#go-idioms)\n6. [Functional Options](#functional-options)\n7. [Dependency Injection](#dependency-injection)\n8. [Error Handling Patterns](#error-handling-patterns)\n9. [Testing Patterns](#testing-patterns)\n10. [Performance Patterns](#performance-patterns)\n\n## Creational Patterns\n\n### Singleton\n```go\n// Thread-safe singleton using sync.Once\ntype singleton struct {\n    data string\n}\n\nvar (\n    instance *singleton\n    once     sync.Once\n)\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &singleton{\n            data: \"initialized\",\n        }\n    })\n    return instance\n}\n\n// Singleton with initialization parameters\ntype Database struct {\n    connection string\n}\n\nvar (\n    db     *Database\n    dbOnce sync.Once\n)\n\nfunc InitDatabase(conn string) *Database {\n    dbOnce.Do(func() {\n        db = &Database{\n            connection: conn,\n        }\n    })\n    return db\n}\n\nfunc GetDatabase() *Database {\n    if db == nil {\n        panic(\"database not initialized\")\n    }\n    return db\n}\n```\n\n### Factory\n```go\n// Simple factory\ntype StorageType int\n\nconst (\n    DiskStorage StorageType = iota\n    MemoryStorage\n    CloudStorage\n)\n\ntype Storage interface {\n    Save(data []byte) error\n    Load(id string) ([]byte, error)\n}\n\nfunc NewStorage(t StorageType) Storage {\n    switch t {\n    case DiskStorage:\n        return &diskStorage{}\n    case MemoryStorage:\n        return &memoryStorage{}\n    case CloudStorage:\n        return &cloudStorage{}\n    default:\n        return &memoryStorage{}\n    }\n}\n\n// Factory with registration\ntype Creator func() Storage\n\nvar creators = make(map[string]Creator)\n\nfunc RegisterStorage(name string, creator Creator) {\n    creators[name] = creator\n}\n\nfunc CreateStorage(name string) Storage {\n    creator, ok := creators[name]\n    if !ok {\n        return nil\n    }\n    return creator()\n}\n\n// Usage\nfunc init() {\n    RegisterStorage(\"s3\", func() Storage {\n        return &S3Storage{}\n    })\n    RegisterStorage(\"gcs\", func() Storage {\n        return &GCSStorage{}\n    })\n}\n```\n\n### Builder\n```go\n// Builder pattern for complex object construction\ntype Server struct {\n    host       string\n    port       int\n    timeout    time.Duration\n    maxConns   int\n    tls        bool\n    middleware []func(http.Handler) http.Handler\n}\n\ntype ServerBuilder struct {\n    server Server\n}\n\nfunc NewServerBuilder() *ServerBuilder {\n    return &ServerBuilder{\n        server: Server{\n            port:     8080,\n            timeout:  30 * time.Second,\n            maxConns: 100,\n        },\n    }\n}\n\nfunc (b *ServerBuilder) WithHost(host string) *ServerBuilder {\n    b.server.host = host\n    return b\n}\n\nfunc (b *ServerBuilder) WithPort(port int) *ServerBuilder {\n    b.server.port = port\n    return b\n}\n\nfunc (b *ServerBuilder) WithTimeout(timeout time.Duration) *ServerBuilder {\n    b.server.timeout = timeout\n    return b\n}\n\nfunc (b *ServerBuilder) WithTLS() *ServerBuilder {\n    b.server.tls = true\n    return b\n}\n\nfunc (b *ServerBuilder) WithMiddleware(mw func(http.Handler) http.Handler) *ServerBuilder {\n    b.server.middleware = append(b.server.middleware, mw)\n    return b\n}\n\nfunc (b *ServerBuilder) Build() *Server {\n    return &b.server\n}\n\n// Usage\nserver := NewServerBuilder().\n    WithHost(\"localhost\").\n    WithPort(9000).\n    WithTLS().\n    WithTimeout(60 * time.Second).\n    Build()\n```\n\n### Object Pool\n```go\n// Object pool for expensive resources\ntype Connection struct {\n    id   int\n    conn net.Conn\n}\n\ntype ConnectionPool struct {\n    mu       sync.Mutex\n    idle     []*Connection\n    active   map[int]*Connection\n    maxIdle  int\n    maxActive int\n    factory  func() (*Connection, error)\n}\n\nfunc NewConnectionPool(maxIdle, maxActive int, factory func() (*Connection, error)) *ConnectionPool {\n    return &ConnectionPool{\n        idle:      make([]*Connection, 0, maxIdle),\n        active:    make(map[int]*Connection),\n        maxIdle:   maxIdle,\n        maxActive: maxActive,\n        factory:   factory,\n    }\n}\n\nfunc (p *ConnectionPool) Get() (*Connection, error) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    \n    // Reuse idle connection\n    if len(p.idle) > 0 {\n        conn := p.idle[len(p.idle)-1]\n        p.idle = p.idle[:len(p.idle)-1]\n        p.active[conn.id] = conn\n        return conn, nil\n    }\n    \n    // Create new if under limit\n    if len(p.active) < p.maxActive {\n        conn, err := p.factory()\n        if err != nil {\n            return nil, err\n        }\n        p.active[conn.id] = conn\n        return conn, nil\n    }\n    \n    return nil, errors.New(\"pool exhausted\")\n}\n\nfunc (p *ConnectionPool) Put(conn *Connection) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    \n    delete(p.active, conn.id)\n    \n    if len(p.idle) < p.maxIdle {\n        p.idle = append(p.idle, conn)\n    } else {\n        // Close and discard\n        conn.conn.Close()\n    }\n}\n\n// sync.Pool for simple object pooling\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processData(data []byte) string {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    return buf.String()\n}\n```\n\n### Prototype\n```go\n// Prototype pattern for cloning objects\ntype Prototype interface {\n    Clone() Prototype\n}\n\ntype Document struct {\n    Title    string\n    Content  string\n    Metadata map[string]string\n}\n\nfunc (d *Document) Clone() Prototype {\n    // Deep copy\n    metadata := make(map[string]string)\n    for k, v := range d.Metadata {\n        metadata[k] = v\n    }\n    \n    return &Document{\n        Title:    d.Title,\n        Content:  d.Content,\n        Metadata: metadata,\n    }\n}\n\n// Prototype registry\ntype PrototypeRegistry struct {\n    prototypes map[string]Prototype\n}\n\nfunc (r *PrototypeRegistry) Register(name string, prototype Prototype) {\n    r.prototypes[name] = prototype\n}\n\nfunc (r *PrototypeRegistry) Create(name string) Prototype {\n    prototype, exists := r.prototypes[name]\n    if !exists {\n        return nil\n    }\n    return prototype.Clone()\n}\n```\n\n## Structural Patterns\n\n### Adapter\n```go\n// Adapter pattern to make incompatible interfaces work together\ntype OldPrinter interface {\n    PrintOldFormat(s string)\n}\n\ntype NewPrinter interface {\n    Print(d Document)\n}\n\ntype Document struct {\n    content string\n}\n\n// Adapter\ntype PrinterAdapter struct {\n    oldPrinter OldPrinter\n}\n\nfunc (a *PrinterAdapter) Print(d Document) {\n    a.oldPrinter.PrintOldFormat(d.content)\n}\n\n// Two-way adapter\ntype ModernAPI interface {\n    Request(ctx context.Context, data []byte) ([]byte, error)\n}\n\ntype LegacyAPI interface {\n    Call(data string) string\n}\n\ntype APIAdapter struct {\n    legacy LegacyAPI\n}\n\nfunc (a *APIAdapter) Request(ctx context.Context, data []byte) ([]byte, error) {\n    // Check context\n    select {\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    default:\n    }\n    \n    // Convert and call\n    result := a.legacy.Call(string(data))\n    return []byte(result), nil\n}\n\n// Adapt legacy to modern\ntype ReversAPIAdapter struct {\n    modern ModernAPI\n}\n\nfunc (a *ReversAPIAdapter) Call(data string) string {\n    ctx := context.Background()\n    result, err := a.modern.Request(ctx, []byte(data))\n    if err != nil {\n        return \"\"\n    }\n    return string(result)\n}\n```\n\n### Decorator\n```go\n// Decorator pattern for adding behavior\ntype Component interface {\n    Operation() string\n}\n\ntype ConcreteComponent struct{}\n\nfunc (c *ConcreteComponent) Operation() string {\n    return \"ConcreteComponent\"\n}\n\n// Base decorator\ntype Decorator struct {\n    component Component\n}\n\nfunc (d *Decorator) Operation() string {\n    return d.component.Operation()\n}\n\n// Concrete decorators\ntype LoggingDecorator struct {\n    Decorator\n    logger *log.Logger\n}\n\nfunc (d *LoggingDecorator) Operation() string {\n    result := d.component.Operation()\n    d.logger.Printf(\"Operation called, result: %s\", result)\n    return result\n}\n\ntype TimingDecorator struct {\n    Decorator\n}\n\nfunc (d *TimingDecorator) Operation() string {\n    start := time.Now()\n    result := d.component.Operation()\n    fmt.Printf(\"Operation took %v\\n\", time.Since(start))\n    return result\n}\n\n// HTTP middleware as decorator\ntype Middleware func(http.Handler) http.Handler\n\nfunc Logging(logger *log.Logger) Middleware {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            start := time.Now()\n            wrapped := &responseWriter{ResponseWriter: w}\n            next.ServeHTTP(wrapped, r)\n            logger.Printf(\"%s %s %d %v\", r.Method, r.URL.Path, wrapped.status, time.Since(start))\n        })\n    }\n}\n\nfunc RateLimit(limit int) Middleware {\n    limiter := rate.NewLimiter(rate.Limit(limit), 1)\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            if !limiter.Allow() {\n                http.Error(w, \"Rate limit exceeded\", http.StatusTooManyRequests)\n                return\n            }\n            next.ServeHTTP(w, r)\n        })\n    }\n}\n\n// Chain decorators\nfunc Chain(h http.Handler, middlewares ...Middleware) http.Handler {\n    for i := len(middlewares) - 1; i >= 0; i-- {\n        h = middlewares[i](h)\n    }\n    return h\n}\n```\n\n### Facade\n```go\n// Facade pattern for simplifying complex subsystems\ntype OrderFacade struct {\n    inventory *InventoryService\n    payment   *PaymentService\n    shipping  *ShippingService\n    email     *EmailService\n}\n\nfunc NewOrderFacade() *OrderFacade {\n    return &OrderFacade{\n        inventory: &InventoryService{},\n        payment:   &PaymentService{},\n        shipping:  &ShippingService{},\n        email:     &EmailService{},\n    }\n}\n\nfunc (f *OrderFacade) PlaceOrder(order Order) error {\n    // Check inventory\n    if err := f.inventory.CheckAvailability(order.Items); err != nil {\n        return fmt.Errorf(\"inventory check failed: %w\", err)\n    }\n    \n    // Process payment\n    if err := f.payment.ProcessPayment(order.Payment); err != nil {\n        return fmt.Errorf(\"payment failed: %w\", err)\n    }\n    \n    // Reserve inventory\n    if err := f.inventory.Reserve(order.Items); err != nil {\n        f.payment.Refund(order.Payment)\n        return fmt.Errorf(\"inventory reservation failed: %w\", err)\n    }\n    \n    // Schedule shipping\n    trackingNumber, err := f.shipping.Schedule(order.ShippingAddress)\n    if err != nil {\n        f.inventory.Release(order.Items)\n        f.payment.Refund(order.Payment)\n        return fmt.Errorf(\"shipping failed: %w\", err)\n    }\n    \n    // Send confirmation\n    f.email.SendConfirmation(order.Email, trackingNumber)\n    \n    return nil\n}\n```\n\n### Proxy\n```go\n// Proxy pattern for controlling access\ntype Image interface {\n    Display()\n}\n\ntype RealImage struct {\n    filename string\n    data     []byte\n}\n\nfunc NewRealImage(filename string) *RealImage {\n    return &RealImage{\n        filename: filename,\n        data:     loadFromDisk(filename),\n    }\n}\n\nfunc (i *RealImage) Display() {\n    fmt.Printf(\"Displaying %s\\n\", i.filename)\n}\n\n// Virtual proxy - lazy loading\ntype ImageProxy struct {\n    filename string\n    realImage *RealImage\n}\n\nfunc NewImageProxy(filename string) *ImageProxy {\n    return &ImageProxy{\n        filename: filename,\n    }\n}\n\nfunc (p *ImageProxy) Display() {\n    if p.realImage == nil {\n        p.realImage = NewRealImage(p.filename)\n    }\n    p.realImage.Display()\n}\n\n// Protection proxy\ntype SecureDocument interface {\n    Read(user User) (string, error)\n    Write(user User, content string) error\n}\n\ntype Document struct {\n    content string\n}\n\ntype SecureDocumentProxy struct {\n    document *Document\n    acl      map[string][]string // user -> permissions\n}\n\nfunc (p *SecureDocumentProxy) Read(user User) (string, error) {\n    if !p.hasPermission(user.Name, \"read\") {\n        return \"\", errors.New(\"access denied\")\n    }\n    return p.document.content, nil\n}\n\nfunc (p *SecureDocumentProxy) Write(user User, content string) error {\n    if !p.hasPermission(user.Name, \"write\") {\n        return errors.New(\"access denied\")\n    }\n    p.document.content = content\n    return nil\n}\n\nfunc (p *SecureDocumentProxy) hasPermission(user, permission string) bool {\n    perms, ok := p.acl[user]\n    if !ok {\n        return false\n    }\n    for _, p := range perms {\n        if p == permission {\n            return true\n        }\n    }\n    return false\n}\n\n// Caching proxy\ntype DataService interface {\n    GetData(id string) ([]byte, error)\n}\n\ntype CachingProxy struct {\n    service DataService\n    cache   map[string][]byte\n    mu      sync.RWMutex\n}\n\nfunc (p *CachingProxy) GetData(id string) ([]byte, error) {\n    // Check cache\n    p.mu.RLock()\n    if data, ok := p.cache[id]; ok {\n        p.mu.RUnlock()\n        return data, nil\n    }\n    p.mu.RUnlock()\n    \n    // Fetch from service\n    data, err := p.service.GetData(id)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Update cache\n    p.mu.Lock()\n    p.cache[id] = data\n    p.mu.Unlock()\n    \n    return data, nil\n}\n```\n\n### Bridge\n```go\n// Bridge pattern - separate abstraction from implementation\ntype Renderer interface {\n    RenderCircle(radius float64)\n    RenderSquare(side float64)\n}\n\ntype VectorRenderer struct{}\n\nfunc (v *VectorRenderer) RenderCircle(radius float64) {\n    fmt.Printf(\"Drawing circle with radius %f as vectors\\n\", radius)\n}\n\nfunc (v *VectorRenderer) RenderSquare(side float64) {\n    fmt.Printf(\"Drawing square with side %f as vectors\\n\", side)\n}\n\ntype RasterRenderer struct{}\n\nfunc (r *RasterRenderer) RenderCircle(radius float64) {\n    fmt.Printf(\"Drawing circle with radius %f as pixels\\n\", radius)\n}\n\nfunc (r *RasterRenderer) RenderSquare(side float64) {\n    fmt.Printf(\"Drawing square with side %f as pixels\\n\", side)\n}\n\n// Abstraction\ntype Shape interface {\n    Draw()\n    Resize(factor float64)\n}\n\ntype Circle struct {\n    renderer Renderer\n    radius   float64\n}\n\nfunc NewCircle(renderer Renderer, radius float64) *Circle {\n    return &Circle{\n        renderer: renderer,\n        radius:   radius,\n    }\n}\n\nfunc (c *Circle) Draw() {\n    c.renderer.RenderCircle(c.radius)\n}\n\nfunc (c *Circle) Resize(factor float64) {\n    c.radius *= factor\n}\n\ntype Square struct {\n    renderer Renderer\n    side     float64\n}\n\nfunc NewSquare(renderer Renderer, side float64) *Square {\n    return &Square{\n        renderer: renderer,\n        side:     side,\n    }\n}\n\nfunc (s *Square) Draw() {\n    s.renderer.RenderSquare(s.side)\n}\n\nfunc (s *Square) Resize(factor float64) {\n    s.side *= factor\n}\n```\n\n### Composite\n```go\n// Composite pattern for tree structures\ntype Component interface {\n    Operation() string\n}\n\ntype Leaf struct {\n    name string\n}\n\nfunc (l *Leaf) Operation() string {\n    return l.name\n}\n\ntype Composite struct {\n    children []Component\n}\n\nfunc (c *Composite) Add(component Component) {\n    c.children = append(c.children, component)\n}\n\nfunc (c *Composite) Remove(component Component) {\n    for i, child := range c.children {\n        if child == component {\n            c.children = append(c.children[:i], c.children[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (c *Composite) Operation() string {\n    var result []string\n    for _, child := range c.children {\n        result = append(result, child.Operation())\n    }\n    return strings.Join(result, \" + \")\n}\n\n// File system example\ntype FileSystemNode interface {\n    GetSize() int64\n    GetName() string\n}\n\ntype File struct {\n    name string\n    size int64\n}\n\nfunc (f *File) GetSize() int64 {\n    return f.size\n}\n\nfunc (f *File) GetName() string {\n    return f.name\n}\n\ntype Directory struct {\n    name     string\n    children []FileSystemNode\n}\n\nfunc (d *Directory) GetSize() int64 {\n    var total int64\n    for _, child := range d.children {\n        total += child.GetSize()\n    }\n    return total\n}\n\nfunc (d *Directory) GetName() string {\n    return d.name\n}\n\nfunc (d *Directory) Add(node FileSystemNode) {\n    d.children = append(d.children, node)\n}\n```\n\n## Behavioral Patterns\n\n### Strategy\n```go\n// Strategy pattern for interchangeable algorithms\ntype PaymentStrategy interface {\n    Pay(amount float64) error\n}\n\ntype CreditCard struct {\n    number string\n    cvv    string\n}\n\nfunc (c *CreditCard) Pay(amount float64) error {\n    fmt.Printf(\"Paying %.2f using credit card %s\\n\", amount, c.number)\n    return nil\n}\n\ntype PayPal struct {\n    email string\n}\n\nfunc (p *PayPal) Pay(amount float64) error {\n    fmt.Printf(\"Paying %.2f using PayPal account %s\\n\", amount, p.email)\n    return nil\n}\n\ntype Bitcoin struct {\n    walletAddress string\n}\n\nfunc (b *Bitcoin) Pay(amount float64) error {\n    fmt.Printf(\"Paying %.2f using Bitcoin wallet %s\\n\", amount, b.walletAddress)\n    return nil\n}\n\ntype PaymentProcessor struct {\n    strategy PaymentStrategy\n}\n\nfunc (p *PaymentProcessor) SetStrategy(strategy PaymentStrategy) {\n    p.strategy = strategy\n}\n\nfunc (p *PaymentProcessor) ProcessPayment(amount float64) error {\n    if p.strategy == nil {\n        return errors.New(\"payment strategy not set\")\n    }\n    return p.strategy.Pay(amount)\n}\n\n// Compression strategy example\ntype CompressionStrategy interface {\n    Compress(data []byte) []byte\n}\n\ntype GzipCompression struct{}\n\nfunc (g *GzipCompression) Compress(data []byte) []byte {\n    var buf bytes.Buffer\n    writer := gzip.NewWriter(&buf)\n    writer.Write(data)\n    writer.Close()\n    return buf.Bytes()\n}\n\ntype ZlibCompression struct{}\n\nfunc (z *ZlibCompression) Compress(data []byte) []byte {\n    var buf bytes.Buffer\n    writer := zlib.NewWriter(&buf)\n    writer.Write(data)\n    writer.Close()\n    return buf.Bytes()\n}\n\ntype Compressor struct {\n    strategy CompressionStrategy\n}\n\nfunc (c *Compressor) Compress(data []byte) []byte {\n    return c.strategy.Compress(data)\n}\n```\n\n### Observer\n```go\n// Observer pattern for event notification\ntype Observer interface {\n    Update(event interface{})\n}\n\ntype Subject interface {\n    Attach(Observer)\n    Detach(Observer)\n    Notify(event interface{})\n}\n\ntype ConcreteSubject struct {\n    observers []Observer\n    mu        sync.RWMutex\n}\n\nfunc (s *ConcreteSubject) Attach(observer Observer) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.observers = append(s.observers, observer)\n}\n\nfunc (s *ConcreteSubject) Detach(observer Observer) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    for i, o := range s.observers {\n        if o == observer {\n            s.observers = append(s.observers[:i], s.observers[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (s *ConcreteSubject) Notify(event interface{}) {\n    s.mu.RLock()\n    observers := make([]Observer, len(s.observers))\n    copy(observers, s.observers)\n    s.mu.RUnlock()\n    \n    for _, observer := range observers {\n        observer.Update(event)\n    }\n}\n\n// Event bus implementation\ntype EventBus struct {\n    mu        sync.RWMutex\n    listeners map[string][]chan interface{}\n}\n\nfunc NewEventBus() *EventBus {\n    return &EventBus{\n        listeners: make(map[string][]chan interface{}),\n    }\n}\n\nfunc (eb *EventBus) Subscribe(event string) <-chan interface{} {\n    eb.mu.Lock()\n    defer eb.mu.Unlock()\n    \n    ch := make(chan interface{}, 10)\n    eb.listeners[event] = append(eb.listeners[event], ch)\n    return ch\n}\n\nfunc (eb *EventBus) Publish(event string, data interface{}) {\n    eb.mu.RLock()\n    defer eb.mu.RUnlock()\n    \n    for _, ch := range eb.listeners[event] {\n        select {\n        case ch <- data:\n        default:\n            // Listener is slow, skip\n        }\n    }\n}\n\nfunc (eb *EventBus) Unsubscribe(event string, ch <-chan interface{}) {\n    eb.mu.Lock()\n    defer eb.mu.Unlock()\n    \n    listeners := eb.listeners[event]\n    for i, listener := range listeners {\n        if listener == ch {\n            close(listener)\n            eb.listeners[event] = append(listeners[:i], listeners[i+1:]...)\n            break\n        }\n    }\n}\n```\n\n### Command\n```go\n// Command pattern for encapsulating requests\ntype Command interface {\n    Execute() error\n    Undo() error\n}\n\n// Receiver\ntype Light struct {\n    isOn bool\n}\n\nfunc (l *Light) TurnOn() {\n    l.isOn = true\n    fmt.Println(\"Light is on\")\n}\n\nfunc (l *Light) TurnOff() {\n    l.isOn = false\n    fmt.Println(\"Light is off\")\n}\n\n// Concrete commands\ntype TurnOnCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOnCommand) Execute() error {\n    c.light.TurnOn()\n    return nil\n}\n\nfunc (c *TurnOnCommand) Undo() error {\n    c.light.TurnOff()\n    return nil\n}\n\ntype TurnOffCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOffCommand) Execute() error {\n    c.light.TurnOff()\n    return nil\n}\n\nfunc (c *TurnOffCommand) Undo() error {\n    c.light.TurnOn()\n    return nil\n}\n\n// Invoker with history\ntype RemoteControl struct {\n    commands []Command\n    history  []Command\n}\n\nfunc (r *RemoteControl) SetCommand(cmd Command) {\n    r.commands = append(r.commands, cmd)\n}\n\nfunc (r *RemoteControl) PressButton(index int) error {\n    if index >= len(r.commands) {\n        return errors.New(\"invalid button\")\n    }\n    cmd := r.commands[index]\n    if err := cmd.Execute(); err != nil {\n        return err\n    }\n    r.history = append(r.history, cmd)\n    return nil\n}\n\nfunc (r *RemoteControl) Undo() error {\n    if len(r.history) == 0 {\n        return errors.New(\"nothing to undo\")\n    }\n    cmd := r.history[len(r.history)-1]\n    r.history = r.history[:len(r.history)-1]\n    return cmd.Undo()\n}\n\n// Macro command\ntype MacroCommand struct {\n    commands []Command\n}\n\nfunc (m *MacroCommand) Execute() error {\n    for _, cmd := range m.commands {\n        if err := cmd.Execute(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc (m *MacroCommand) Undo() error {\n    // Undo in reverse order\n    for i := len(m.commands) - 1; i >= 0; i-- {\n        if err := m.commands[i].Undo(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n### Iterator\n```go\n// Iterator pattern for traversing collections\ntype Iterator interface {\n    HasNext() bool\n    Next() interface{}\n    Reset()\n}\n\ntype Collection interface {\n    CreateIterator() Iterator\n}\n\n// Concrete collection\ntype BookCollection struct {\n    books []string\n}\n\nfunc (c *BookCollection) CreateIterator() Iterator {\n    return &BookIterator{\n        collection: c,\n        index:      0,\n    }\n}\n\ntype BookIterator struct {\n    collection *BookCollection\n    index      int\n}\n\nfunc (i *BookIterator) HasNext() bool {\n    return i.index < len(i.collection.books)\n}\n\nfunc (i *BookIterator) Next() interface{} {\n    if i.HasNext() {\n        book := i.collection.books[i.index]\n        i.index++\n        return book\n    }\n    return nil\n}\n\nfunc (i *BookIterator) Reset() {\n    i.index = 0\n}\n\n// Generic iterator using channels\nfunc Iterate[T any](slice []T) <-chan T {\n    ch := make(chan T)\n    go func() {\n        defer close(ch)\n        for _, item := range slice {\n            ch <- item\n        }\n    }()\n    return ch\n}\n\n// Tree iterator\ntype TreeNode struct {\n    Value    int\n    Children []*TreeNode\n}\n\nfunc (n *TreeNode) DepthFirst() <-chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        n.depthFirstHelper(ch)\n    }()\n    return ch\n}\n\nfunc (n *TreeNode) depthFirstHelper(ch chan<- int) {\n    ch <- n.Value\n    for _, child := range n.Children {\n        child.depthFirstHelper(ch)\n    }\n}\n\nfunc (n *TreeNode) BreadthFirst() <-chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        queue := []*TreeNode{n}\n        for len(queue) > 0 {\n            node := queue[0]\n            queue = queue[1:]\n            ch <- node.Value\n            queue = append(queue, node.Children...)\n        }\n    }()\n    return ch\n}\n```\n\n### Chain of Responsibility\n```go\n// Chain of Responsibility pattern\ntype Handler interface {\n    SetNext(Handler) Handler\n    Handle(request interface{}) error\n}\n\ntype BaseHandler struct {\n    next Handler\n}\n\nfunc (h *BaseHandler) SetNext(next Handler) Handler {\n    h.next = next\n    return next\n}\n\nfunc (h *BaseHandler) Handle(request interface{}) error {\n    if h.next != nil {\n        return h.next.Handle(request)\n    }\n    return nil\n}\n\n// Concrete handlers\ntype AuthenticationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthenticationHandler) Handle(request interface{}) error {\n    req, ok := request.(*Request)\n    if !ok {\n        return errors.New(\"invalid request type\")\n    }\n    \n    if req.Token == \"\" {\n        return errors.New(\"authentication required\")\n    }\n    \n    fmt.Println(\"Authentication passed\")\n    return h.BaseHandler.Handle(request)\n}\n\ntype AuthorizationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthorizationHandler) Handle(request interface{}) error {\n    req, ok := request.(*Request)\n    if !ok {\n        return errors.New(\"invalid request type\")\n    }\n    \n    if !req.HasPermission {\n        return errors.New(\"insufficient permissions\")\n    }\n    \n    fmt.Println(\"Authorization passed\")\n    return h.BaseHandler.Handle(request)\n}\n\ntype ValidationHandler struct {\n    BaseHandler\n}\n\nfunc (h *ValidationHandler) Handle(request interface{}) error {\n    req, ok := request.(*Request)\n    if !ok {\n        return errors.New(\"invalid request type\")\n    }\n    \n    if req.Data == \"\" {\n        return errors.New(\"invalid data\")\n    }\n    \n    fmt.Println(\"Validation passed\")\n    return h.BaseHandler.Handle(request)\n}\n\n// Usage\nfunc setupChain() Handler {\n    auth := &AuthenticationHandler{}\n    authz := &AuthorizationHandler{}\n    valid := &ValidationHandler{}\n    \n    auth.SetNext(authz).SetNext(valid)\n    \n    return auth\n}\n```\n\n## Concurrency Patterns\n\n### Pipeline\n```go\n// Pipeline pattern for data processing\nfunc pipeline() {\n    // Stage 1: Generate numbers\n    numbers := generate(100)\n    \n    // Stage 2: Square numbers\n    squares := square(numbers)\n    \n    // Stage 3: Filter even\n    evens := filter(squares, func(n int) bool {\n        return n%2 == 0\n    })\n    \n    // Consume\n    for n := range evens {\n        fmt.Println(n)\n    }\n}\n\nfunc generate(max int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for i := 1; i <= max; i++ {\n            out <- i\n        }\n    }()\n    return out\n}\n\nfunc square(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            out <- n * n\n        }\n    }()\n    return out\n}\n\nfunc filter(in <-chan int, fn func(int) bool) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            if fn(n) {\n                out <- n\n            }\n        }\n    }()\n    return out\n}\n```\n\n### Fan-Out/Fan-In\n```go\n// Fan-out/Fan-in for parallel processing\nfunc fanOutFanIn() {\n    in := generate(100)\n    \n    // Fan-out to multiple workers\n    c1 := process(in)\n    c2 := process(in)\n    c3 := process(in)\n    \n    // Fan-in results\n    out := fanIn(c1, c2, c3)\n    \n    for result := range out {\n        fmt.Println(result)\n    }\n}\n\nfunc process(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            out <- n * 2 // Some processing\n            time.Sleep(time.Millisecond) // Simulate work\n        }\n    }()\n    return out\n}\n\nfunc fanIn(channels ...<-chan int) <-chan int {\n    out := make(chan int)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan int) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n```\n\n### Worker Pool\n```go\n// Worker pool for controlled concurrency\ntype WorkerPool struct {\n    maxWorkers int\n    jobQueue   chan Job\n    workerPool chan chan Job\n    workers    []*Worker\n    wg         sync.WaitGroup\n}\n\ntype Job interface {\n    Process() error\n}\n\ntype Worker struct {\n    id         int\n    jobChannel chan Job\n    workerPool chan chan Job\n    quit       chan bool\n}\n\nfunc NewWorkerPool(maxWorkers int) *WorkerPool {\n    pool := &WorkerPool{\n        maxWorkers: maxWorkers,\n        jobQueue:   make(chan Job),\n        workerPool: make(chan chan Job, maxWorkers),\n    }\n    \n    pool.workers = make([]*Worker, maxWorkers)\n    for i := 0; i < maxWorkers; i++ {\n        worker := NewWorker(i, pool.workerPool)\n        pool.workers[i] = worker\n        worker.Start()\n    }\n    \n    go pool.dispatch()\n    \n    return pool\n}\n\nfunc (p *WorkerPool) dispatch() {\n    for job := range p.jobQueue {\n        jobChannel := <-p.workerPool\n        jobChannel <- job\n    }\n}\n\nfunc (p *WorkerPool) Submit(job Job) {\n    p.jobQueue <- job\n}\n\nfunc (p *WorkerPool) Shutdown() {\n    close(p.jobQueue)\n    for _, worker := range p.workers {\n        worker.Stop()\n    }\n}\n\nfunc NewWorker(id int, workerPool chan chan Job) *Worker {\n    return &Worker{\n        id:         id,\n        jobChannel: make(chan Job),\n        workerPool: workerPool,\n        quit:       make(chan bool),\n    }\n}\n\nfunc (w *Worker) Start() {\n    go func() {\n        for {\n            w.workerPool <- w.jobChannel\n            \n            select {\n            case job := <-w.jobChannel:\n                if err := job.Process(); err != nil {\n                    fmt.Printf(\"Worker %d error: %v\\n\", w.id, err)\n                }\n            case <-w.quit:\n                return\n            }\n        }\n    }()\n}\n\nfunc (w *Worker) Stop() {\n    close(w.quit)\n}\n```\n\n## Go Idioms\n\n### Accept Interfaces, Return Structs\n```go\n// Good: Accept interface\nfunc ProcessData(r io.Reader) error {\n    data, err := io.ReadAll(r)\n    if err != nil {\n        return err\n    }\n    // Process data\n    return nil\n}\n\n// Good: Return concrete type\nfunc NewBuffer() *bytes.Buffer {\n    return &bytes.Buffer{}\n}\n\n// Usage is flexible\nProcessData(os.Stdin)\nProcessData(NewBuffer())\nProcessData(strings.NewReader(\"test\"))\n```\n\n### Embedding for Composition\n```go\n// Embedding interfaces\ntype ReadWriter interface {\n    io.Reader\n    io.Writer\n}\n\n// Embedding structs\ntype Server struct {\n    http.Server       // Embed standard server\n    logger *log.Logger\n    config *Config\n}\n\nfunc (s *Server) Start() error {\n    s.logger.Println(\"Starting server\")\n    return s.ListenAndServe() // Call embedded method\n}\n\n// Method promotion\ntype Document struct {\n    *bytes.Buffer // Embed pointer\n    metadata map[string]string\n}\n\nfunc NewDocument() *Document {\n    return &Document{\n        Buffer:   new(bytes.Buffer),\n        metadata: make(map[string]string),\n    }\n}\n\n// Buffer methods are promoted\ndoc := NewDocument()\ndoc.WriteString(\"Hello\") // Calls Buffer.WriteString\n```\n\n### Table-Driven Tests\n```go\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name string\n        a, b int\n        want int\n    }{\n        {\"positive\", 2, 3, 5},\n        {\"negative\", -2, -3, -5},\n        {\"mixed\", -2, 3, 1},\n        {\"zero\", 0, 0, 0},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := Add(tt.a, tt.b); got != tt.want {\n                t.Errorf(\"Add(%d, %d) = %d, want %d\", tt.a, tt.b, got, tt.want)\n            }\n        })\n    }\n}\n```\n\n### Named Results for Documentation\n```go\n// Named results clarify what function returns\nfunc ParseConfig(data []byte) (config *Config, warnings []string, err error) {\n    config = &Config{}\n    \n    if err = json.Unmarshal(data, config); err != nil {\n        return nil, nil, fmt.Errorf(\"invalid JSON: %w\", err)\n    }\n    \n    if config.Timeout == 0 {\n        warnings = append(warnings, \"timeout not set, using default\")\n        config.Timeout = 30 * time.Second\n    }\n    \n    return config, warnings, nil\n}\n```\n\n## Functional Options\n\n### Options Pattern\n```go\n// Functional options for flexible APIs\ntype Server struct {\n    host     string\n    port     int\n    timeout  time.Duration\n    maxConns int\n    tls      bool\n}\n\ntype Option func(*Server)\n\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = timeout\n    }\n}\n\nfunc WithTLS(certFile, keyFile string) Option {\n    return func(s *Server) {\n        s.tls = true\n        // Configure TLS\n    }\n}\n\nfunc WithMaxConnections(max int) Option {\n    return func(s *Server) {\n        s.maxConns = max\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    // Defaults\n    s := &Server{\n        host:     \"localhost\",\n        port:     8080,\n        timeout:  30 * time.Second,\n        maxConns: 100,\n    }\n    \n    // Apply options\n    for _, opt := range opts {\n        opt(s)\n    }\n    \n    return s\n}\n\n// Clean usage\nserver := NewServer(\n    WithHost(\"0.0.0.0\"),\n    WithPort(9000),\n    WithTimeout(60*time.Second),\n    WithTLS(\"cert.pem\", \"key.pem\"),\n)\n\n// Option validation\nfunc WithPort(port int) Option {\n    return func(s *Server) error {\n        if port <= 0 || port > 65535 {\n            return fmt.Errorf(\"invalid port: %d\", port)\n        }\n        s.port = port\n        return nil\n    }\n}\n\n// Options with error handling\ntype OptionWithError func(*Server) error\n\nfunc NewServerWithValidation(opts ...OptionWithError) (*Server, error) {\n    s := &Server{\n        // defaults\n    }\n    \n    for _, opt := range opts {\n        if err := opt(s); err != nil {\n            return nil, err\n        }\n    }\n    \n    return s, nil\n}\n```\n\n## Dependency Injection\n\n### Constructor Injection\n```go\n// Constructor injection for explicit dependencies\ntype Service struct {\n    logger *log.Logger\n    db     *sql.DB\n    cache  Cache\n    config *Config\n}\n\nfunc NewService(logger *log.Logger, db *sql.DB, cache Cache, config *Config) *Service {\n    return &Service{\n        logger: logger,\n        db:     db,\n        cache:  cache,\n        config: config,\n    }\n}\n\n// Interface injection for testability\ntype UserRepository interface {\n    GetUser(id int) (*User, error)\n    SaveUser(user *User) error\n}\n\ntype UserService struct {\n    repo   UserRepository\n    logger *log.Logger\n}\n\nfunc NewUserService(repo UserRepository, logger *log.Logger) *UserService {\n    return &UserService{\n        repo:   repo,\n        logger: logger,\n    }\n}\n```\n\n### Wire for Dependency Injection\n```go\n// wire.go\n//go:build wireinject\n\npackage main\n\nimport \"github.com/google/wire\"\n\nfunc InitializeApp() (*App, error) {\n    wire.Build(\n        NewConfig,\n        NewLogger,\n        NewDatabase,\n        NewCache,\n        NewUserRepository,\n        NewUserService,\n        NewApp,\n    )\n    return nil, nil\n}\n\n// Providers\nfunc NewConfig() *Config {\n    return &Config{} // Load from environment\n}\n\nfunc NewLogger(cfg *Config) *log.Logger {\n    return log.New(os.Stdout, cfg.LogPrefix, log.LstdFlags)\n}\n\nfunc NewDatabase(cfg *Config) (*sql.DB, error) {\n    return sql.Open(\"postgres\", cfg.DatabaseURL)\n}\n\nfunc NewCache(cfg *Config) Cache {\n    return NewRedisCache(cfg.RedisURL)\n}\n\nfunc NewUserRepository(db *sql.DB) UserRepository {\n    return &SQLUserRepository{db: db}\n}\n\nfunc NewUserService(repo UserRepository, logger *log.Logger, cache Cache) *UserService {\n    return &UserService{\n        repo:   repo,\n        logger: logger,\n        cache:  cache,\n    }\n}\n\nfunc NewApp(service *UserService) *App {\n    return &App{\n        service: service,\n    }\n}\n```\n\n## Error Handling Patterns\n\n### Error Types\n```go\n// Sentinel errors\nvar (\n    ErrNotFound   = errors.New(\"not found\")\n    ErrUnauthorized = errors.New(\"unauthorized\")\n    ErrInternal   = errors.New(\"internal error\")\n)\n\n// Error types\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error on field %s: %s\", e.Field, e.Message)\n}\n\n// Wrapped errors\nfunc processFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return fmt.Errorf(\"failed to open file %s: %w\", filename, err)\n    }\n    defer file.Close()\n    \n    data, err := io.ReadAll(file)\n    if err != nil {\n        return fmt.Errorf(\"failed to read file %s: %w\", filename, err)\n    }\n    \n    if err := processData(data); err != nil {\n        return fmt.Errorf(\"failed to process data from %s: %w\", filename, err)\n    }\n    \n    return nil\n}\n\n// Error checking\nfunc handleError(err error) {\n    if errors.Is(err, ErrNotFound) {\n        // Handle not found\n    }\n    \n    var validationErr ValidationError\n    if errors.As(err, &validationErr) {\n        // Handle validation error\n        fmt.Printf(\"Field %s failed validation\\n\", validationErr.Field)\n    }\n}\n```\n\n### Error Collection\n```go\n// Multiple error handling\ntype ErrorCollector struct {\n    mu     sync.Mutex\n    errors []error\n}\n\nfunc (c *ErrorCollector) Add(err error) {\n    if err == nil {\n        return\n    }\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.errors = append(c.errors, err)\n}\n\nfunc (c *ErrorCollector) Error() error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    if len(c.errors) == 0 {\n        return nil\n    }\n    \n    if len(c.errors) == 1 {\n        return c.errors[0]\n    }\n    \n    return fmt.Errorf(\"multiple errors occurred: %v\", c.errors)\n}\n\n// Usage with goroutines\nfunc processItems(items []Item) error {\n    var wg sync.WaitGroup\n    collector := &ErrorCollector{}\n    \n    for _, item := range items {\n        wg.Add(1)\n        go func(i Item) {\n            defer wg.Done()\n            if err := process(i); err != nil {\n                collector.Add(fmt.Errorf(\"item %v: %w\", i.ID, err))\n            }\n        }(item)\n    }\n    \n    wg.Wait()\n    return collector.Error()\n}\n```\n\n## Testing Patterns\n\n### Test Fixtures\n```go\n// Test fixtures for consistent test data\ntype Fixtures struct {\n    Users    []*User\n    Products []*Product\n    Orders   []*Order\n}\n\nfunc NewFixtures() *Fixtures {\n    return &Fixtures{\n        Users: []*User{\n            {ID: 1, Name: \"Alice\", Email: \"alice@example.com\"},\n            {ID: 2, Name: \"Bob\", Email: \"bob@example.com\"},\n        },\n        Products: []*Product{\n            {ID: 1, Name: \"Widget\", Price: 9.99},\n            {ID: 2, Name: \"Gadget\", Price: 19.99},\n        },\n    }\n}\n\n// Golden files for snapshot testing\nfunc TestRender(t *testing.T) {\n    data := getData()\n    output := Render(data)\n    \n    golden := filepath.Join(\"testdata\", t.Name()+\".golden\")\n    \n    if *update {\n        os.WriteFile(golden, []byte(output), 0644)\n    }\n    \n    expected, err := os.ReadFile(golden)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if output != string(expected) {\n        t.Errorf(\"output mismatch:\\ngot:\\n%s\\nwant:\\n%s\", output, expected)\n    }\n}\n```\n\n### Test Helpers\n```go\n// Test helpers for common operations\nfunc setupTest(t *testing.T) (*sql.DB, func()) {\n    t.Helper()\n    \n    db, err := sql.Open(\"sqlite3\", \":memory:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if err := migrate(db); err != nil {\n        t.Fatal(err)\n    }\n    \n    cleanup := func() {\n        db.Close()\n    }\n    \n    return db, cleanup\n}\n\n// Usage\nfunc TestUserRepository(t *testing.T) {\n    db, cleanup := setupTest(t)\n    defer cleanup()\n    \n    repo := NewUserRepository(db)\n    // Test repository\n}\n\n// Test server\nfunc setupTestServer(t *testing.T, handler http.Handler) *httptest.Server {\n    t.Helper()\n    server := httptest.NewServer(handler)\n    t.Cleanup(server.Close)\n    return server\n}\n```\n\n## Performance Patterns\n\n### Object Pooling\n```go\n// Sync.Pool for reducing allocations\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processRequest(data []byte) string {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    // Process\n    return buf.String()\n}\n```\n\n### Lazy Initialization\n```go\n// Lazy loading with sync.Once\ntype ExpensiveResource struct {\n    once sync.Once\n    data *Data\n}\n\nfunc (r *ExpensiveResource) Get() *Data {\n    r.once.Do(func() {\n        r.data = loadExpensiveData()\n    })\n    return r.data\n}\n```\n\n### Copy-on-Write\n```go\n// Copy-on-write for concurrent access\ntype COWMap struct {\n    mu   sync.RWMutex\n    data map[string]interface{}\n}\n\nfunc (m *COWMap) Get(key string) (interface{}, bool) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    val, ok := m.data[key]\n    return val, ok\n}\n\nfunc (m *COWMap) Set(key string, value interface{}) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    \n    // Copy on write\n    newData := make(map[string]interface{}, len(m.data)+1)\n    for k, v := range m.data {\n        newData[k] = v\n    }\n    newData[key] = value\n    m.data = newData\n}\n```\n\n## Best Practices Summary\n\n1. **Prefer composition over inheritance** - Use embedding and interfaces\n2. **Keep interfaces small** - Single responsibility\n3. **Accept interfaces, return structs** - Maximum flexibility\n4. **Use functional options** - For optional parameters\n5. **Constructor injection** - For required dependencies\n6. **Table-driven tests** - For comprehensive testing\n7. **Error wrapping** - Maintain error context\n8. **Channels for communication** - Between goroutines\n9. **Context for cancellation** - And request-scoped values\n10. **Profile before optimizing** - Measure performance impacts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":11187,"cache_read_input_tokens":46513,"output_tokens":13123,"service_tier":"standard"}},"requestId":"req_011CS5J86hFf92LuzxEFruCQ","type":"assistant","uuid":"ff1aa17c-95ac-474a-bf9c-8e0de02916e1","timestamp":"2025-08-13T07:19:53.471Z"}
{"parentUuid":"ff1aa17c-95ac-474a-bf9c-8e0de02916e1","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011ayPVLQSEgMi84DexhQXzR","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/go-patterns.md"}]},"uuid":"c6569f7d-b89a-41c6-9251-b9bf90ffa1eb","timestamp":"2025-08-13T07:19:53.520Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-patterns.md","content":"# Go Design Patterns - Comprehensive Pattern Guide\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Concurrency Patterns](#concurrency-patterns)\n5. [Go Idioms](#go-idioms)\n6. [Functional Options](#functional-options)\n7. [Dependency Injection](#dependency-injection)\n8. [Error Handling Patterns](#error-handling-patterns)\n9. [Testing Patterns](#testing-patterns)\n10. [Performance Patterns](#performance-patterns)\n\n## Creational Patterns\n\n### Singleton\n```go\n// Thread-safe singleton using sync.Once\ntype singleton struct {\n    data string\n}\n\nvar (\n    instance *singleton\n    once     sync.Once\n)\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &singleton{\n            data: \"initialized\",\n        }\n    })\n    return instance\n}\n\n// Singleton with initialization parameters\ntype Database struct {\n    connection string\n}\n\nvar (\n    db     *Database\n    dbOnce sync.Once\n)\n\nfunc InitDatabase(conn string) *Database {\n    dbOnce.Do(func() {\n        db = &Database{\n            connection: conn,\n        }\n    })\n    return db\n}\n\nfunc GetDatabase() *Database {\n    if db == nil {\n        panic(\"database not initialized\")\n    }\n    return db\n}\n```\n\n### Factory\n```go\n// Simple factory\ntype StorageType int\n\nconst (\n    DiskStorage StorageType = iota\n    MemoryStorage\n    CloudStorage\n)\n\ntype Storage interface {\n    Save(data []byte) error\n    Load(id string) ([]byte, error)\n}\n\nfunc NewStorage(t StorageType) Storage {\n    switch t {\n    case DiskStorage:\n        return &diskStorage{}\n    case MemoryStorage:\n        return &memoryStorage{}\n    case CloudStorage:\n        return &cloudStorage{}\n    default:\n        return &memoryStorage{}\n    }\n}\n\n// Factory with registration\ntype Creator func() Storage\n\nvar creators = make(map[string]Creator)\n\nfunc RegisterStorage(name string, creator Creator) {\n    creators[name] = creator\n}\n\nfunc CreateStorage(name string) Storage {\n    creator, ok := creators[name]\n    if !ok {\n        return nil\n    }\n    return creator()\n}\n\n// Usage\nfunc init() {\n    RegisterStorage(\"s3\", func() Storage {\n        return &S3Storage{}\n    })\n    RegisterStorage(\"gcs\", func() Storage {\n        return &GCSStorage{}\n    })\n}\n```\n\n### Builder\n```go\n// Builder pattern for complex object construction\ntype Server struct {\n    host       string\n    port       int\n    timeout    time.Duration\n    maxConns   int\n    tls        bool\n    middleware []func(http.Handler) http.Handler\n}\n\ntype ServerBuilder struct {\n    server Server\n}\n\nfunc NewServerBuilder() *ServerBuilder {\n    return &ServerBuilder{\n        server: Server{\n            port:     8080,\n            timeout:  30 * time.Second,\n            maxConns: 100,\n        },\n    }\n}\n\nfunc (b *ServerBuilder) WithHost(host string) *ServerBuilder {\n    b.server.host = host\n    return b\n}\n\nfunc (b *ServerBuilder) WithPort(port int) *ServerBuilder {\n    b.server.port = port\n    return b\n}\n\nfunc (b *ServerBuilder) WithTimeout(timeout time.Duration) *ServerBuilder {\n    b.server.timeout = timeout\n    return b\n}\n\nfunc (b *ServerBuilder) WithTLS() *ServerBuilder {\n    b.server.tls = true\n    return b\n}\n\nfunc (b *ServerBuilder) WithMiddleware(mw func(http.Handler) http.Handler) *ServerBuilder {\n    b.server.middleware = append(b.server.middleware, mw)\n    return b\n}\n\nfunc (b *ServerBuilder) Build() *Server {\n    return &b.server\n}\n\n// Usage\nserver := NewServerBuilder().\n    WithHost(\"localhost\").\n    WithPort(9000).\n    WithTLS().\n    WithTimeout(60 * time.Second).\n    Build()\n```\n\n### Object Pool\n```go\n// Object pool for expensive resources\ntype Connection struct {\n    id   int\n    conn net.Conn\n}\n\ntype ConnectionPool struct {\n    mu       sync.Mutex\n    idle     []*Connection\n    active   map[int]*Connection\n    maxIdle  int\n    maxActive int\n    factory  func() (*Connection, error)\n}\n\nfunc NewConnectionPool(maxIdle, maxActive int, factory func() (*Connection, error)) *ConnectionPool {\n    return &ConnectionPool{\n        idle:      make([]*Connection, 0, maxIdle),\n        active:    make(map[int]*Connection),\n        maxIdle:   maxIdle,\n        maxActive: maxActive,\n        factory:   factory,\n    }\n}\n\nfunc (p *ConnectionPool) Get() (*Connection, error) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    \n    // Reuse idle connection\n    if len(p.idle) > 0 {\n        conn := p.idle[len(p.idle)-1]\n        p.idle = p.idle[:len(p.idle)-1]\n        p.active[conn.id] = conn\n        return conn, nil\n    }\n    \n    // Create new if under limit\n    if len(p.active) < p.maxActive {\n        conn, err := p.factory()\n        if err != nil {\n            return nil, err\n        }\n        p.active[conn.id] = conn\n        return conn, nil\n    }\n    \n    return nil, errors.New(\"pool exhausted\")\n}\n\nfunc (p *ConnectionPool) Put(conn *Connection) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    \n    delete(p.active, conn.id)\n    \n    if len(p.idle) < p.maxIdle {\n        p.idle = append(p.idle, conn)\n    } else {\n        // Close and discard\n        conn.conn.Close()\n    }\n}\n\n// sync.Pool for simple object pooling\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processData(data []byte) string {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    return buf.String()\n}\n```\n\n### Prototype\n```go\n// Prototype pattern for cloning objects\ntype Prototype interface {\n    Clone() Prototype\n}\n\ntype Document struct {\n    Title    string\n    Content  string\n    Metadata map[string]string\n}\n\nfunc (d *Document) Clone() Prototype {\n    // Deep copy\n    metadata := make(map[string]string)\n    for k, v := range d.Metadata {\n        metadata[k] = v\n    }\n    \n    return &Document{\n        Title:    d.Title,\n        Content:  d.Content,\n        Metadata: metadata,\n    }\n}\n\n// Prototype registry\ntype PrototypeRegistry struct {\n    prototypes map[string]Prototype\n}\n\nfunc (r *PrototypeRegistry) Register(name string, prototype Prototype) {\n    r.prototypes[name] = prototype\n}\n\nfunc (r *PrototypeRegistry) Create(name string) Prototype {\n    prototype, exists := r.prototypes[name]\n    if !exists {\n        return nil\n    }\n    return prototype.Clone()\n}\n```\n\n## Structural Patterns\n\n### Adapter\n```go\n// Adapter pattern to make incompatible interfaces work together\ntype OldPrinter interface {\n    PrintOldFormat(s string)\n}\n\ntype NewPrinter interface {\n    Print(d Document)\n}\n\ntype Document struct {\n    content string\n}\n\n// Adapter\ntype PrinterAdapter struct {\n    oldPrinter OldPrinter\n}\n\nfunc (a *PrinterAdapter) Print(d Document) {\n    a.oldPrinter.PrintOldFormat(d.content)\n}\n\n// Two-way adapter\ntype ModernAPI interface {\n    Request(ctx context.Context, data []byte) ([]byte, error)\n}\n\ntype LegacyAPI interface {\n    Call(data string) string\n}\n\ntype APIAdapter struct {\n    legacy LegacyAPI\n}\n\nfunc (a *APIAdapter) Request(ctx context.Context, data []byte) ([]byte, error) {\n    // Check context\n    select {\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    default:\n    }\n    \n    // Convert and call\n    result := a.legacy.Call(string(data))\n    return []byte(result), nil\n}\n\n// Adapt legacy to modern\ntype ReversAPIAdapter struct {\n    modern ModernAPI\n}\n\nfunc (a *ReversAPIAdapter) Call(data string) string {\n    ctx := context.Background()\n    result, err := a.modern.Request(ctx, []byte(data))\n    if err != nil {\n        return \"\"\n    }\n    return string(result)\n}\n```\n\n### Decorator\n```go\n// Decorator pattern for adding behavior\ntype Component interface {\n    Operation() string\n}\n\ntype ConcreteComponent struct{}\n\nfunc (c *ConcreteComponent) Operation() string {\n    return \"ConcreteComponent\"\n}\n\n// Base decorator\ntype Decorator struct {\n    component Component\n}\n\nfunc (d *Decorator) Operation() string {\n    return d.component.Operation()\n}\n\n// Concrete decorators\ntype LoggingDecorator struct {\n    Decorator\n    logger *log.Logger\n}\n\nfunc (d *LoggingDecorator) Operation() string {\n    result := d.component.Operation()\n    d.logger.Printf(\"Operation called, result: %s\", result)\n    return result\n}\n\ntype TimingDecorator struct {\n    Decorator\n}\n\nfunc (d *TimingDecorator) Operation() string {\n    start := time.Now()\n    result := d.component.Operation()\n    fmt.Printf(\"Operation took %v\\n\", time.Since(start))\n    return result\n}\n\n// HTTP middleware as decorator\ntype Middleware func(http.Handler) http.Handler\n\nfunc Logging(logger *log.Logger) Middleware {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            start := time.Now()\n            wrapped := &responseWriter{ResponseWriter: w}\n            next.ServeHTTP(wrapped, r)\n            logger.Printf(\"%s %s %d %v\", r.Method, r.URL.Path, wrapped.status, time.Since(start))\n        })\n    }\n}\n\nfunc RateLimit(limit int) Middleware {\n    limiter := rate.NewLimiter(rate.Limit(limit), 1)\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            if !limiter.Allow() {\n                http.Error(w, \"Rate limit exceeded\", http.StatusTooManyRequests)\n                return\n            }\n            next.ServeHTTP(w, r)\n        })\n    }\n}\n\n// Chain decorators\nfunc Chain(h http.Handler, middlewares ...Middleware) http.Handler {\n    for i := len(middlewares) - 1; i >= 0; i-- {\n        h = middlewares[i](h)\n    }\n    return h\n}\n```\n\n### Facade\n```go\n// Facade pattern for simplifying complex subsystems\ntype OrderFacade struct {\n    inventory *InventoryService\n    payment   *PaymentService\n    shipping  *ShippingService\n    email     *EmailService\n}\n\nfunc NewOrderFacade() *OrderFacade {\n    return &OrderFacade{\n        inventory: &InventoryService{},\n        payment:   &PaymentService{},\n        shipping:  &ShippingService{},\n        email:     &EmailService{},\n    }\n}\n\nfunc (f *OrderFacade) PlaceOrder(order Order) error {\n    // Check inventory\n    if err := f.inventory.CheckAvailability(order.Items); err != nil {\n        return fmt.Errorf(\"inventory check failed: %w\", err)\n    }\n    \n    // Process payment\n    if err := f.payment.ProcessPayment(order.Payment); err != nil {\n        return fmt.Errorf(\"payment failed: %w\", err)\n    }\n    \n    // Reserve inventory\n    if err := f.inventory.Reserve(order.Items); err != nil {\n        f.payment.Refund(order.Payment)\n        return fmt.Errorf(\"inventory reservation failed: %w\", err)\n    }\n    \n    // Schedule shipping\n    trackingNumber, err := f.shipping.Schedule(order.ShippingAddress)\n    if err != nil {\n        f.inventory.Release(order.Items)\n        f.payment.Refund(order.Payment)\n        return fmt.Errorf(\"shipping failed: %w\", err)\n    }\n    \n    // Send confirmation\n    f.email.SendConfirmation(order.Email, trackingNumber)\n    \n    return nil\n}\n```\n\n### Proxy\n```go\n// Proxy pattern for controlling access\ntype Image interface {\n    Display()\n}\n\ntype RealImage struct {\n    filename string\n    data     []byte\n}\n\nfunc NewRealImage(filename string) *RealImage {\n    return &RealImage{\n        filename: filename,\n        data:     loadFromDisk(filename),\n    }\n}\n\nfunc (i *RealImage) Display() {\n    fmt.Printf(\"Displaying %s\\n\", i.filename)\n}\n\n// Virtual proxy - lazy loading\ntype ImageProxy struct {\n    filename string\n    realImage *RealImage\n}\n\nfunc NewImageProxy(filename string) *ImageProxy {\n    return &ImageProxy{\n        filename: filename,\n    }\n}\n\nfunc (p *ImageProxy) Display() {\n    if p.realImage == nil {\n        p.realImage = NewRealImage(p.filename)\n    }\n    p.realImage.Display()\n}\n\n// Protection proxy\ntype SecureDocument interface {\n    Read(user User) (string, error)\n    Write(user User, content string) error\n}\n\ntype Document struct {\n    content string\n}\n\ntype SecureDocumentProxy struct {\n    document *Document\n    acl      map[string][]string // user -> permissions\n}\n\nfunc (p *SecureDocumentProxy) Read(user User) (string, error) {\n    if !p.hasPermission(user.Name, \"read\") {\n        return \"\", errors.New(\"access denied\")\n    }\n    return p.document.content, nil\n}\n\nfunc (p *SecureDocumentProxy) Write(user User, content string) error {\n    if !p.hasPermission(user.Name, \"write\") {\n        return errors.New(\"access denied\")\n    }\n    p.document.content = content\n    return nil\n}\n\nfunc (p *SecureDocumentProxy) hasPermission(user, permission string) bool {\n    perms, ok := p.acl[user]\n    if !ok {\n        return false\n    }\n    for _, p := range perms {\n        if p == permission {\n            return true\n        }\n    }\n    return false\n}\n\n// Caching proxy\ntype DataService interface {\n    GetData(id string) ([]byte, error)\n}\n\ntype CachingProxy struct {\n    service DataService\n    cache   map[string][]byte\n    mu      sync.RWMutex\n}\n\nfunc (p *CachingProxy) GetData(id string) ([]byte, error) {\n    // Check cache\n    p.mu.RLock()\n    if data, ok := p.cache[id]; ok {\n        p.mu.RUnlock()\n        return data, nil\n    }\n    p.mu.RUnlock()\n    \n    // Fetch from service\n    data, err := p.service.GetData(id)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Update cache\n    p.mu.Lock()\n    p.cache[id] = data\n    p.mu.Unlock()\n    \n    return data, nil\n}\n```\n\n### Bridge\n```go\n// Bridge pattern - separate abstraction from implementation\ntype Renderer interface {\n    RenderCircle(radius float64)\n    RenderSquare(side float64)\n}\n\ntype VectorRenderer struct{}\n\nfunc (v *VectorRenderer) RenderCircle(radius float64) {\n    fmt.Printf(\"Drawing circle with radius %f as vectors\\n\", radius)\n}\n\nfunc (v *VectorRenderer) RenderSquare(side float64) {\n    fmt.Printf(\"Drawing square with side %f as vectors\\n\", side)\n}\n\ntype RasterRenderer struct{}\n\nfunc (r *RasterRenderer) RenderCircle(radius float64) {\n    fmt.Printf(\"Drawing circle with radius %f as pixels\\n\", radius)\n}\n\nfunc (r *RasterRenderer) RenderSquare(side float64) {\n    fmt.Printf(\"Drawing square with side %f as pixels\\n\", side)\n}\n\n// Abstraction\ntype Shape interface {\n    Draw()\n    Resize(factor float64)\n}\n\ntype Circle struct {\n    renderer Renderer\n    radius   float64\n}\n\nfunc NewCircle(renderer Renderer, radius float64) *Circle {\n    return &Circle{\n        renderer: renderer,\n        radius:   radius,\n    }\n}\n\nfunc (c *Circle) Draw() {\n    c.renderer.RenderCircle(c.radius)\n}\n\nfunc (c *Circle) Resize(factor float64) {\n    c.radius *= factor\n}\n\ntype Square struct {\n    renderer Renderer\n    side     float64\n}\n\nfunc NewSquare(renderer Renderer, side float64) *Square {\n    return &Square{\n        renderer: renderer,\n        side:     side,\n    }\n}\n\nfunc (s *Square) Draw() {\n    s.renderer.RenderSquare(s.side)\n}\n\nfunc (s *Square) Resize(factor float64) {\n    s.side *= factor\n}\n```\n\n### Composite\n```go\n// Composite pattern for tree structures\ntype Component interface {\n    Operation() string\n}\n\ntype Leaf struct {\n    name string\n}\n\nfunc (l *Leaf) Operation() string {\n    return l.name\n}\n\ntype Composite struct {\n    children []Component\n}\n\nfunc (c *Composite) Add(component Component) {\n    c.children = append(c.children, component)\n}\n\nfunc (c *Composite) Remove(component Component) {\n    for i, child := range c.children {\n        if child == component {\n            c.children = append(c.children[:i], c.children[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (c *Composite) Operation() string {\n    var result []string\n    for _, child := range c.children {\n        result = append(result, child.Operation())\n    }\n    return strings.Join(result, \" + \")\n}\n\n// File system example\ntype FileSystemNode interface {\n    GetSize() int64\n    GetName() string\n}\n\ntype File struct {\n    name string\n    size int64\n}\n\nfunc (f *File) GetSize() int64 {\n    return f.size\n}\n\nfunc (f *File) GetName() string {\n    return f.name\n}\n\ntype Directory struct {\n    name     string\n    children []FileSystemNode\n}\n\nfunc (d *Directory) GetSize() int64 {\n    var total int64\n    for _, child := range d.children {\n        total += child.GetSize()\n    }\n    return total\n}\n\nfunc (d *Directory) GetName() string {\n    return d.name\n}\n\nfunc (d *Directory) Add(node FileSystemNode) {\n    d.children = append(d.children, node)\n}\n```\n\n## Behavioral Patterns\n\n### Strategy\n```go\n// Strategy pattern for interchangeable algorithms\ntype PaymentStrategy interface {\n    Pay(amount float64) error\n}\n\ntype CreditCard struct {\n    number string\n    cvv    string\n}\n\nfunc (c *CreditCard) Pay(amount float64) error {\n    fmt.Printf(\"Paying %.2f using credit card %s\\n\", amount, c.number)\n    return nil\n}\n\ntype PayPal struct {\n    email string\n}\n\nfunc (p *PayPal) Pay(amount float64) error {\n    fmt.Printf(\"Paying %.2f using PayPal account %s\\n\", amount, p.email)\n    return nil\n}\n\ntype Bitcoin struct {\n    walletAddress string\n}\n\nfunc (b *Bitcoin) Pay(amount float64) error {\n    fmt.Printf(\"Paying %.2f using Bitcoin wallet %s\\n\", amount, b.walletAddress)\n    return nil\n}\n\ntype PaymentProcessor struct {\n    strategy PaymentStrategy\n}\n\nfunc (p *PaymentProcessor) SetStrategy(strategy PaymentStrategy) {\n    p.strategy = strategy\n}\n\nfunc (p *PaymentProcessor) ProcessPayment(amount float64) error {\n    if p.strategy == nil {\n        return errors.New(\"payment strategy not set\")\n    }\n    return p.strategy.Pay(amount)\n}\n\n// Compression strategy example\ntype CompressionStrategy interface {\n    Compress(data []byte) []byte\n}\n\ntype GzipCompression struct{}\n\nfunc (g *GzipCompression) Compress(data []byte) []byte {\n    var buf bytes.Buffer\n    writer := gzip.NewWriter(&buf)\n    writer.Write(data)\n    writer.Close()\n    return buf.Bytes()\n}\n\ntype ZlibCompression struct{}\n\nfunc (z *ZlibCompression) Compress(data []byte) []byte {\n    var buf bytes.Buffer\n    writer := zlib.NewWriter(&buf)\n    writer.Write(data)\n    writer.Close()\n    return buf.Bytes()\n}\n\ntype Compressor struct {\n    strategy CompressionStrategy\n}\n\nfunc (c *Compressor) Compress(data []byte) []byte {\n    return c.strategy.Compress(data)\n}\n```\n\n### Observer\n```go\n// Observer pattern for event notification\ntype Observer interface {\n    Update(event interface{})\n}\n\ntype Subject interface {\n    Attach(Observer)\n    Detach(Observer)\n    Notify(event interface{})\n}\n\ntype ConcreteSubject struct {\n    observers []Observer\n    mu        sync.RWMutex\n}\n\nfunc (s *ConcreteSubject) Attach(observer Observer) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.observers = append(s.observers, observer)\n}\n\nfunc (s *ConcreteSubject) Detach(observer Observer) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    for i, o := range s.observers {\n        if o == observer {\n            s.observers = append(s.observers[:i], s.observers[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (s *ConcreteSubject) Notify(event interface{}) {\n    s.mu.RLock()\n    observers := make([]Observer, len(s.observers))\n    copy(observers, s.observers)\n    s.mu.RUnlock()\n    \n    for _, observer := range observers {\n        observer.Update(event)\n    }\n}\n\n// Event bus implementation\ntype EventBus struct {\n    mu        sync.RWMutex\n    listeners map[string][]chan interface{}\n}\n\nfunc NewEventBus() *EventBus {\n    return &EventBus{\n        listeners: make(map[string][]chan interface{}),\n    }\n}\n\nfunc (eb *EventBus) Subscribe(event string) <-chan interface{} {\n    eb.mu.Lock()\n    defer eb.mu.Unlock()\n    \n    ch := make(chan interface{}, 10)\n    eb.listeners[event] = append(eb.listeners[event], ch)\n    return ch\n}\n\nfunc (eb *EventBus) Publish(event string, data interface{}) {\n    eb.mu.RLock()\n    defer eb.mu.RUnlock()\n    \n    for _, ch := range eb.listeners[event] {\n        select {\n        case ch <- data:\n        default:\n            // Listener is slow, skip\n        }\n    }\n}\n\nfunc (eb *EventBus) Unsubscribe(event string, ch <-chan interface{}) {\n    eb.mu.Lock()\n    defer eb.mu.Unlock()\n    \n    listeners := eb.listeners[event]\n    for i, listener := range listeners {\n        if listener == ch {\n            close(listener)\n            eb.listeners[event] = append(listeners[:i], listeners[i+1:]...)\n            break\n        }\n    }\n}\n```\n\n### Command\n```go\n// Command pattern for encapsulating requests\ntype Command interface {\n    Execute() error\n    Undo() error\n}\n\n// Receiver\ntype Light struct {\n    isOn bool\n}\n\nfunc (l *Light) TurnOn() {\n    l.isOn = true\n    fmt.Println(\"Light is on\")\n}\n\nfunc (l *Light) TurnOff() {\n    l.isOn = false\n    fmt.Println(\"Light is off\")\n}\n\n// Concrete commands\ntype TurnOnCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOnCommand) Execute() error {\n    c.light.TurnOn()\n    return nil\n}\n\nfunc (c *TurnOnCommand) Undo() error {\n    c.light.TurnOff()\n    return nil\n}\n\ntype TurnOffCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOffCommand) Execute() error {\n    c.light.TurnOff()\n    return nil\n}\n\nfunc (c *TurnOffCommand) Undo() error {\n    c.light.TurnOn()\n    return nil\n}\n\n// Invoker with history\ntype RemoteControl struct {\n    commands []Command\n    history  []Command\n}\n\nfunc (r *RemoteControl) SetCommand(cmd Command) {\n    r.commands = append(r.commands, cmd)\n}\n\nfunc (r *RemoteControl) PressButton(index int) error {\n    if index >= len(r.commands) {\n        return errors.New(\"invalid button\")\n    }\n    cmd := r.commands[index]\n    if err := cmd.Execute(); err != nil {\n        return err\n    }\n    r.history = append(r.history, cmd)\n    return nil\n}\n\nfunc (r *RemoteControl) Undo() error {\n    if len(r.history) == 0 {\n        return errors.New(\"nothing to undo\")\n    }\n    cmd := r.history[len(r.history)-1]\n    r.history = r.history[:len(r.history)-1]\n    return cmd.Undo()\n}\n\n// Macro command\ntype MacroCommand struct {\n    commands []Command\n}\n\nfunc (m *MacroCommand) Execute() error {\n    for _, cmd := range m.commands {\n        if err := cmd.Execute(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc (m *MacroCommand) Undo() error {\n    // Undo in reverse order\n    for i := len(m.commands) - 1; i >= 0; i-- {\n        if err := m.commands[i].Undo(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n### Iterator\n```go\n// Iterator pattern for traversing collections\ntype Iterator interface {\n    HasNext() bool\n    Next() interface{}\n    Reset()\n}\n\ntype Collection interface {\n    CreateIterator() Iterator\n}\n\n// Concrete collection\ntype BookCollection struct {\n    books []string\n}\n\nfunc (c *BookCollection) CreateIterator() Iterator {\n    return &BookIterator{\n        collection: c,\n        index:      0,\n    }\n}\n\ntype BookIterator struct {\n    collection *BookCollection\n    index      int\n}\n\nfunc (i *BookIterator) HasNext() bool {\n    return i.index < len(i.collection.books)\n}\n\nfunc (i *BookIterator) Next() interface{} {\n    if i.HasNext() {\n        book := i.collection.books[i.index]\n        i.index++\n        return book\n    }\n    return nil\n}\n\nfunc (i *BookIterator) Reset() {\n    i.index = 0\n}\n\n// Generic iterator using channels\nfunc Iterate[T any](slice []T) <-chan T {\n    ch := make(chan T)\n    go func() {\n        defer close(ch)\n        for _, item := range slice {\n            ch <- item\n        }\n    }()\n    return ch\n}\n\n// Tree iterator\ntype TreeNode struct {\n    Value    int\n    Children []*TreeNode\n}\n\nfunc (n *TreeNode) DepthFirst() <-chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        n.depthFirstHelper(ch)\n    }()\n    return ch\n}\n\nfunc (n *TreeNode) depthFirstHelper(ch chan<- int) {\n    ch <- n.Value\n    for _, child := range n.Children {\n        child.depthFirstHelper(ch)\n    }\n}\n\nfunc (n *TreeNode) BreadthFirst() <-chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        queue := []*TreeNode{n}\n        for len(queue) > 0 {\n            node := queue[0]\n            queue = queue[1:]\n            ch <- node.Value\n            queue = append(queue, node.Children...)\n        }\n    }()\n    return ch\n}\n```\n\n### Chain of Responsibility\n```go\n// Chain of Responsibility pattern\ntype Handler interface {\n    SetNext(Handler) Handler\n    Handle(request interface{}) error\n}\n\ntype BaseHandler struct {\n    next Handler\n}\n\nfunc (h *BaseHandler) SetNext(next Handler) Handler {\n    h.next = next\n    return next\n}\n\nfunc (h *BaseHandler) Handle(request interface{}) error {\n    if h.next != nil {\n        return h.next.Handle(request)\n    }\n    return nil\n}\n\n// Concrete handlers\ntype AuthenticationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthenticationHandler) Handle(request interface{}) error {\n    req, ok := request.(*Request)\n    if !ok {\n        return errors.New(\"invalid request type\")\n    }\n    \n    if req.Token == \"\" {\n        return errors.New(\"authentication required\")\n    }\n    \n    fmt.Println(\"Authentication passed\")\n    return h.BaseHandler.Handle(request)\n}\n\ntype AuthorizationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthorizationHandler) Handle(request interface{}) error {\n    req, ok := request.(*Request)\n    if !ok {\n        return errors.New(\"invalid request type\")\n    }\n    \n    if !req.HasPermission {\n        return errors.New(\"insufficient permissions\")\n    }\n    \n    fmt.Println(\"Authorization passed\")\n    return h.BaseHandler.Handle(request)\n}\n\ntype ValidationHandler struct {\n    BaseHandler\n}\n\nfunc (h *ValidationHandler) Handle(request interface{}) error {\n    req, ok := request.(*Request)\n    if !ok {\n        return errors.New(\"invalid request type\")\n    }\n    \n    if req.Data == \"\" {\n        return errors.New(\"invalid data\")\n    }\n    \n    fmt.Println(\"Validation passed\")\n    return h.BaseHandler.Handle(request)\n}\n\n// Usage\nfunc setupChain() Handler {\n    auth := &AuthenticationHandler{}\n    authz := &AuthorizationHandler{}\n    valid := &ValidationHandler{}\n    \n    auth.SetNext(authz).SetNext(valid)\n    \n    return auth\n}\n```\n\n## Concurrency Patterns\n\n### Pipeline\n```go\n// Pipeline pattern for data processing\nfunc pipeline() {\n    // Stage 1: Generate numbers\n    numbers := generate(100)\n    \n    // Stage 2: Square numbers\n    squares := square(numbers)\n    \n    // Stage 3: Filter even\n    evens := filter(squares, func(n int) bool {\n        return n%2 == 0\n    })\n    \n    // Consume\n    for n := range evens {\n        fmt.Println(n)\n    }\n}\n\nfunc generate(max int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for i := 1; i <= max; i++ {\n            out <- i\n        }\n    }()\n    return out\n}\n\nfunc square(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            out <- n * n\n        }\n    }()\n    return out\n}\n\nfunc filter(in <-chan int, fn func(int) bool) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            if fn(n) {\n                out <- n\n            }\n        }\n    }()\n    return out\n}\n```\n\n### Fan-Out/Fan-In\n```go\n// Fan-out/Fan-in for parallel processing\nfunc fanOutFanIn() {\n    in := generate(100)\n    \n    // Fan-out to multiple workers\n    c1 := process(in)\n    c2 := process(in)\n    c3 := process(in)\n    \n    // Fan-in results\n    out := fanIn(c1, c2, c3)\n    \n    for result := range out {\n        fmt.Println(result)\n    }\n}\n\nfunc process(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        defer close(out)\n        for n := range in {\n            out <- n * 2 // Some processing\n            time.Sleep(time.Millisecond) // Simulate work\n        }\n    }()\n    return out\n}\n\nfunc fanIn(channels ...<-chan int) <-chan int {\n    out := make(chan int)\n    var wg sync.WaitGroup\n    \n    for _, ch := range channels {\n        wg.Add(1)\n        go func(c <-chan int) {\n            defer wg.Done()\n            for val := range c {\n                out <- val\n            }\n        }(ch)\n    }\n    \n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    \n    return out\n}\n```\n\n### Worker Pool\n```go\n// Worker pool for controlled concurrency\ntype WorkerPool struct {\n    maxWorkers int\n    jobQueue   chan Job\n    workerPool chan chan Job\n    workers    []*Worker\n    wg         sync.WaitGroup\n}\n\ntype Job interface {\n    Process() error\n}\n\ntype Worker struct {\n    id         int\n    jobChannel chan Job\n    workerPool chan chan Job\n    quit       chan bool\n}\n\nfunc NewWorkerPool(maxWorkers int) *WorkerPool {\n    pool := &WorkerPool{\n        maxWorkers: maxWorkers,\n        jobQueue:   make(chan Job),\n        workerPool: make(chan chan Job, maxWorkers),\n    }\n    \n    pool.workers = make([]*Worker, maxWorkers)\n    for i := 0; i < maxWorkers; i++ {\n        worker := NewWorker(i, pool.workerPool)\n        pool.workers[i] = worker\n        worker.Start()\n    }\n    \n    go pool.dispatch()\n    \n    return pool\n}\n\nfunc (p *WorkerPool) dispatch() {\n    for job := range p.jobQueue {\n        jobChannel := <-p.workerPool\n        jobChannel <- job\n    }\n}\n\nfunc (p *WorkerPool) Submit(job Job) {\n    p.jobQueue <- job\n}\n\nfunc (p *WorkerPool) Shutdown() {\n    close(p.jobQueue)\n    for _, worker := range p.workers {\n        worker.Stop()\n    }\n}\n\nfunc NewWorker(id int, workerPool chan chan Job) *Worker {\n    return &Worker{\n        id:         id,\n        jobChannel: make(chan Job),\n        workerPool: workerPool,\n        quit:       make(chan bool),\n    }\n}\n\nfunc (w *Worker) Start() {\n    go func() {\n        for {\n            w.workerPool <- w.jobChannel\n            \n            select {\n            case job := <-w.jobChannel:\n                if err := job.Process(); err != nil {\n                    fmt.Printf(\"Worker %d error: %v\\n\", w.id, err)\n                }\n            case <-w.quit:\n                return\n            }\n        }\n    }()\n}\n\nfunc (w *Worker) Stop() {\n    close(w.quit)\n}\n```\n\n## Go Idioms\n\n### Accept Interfaces, Return Structs\n```go\n// Good: Accept interface\nfunc ProcessData(r io.Reader) error {\n    data, err := io.ReadAll(r)\n    if err != nil {\n        return err\n    }\n    // Process data\n    return nil\n}\n\n// Good: Return concrete type\nfunc NewBuffer() *bytes.Buffer {\n    return &bytes.Buffer{}\n}\n\n// Usage is flexible\nProcessData(os.Stdin)\nProcessData(NewBuffer())\nProcessData(strings.NewReader(\"test\"))\n```\n\n### Embedding for Composition\n```go\n// Embedding interfaces\ntype ReadWriter interface {\n    io.Reader\n    io.Writer\n}\n\n// Embedding structs\ntype Server struct {\n    http.Server       // Embed standard server\n    logger *log.Logger\n    config *Config\n}\n\nfunc (s *Server) Start() error {\n    s.logger.Println(\"Starting server\")\n    return s.ListenAndServe() // Call embedded method\n}\n\n// Method promotion\ntype Document struct {\n    *bytes.Buffer // Embed pointer\n    metadata map[string]string\n}\n\nfunc NewDocument() *Document {\n    return &Document{\n        Buffer:   new(bytes.Buffer),\n        metadata: make(map[string]string),\n    }\n}\n\n// Buffer methods are promoted\ndoc := NewDocument()\ndoc.WriteString(\"Hello\") // Calls Buffer.WriteString\n```\n\n### Table-Driven Tests\n```go\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name string\n        a, b int\n        want int\n    }{\n        {\"positive\", 2, 3, 5},\n        {\"negative\", -2, -3, -5},\n        {\"mixed\", -2, 3, 1},\n        {\"zero\", 0, 0, 0},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := Add(tt.a, tt.b); got != tt.want {\n                t.Errorf(\"Add(%d, %d) = %d, want %d\", tt.a, tt.b, got, tt.want)\n            }\n        })\n    }\n}\n```\n\n### Named Results for Documentation\n```go\n// Named results clarify what function returns\nfunc ParseConfig(data []byte) (config *Config, warnings []string, err error) {\n    config = &Config{}\n    \n    if err = json.Unmarshal(data, config); err != nil {\n        return nil, nil, fmt.Errorf(\"invalid JSON: %w\", err)\n    }\n    \n    if config.Timeout == 0 {\n        warnings = append(warnings, \"timeout not set, using default\")\n        config.Timeout = 30 * time.Second\n    }\n    \n    return config, warnings, nil\n}\n```\n\n## Functional Options\n\n### Options Pattern\n```go\n// Functional options for flexible APIs\ntype Server struct {\n    host     string\n    port     int\n    timeout  time.Duration\n    maxConns int\n    tls      bool\n}\n\ntype Option func(*Server)\n\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = timeout\n    }\n}\n\nfunc WithTLS(certFile, keyFile string) Option {\n    return func(s *Server) {\n        s.tls = true\n        // Configure TLS\n    }\n}\n\nfunc WithMaxConnections(max int) Option {\n    return func(s *Server) {\n        s.maxConns = max\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    // Defaults\n    s := &Server{\n        host:     \"localhost\",\n        port:     8080,\n        timeout:  30 * time.Second,\n        maxConns: 100,\n    }\n    \n    // Apply options\n    for _, opt := range opts {\n        opt(s)\n    }\n    \n    return s\n}\n\n// Clean usage\nserver := NewServer(\n    WithHost(\"0.0.0.0\"),\n    WithPort(9000),\n    WithTimeout(60*time.Second),\n    WithTLS(\"cert.pem\", \"key.pem\"),\n)\n\n// Option validation\nfunc WithPort(port int) Option {\n    return func(s *Server) error {\n        if port <= 0 || port > 65535 {\n            return fmt.Errorf(\"invalid port: %d\", port)\n        }\n        s.port = port\n        return nil\n    }\n}\n\n// Options with error handling\ntype OptionWithError func(*Server) error\n\nfunc NewServerWithValidation(opts ...OptionWithError) (*Server, error) {\n    s := &Server{\n        // defaults\n    }\n    \n    for _, opt := range opts {\n        if err := opt(s); err != nil {\n            return nil, err\n        }\n    }\n    \n    return s, nil\n}\n```\n\n## Dependency Injection\n\n### Constructor Injection\n```go\n// Constructor injection for explicit dependencies\ntype Service struct {\n    logger *log.Logger\n    db     *sql.DB\n    cache  Cache\n    config *Config\n}\n\nfunc NewService(logger *log.Logger, db *sql.DB, cache Cache, config *Config) *Service {\n    return &Service{\n        logger: logger,\n        db:     db,\n        cache:  cache,\n        config: config,\n    }\n}\n\n// Interface injection for testability\ntype UserRepository interface {\n    GetUser(id int) (*User, error)\n    SaveUser(user *User) error\n}\n\ntype UserService struct {\n    repo   UserRepository\n    logger *log.Logger\n}\n\nfunc NewUserService(repo UserRepository, logger *log.Logger) *UserService {\n    return &UserService{\n        repo:   repo,\n        logger: logger,\n    }\n}\n```\n\n### Wire for Dependency Injection\n```go\n// wire.go\n//go:build wireinject\n\npackage main\n\nimport \"github.com/google/wire\"\n\nfunc InitializeApp() (*App, error) {\n    wire.Build(\n        NewConfig,\n        NewLogger,\n        NewDatabase,\n        NewCache,\n        NewUserRepository,\n        NewUserService,\n        NewApp,\n    )\n    return nil, nil\n}\n\n// Providers\nfunc NewConfig() *Config {\n    return &Config{} // Load from environment\n}\n\nfunc NewLogger(cfg *Config) *log.Logger {\n    return log.New(os.Stdout, cfg.LogPrefix, log.LstdFlags)\n}\n\nfunc NewDatabase(cfg *Config) (*sql.DB, error) {\n    return sql.Open(\"postgres\", cfg.DatabaseURL)\n}\n\nfunc NewCache(cfg *Config) Cache {\n    return NewRedisCache(cfg.RedisURL)\n}\n\nfunc NewUserRepository(db *sql.DB) UserRepository {\n    return &SQLUserRepository{db: db}\n}\n\nfunc NewUserService(repo UserRepository, logger *log.Logger, cache Cache) *UserService {\n    return &UserService{\n        repo:   repo,\n        logger: logger,\n        cache:  cache,\n    }\n}\n\nfunc NewApp(service *UserService) *App {\n    return &App{\n        service: service,\n    }\n}\n```\n\n## Error Handling Patterns\n\n### Error Types\n```go\n// Sentinel errors\nvar (\n    ErrNotFound   = errors.New(\"not found\")\n    ErrUnauthorized = errors.New(\"unauthorized\")\n    ErrInternal   = errors.New(\"internal error\")\n)\n\n// Error types\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error on field %s: %s\", e.Field, e.Message)\n}\n\n// Wrapped errors\nfunc processFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return fmt.Errorf(\"failed to open file %s: %w\", filename, err)\n    }\n    defer file.Close()\n    \n    data, err := io.ReadAll(file)\n    if err != nil {\n        return fmt.Errorf(\"failed to read file %s: %w\", filename, err)\n    }\n    \n    if err := processData(data); err != nil {\n        return fmt.Errorf(\"failed to process data from %s: %w\", filename, err)\n    }\n    \n    return nil\n}\n\n// Error checking\nfunc handleError(err error) {\n    if errors.Is(err, ErrNotFound) {\n        // Handle not found\n    }\n    \n    var validationErr ValidationError\n    if errors.As(err, &validationErr) {\n        // Handle validation error\n        fmt.Printf(\"Field %s failed validation\\n\", validationErr.Field)\n    }\n}\n```\n\n### Error Collection\n```go\n// Multiple error handling\ntype ErrorCollector struct {\n    mu     sync.Mutex\n    errors []error\n}\n\nfunc (c *ErrorCollector) Add(err error) {\n    if err == nil {\n        return\n    }\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.errors = append(c.errors, err)\n}\n\nfunc (c *ErrorCollector) Error() error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    if len(c.errors) == 0 {\n        return nil\n    }\n    \n    if len(c.errors) == 1 {\n        return c.errors[0]\n    }\n    \n    return fmt.Errorf(\"multiple errors occurred: %v\", c.errors)\n}\n\n// Usage with goroutines\nfunc processItems(items []Item) error {\n    var wg sync.WaitGroup\n    collector := &ErrorCollector{}\n    \n    for _, item := range items {\n        wg.Add(1)\n        go func(i Item) {\n            defer wg.Done()\n            if err := process(i); err != nil {\n                collector.Add(fmt.Errorf(\"item %v: %w\", i.ID, err))\n            }\n        }(item)\n    }\n    \n    wg.Wait()\n    return collector.Error()\n}\n```\n\n## Testing Patterns\n\n### Test Fixtures\n```go\n// Test fixtures for consistent test data\ntype Fixtures struct {\n    Users    []*User\n    Products []*Product\n    Orders   []*Order\n}\n\nfunc NewFixtures() *Fixtures {\n    return &Fixtures{\n        Users: []*User{\n            {ID: 1, Name: \"Alice\", Email: \"alice@example.com\"},\n            {ID: 2, Name: \"Bob\", Email: \"bob@example.com\"},\n        },\n        Products: []*Product{\n            {ID: 1, Name: \"Widget\", Price: 9.99},\n            {ID: 2, Name: \"Gadget\", Price: 19.99},\n        },\n    }\n}\n\n// Golden files for snapshot testing\nfunc TestRender(t *testing.T) {\n    data := getData()\n    output := Render(data)\n    \n    golden := filepath.Join(\"testdata\", t.Name()+\".golden\")\n    \n    if *update {\n        os.WriteFile(golden, []byte(output), 0644)\n    }\n    \n    expected, err := os.ReadFile(golden)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if output != string(expected) {\n        t.Errorf(\"output mismatch:\\ngot:\\n%s\\nwant:\\n%s\", output, expected)\n    }\n}\n```\n\n### Test Helpers\n```go\n// Test helpers for common operations\nfunc setupTest(t *testing.T) (*sql.DB, func()) {\n    t.Helper()\n    \n    db, err := sql.Open(\"sqlite3\", \":memory:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if err := migrate(db); err != nil {\n        t.Fatal(err)\n    }\n    \n    cleanup := func() {\n        db.Close()\n    }\n    \n    return db, cleanup\n}\n\n// Usage\nfunc TestUserRepository(t *testing.T) {\n    db, cleanup := setupTest(t)\n    defer cleanup()\n    \n    repo := NewUserRepository(db)\n    // Test repository\n}\n\n// Test server\nfunc setupTestServer(t *testing.T, handler http.Handler) *httptest.Server {\n    t.Helper()\n    server := httptest.NewServer(handler)\n    t.Cleanup(server.Close)\n    return server\n}\n```\n\n## Performance Patterns\n\n### Object Pooling\n```go\n// Sync.Pool for reducing allocations\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processRequest(data []byte) string {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    // Process\n    return buf.String()\n}\n```\n\n### Lazy Initialization\n```go\n// Lazy loading with sync.Once\ntype ExpensiveResource struct {\n    once sync.Once\n    data *Data\n}\n\nfunc (r *ExpensiveResource) Get() *Data {\n    r.once.Do(func() {\n        r.data = loadExpensiveData()\n    })\n    return r.data\n}\n```\n\n### Copy-on-Write\n```go\n// Copy-on-write for concurrent access\ntype COWMap struct {\n    mu   sync.RWMutex\n    data map[string]interface{}\n}\n\nfunc (m *COWMap) Get(key string) (interface{}, bool) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    val, ok := m.data[key]\n    return val, ok\n}\n\nfunc (m *COWMap) Set(key string, value interface{}) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    \n    // Copy on write\n    newData := make(map[string]interface{}, len(m.data)+1)\n    for k, v := range m.data {\n        newData[k] = v\n    }\n    newData[key] = value\n    m.data = newData\n}\n```\n\n## Best Practices Summary\n\n1. **Prefer composition over inheritance** - Use embedding and interfaces\n2. **Keep interfaces small** - Single responsibility\n3. **Accept interfaces, return structs** - Maximum flexibility\n4. **Use functional options** - For optional parameters\n5. **Constructor injection** - For required dependencies\n6. **Table-driven tests** - For comprehensive testing\n7. **Error wrapping** - Maintain error context\n8. **Channels for communication** - Between goroutines\n9. **Context for cancellation** - And request-scoped values\n10. **Profile before optimizing** - Measure performance impacts","structuredPatch":[]}}
{"parentUuid":"c6569f7d-b89a-41c6-9251-b9bf90ffa1eb","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01SfoQV31a5v5EowqqwwsKBb","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Due to the response length limits, I'll continue creating the remaining documentation files. Let me proceed with the next files:\n\n## 4. Go Testing"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":70863,"cache_read_input_tokens":0,"output_tokens":10064,"service_tier":"standard"}},"requestId":"req_011CS5JYeqStg2k1P9kmXbaY","type":"assistant","uuid":"904e6a27-4265-4b8e-8800-d0f19d8c5634","timestamp":"2025-08-13T07:20:01.180Z"}
{"parentUuid":"904e6a27-4265-4b8e-8800-d0f19d8c5634","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01SfoQV31a5v5EowqqwwsKBb","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_016rCZU1ZfXJgwrcyeydJvuG","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-testing.md","content":"# Go Testing - Complete Testing Guide\n\n## Table of Contents\n1. [Unit Tests](#unit-tests)\n2. [Table-Driven Tests](#table-driven-tests)\n3. [Subtests](#subtests)\n4. [Mocks and Stubs](#mocks-and-stubs)\n5. [Fuzz Testing](#fuzz-testing)\n6. [Benchmarks](#benchmarks)\n7. [Coverage](#coverage)\n8. [Integration Tests](#integration-tests)\n9. [Test Fixtures and Helpers](#test-fixtures-and-helpers)\n10. [Advanced Testing Techniques](#advanced-testing-techniques)\n\n## Unit Tests\n\n### Basic Test Structure\n```go\n// File: math.go\npackage math\n\nfunc Add(a, b int) int {\n    return a + b\n}\n\n// File: math_test.go\npackage math\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n    result := Add(2, 3)\n    expected := 5\n    \n    if result != expected {\n        t.Errorf(\"Add(2, 3) = %d; want %d\", result, expected)\n    }\n}\n\n// Test with multiple assertions\nfunc TestMultipleAssertions(t *testing.T) {\n    // Arrange\n    input := \"test\"\n    \n    // Act\n    result := Process(input)\n    \n    // Assert\n    if result.Status != \"success\" {\n        t.Errorf(\"expected status 'success', got %q\", result.Status)\n    }\n    \n    if len(result.Data) == 0 {\n        t.Error(\"expected non-empty data\")\n    }\n    \n    if result.Timestamp.IsZero() {\n        t.Error(\"expected non-zero timestamp\")\n    }\n}\n\n// Using t.Fatal for critical failures\nfunc TestCriticalFailure(t *testing.T) {\n    db, err := connectDB()\n    if err != nil {\n        t.Fatalf(\"failed to connect to database: %v\", err)\n    }\n    defer db.Close()\n    \n    // Continue with test...\n}\n\n// Using t.Skip for conditional tests\nfunc TestRequiresDocker(t *testing.T) {\n    if !dockerAvailable() {\n        t.Skip(\"skipping test; Docker not available\")\n    }\n    \n    // Docker-dependent test...\n}\n\n// Parallel tests\nfunc TestParallel1(t *testing.T) {\n    t.Parallel() // Run in parallel with other parallel tests\n    // Test implementation...\n}\n\nfunc TestParallel2(t *testing.T) {\n    t.Parallel()\n    // Test implementation...\n}\n```\n\n### Test Organization\n```go\n// Testing exported functions\nfunc TestPublicFunction(t *testing.T) {\n    result := PublicFunction(\"input\")\n    if result != \"expected\" {\n        t.Errorf(\"got %q, want %q\", result, \"expected\")\n    }\n}\n\n// Testing unexported functions (same package)\nfunc TestPrivateFunction(t *testing.T) {\n    result := privateFunction(\"input\")\n    if result != \"expected\" {\n        t.Errorf(\"got %q, want %q\", result, \"expected\")\n    }\n}\n\n// Testing with external package (black-box testing)\npackage math_test\n\nimport (\n    \"testing\"\n    \"myproject/math\"\n)\n\nfunc TestAddExternal(t *testing.T) {\n    result := math.Add(2, 3)\n    if result != 5 {\n        t.Errorf(\"math.Add(2, 3) = %d; want 5\", result)\n    }\n}\n\n// Example tests (show up in documentation)\nfunc ExampleAdd() {\n    result := Add(2, 3)\n    fmt.Println(result)\n    // Output: 5\n}\n\nfunc ExampleAdd_negative() {\n    result := Add(-2, -3)\n    fmt.Println(result)\n    // Output: -5\n}\n\n// Testing main function\nfunc TestMain(m *testing.M) {\n    // Setup before tests\n    setup()\n    \n    // Run tests\n    code := m.Run()\n    \n    // Cleanup after tests\n    teardown()\n    \n    os.Exit(code)\n}\n```\n\n## Table-Driven Tests\n\n### Basic Table-Driven Tests\n```go\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name     string\n        a, b     int\n        expected int\n    }{\n        {\"positive numbers\", 2, 3, 5},\n        {\"negative numbers\", -2, -3, -5},\n        {\"mixed\", -5, 10, 5},\n        {\"with zero\", 0, 5, 5},\n        {\"both zero\", 0, 0, 0},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := Add(tt.a, tt.b)\n            if result != tt.expected {\n                t.Errorf(\"Add(%d, %d) = %d; want %d\", \n                    tt.a, tt.b, result, tt.expected)\n            }\n        })\n    }\n}\n\n// Table-driven tests with errors\nfunc TestDivide(t *testing.T) {\n    tests := []struct {\n        name      string\n        dividend  float64\n        divisor   float64\n        want      float64\n        wantErr   bool\n        errString string\n    }{\n        {\n            name:     \"normal division\",\n            dividend: 10,\n            divisor:  2,\n            want:     5,\n            wantErr:  false,\n        },\n        {\n            name:      \"divide by zero\",\n            dividend:  10,\n            divisor:   0,\n            want:      0,\n            wantErr:   true,\n            errString: \"division by zero\",\n        },\n        {\n            name:     \"negative division\",\n            dividend: -10,\n            divisor:  2,\n            want:     -5,\n            wantErr:  false,\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := Divide(tt.dividend, tt.divisor)\n            \n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Divide() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            \n            if tt.wantErr && err.Error() != tt.errString {\n                t.Errorf(\"Divide() error = %q, want %q\", err.Error(), tt.errString)\n                return\n            }\n            \n            if got != tt.want {\n                t.Errorf(\"Divide() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n\n// Complex table-driven tests\nfunc TestParser(t *testing.T) {\n    tests := []struct {\n        name    string\n        input   string\n        setup   func()\n        cleanup func()\n        want    *Result\n        wantErr bool\n        check   func(t *testing.T, got *Result)\n    }{\n        {\n            name:  \"valid JSON\",\n            input: `{\"key\": \"value\"}`,\n            want: &Result{\n                Type: \"object\",\n                Data: map[string]interface{}{\"key\": \"value\"},\n            },\n        },\n        {\n            name:  \"complex validation\",\n            input: `{\"items\": [1, 2, 3]}`,\n            check: func(t *testing.T, got *Result) {\n                if got.Type != \"object\" {\n                    t.Errorf(\"wrong type: %s\", got.Type)\n                }\n                items, ok := got.Data.(map[string]interface{})[\"items\"].([]interface{})\n                if !ok || len(items) != 3 {\n                    t.Error(\"expected 3 items\")\n                }\n            },\n        },\n        {\n            name: \"with setup\",\n            input: \"special\",\n            setup: func() {\n                // Prepare test environment\n                os.Setenv(\"TEST_MODE\", \"special\")\n            },\n            cleanup: func() {\n                os.Unsetenv(\"TEST_MODE\")\n            },\n            want: &Result{Type: \"special\"},\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if tt.setup != nil {\n                tt.setup()\n            }\n            if tt.cleanup != nil {\n                defer tt.cleanup()\n            }\n            \n            got, err := Parse(tt.input)\n            \n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            \n            if tt.check != nil {\n                tt.check(t, got)\n            } else if !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\n## Subtests\n\n### Using Subtests\n```go\nfunc TestFeature(t *testing.T) {\n    // Setup shared by all subtests\n    db := setupTestDB(t)\n    defer db.Close()\n    \n    t.Run(\"Create\", func(t *testing.T) {\n        // Can run in parallel with other subtests\n        t.Parallel()\n        \n        err := db.Create(&User{Name: \"Alice\"})\n        if err != nil {\n            t.Errorf(\"failed to create user: %v\", err)\n        }\n    })\n    \n    t.Run(\"Read\", func(t *testing.T) {\n        t.Parallel()\n        \n        user, err := db.Read(1)\n        if err != nil {\n            t.Errorf(\"failed to read user: %v\", err)\n        }\n        if user.Name != \"Alice\" {\n            t.Errorf(\"wrong name: got %q, want %q\", user.Name, \"Alice\")\n        }\n    })\n    \n    t.Run(\"Update\", func(t *testing.T) {\n        t.Parallel()\n        \n        err := db.Update(1, &User{Name: \"Bob\"})\n        if err != nil {\n            t.Errorf(\"failed to update user: %v\", err)\n        }\n    })\n    \n    t.Run(\"Delete\", func(t *testing.T) {\n        t.Parallel()\n        \n        err := db.Delete(1)\n        if err != nil {\n            t.Errorf(\"failed to delete user: %v\", err)\n        }\n    })\n}\n\n// Nested subtests\nfunc TestComplexFeature(t *testing.T) {\n    t.Run(\"Component1\", func(t *testing.T) {\n        t.Run(\"Subcomponent1\", func(t *testing.T) {\n            // Test specific functionality\n        })\n        \n        t.Run(\"Subcomponent2\", func(t *testing.T) {\n            // Test specific functionality\n        })\n    })\n    \n    t.Run(\"Component2\", func(t *testing.T) {\n        t.Run(\"Subcomponent1\", func(t *testing.T) {\n            // Test specific functionality\n        })\n    })\n}\n\n// Dynamic subtests\nfunc TestDynamicSubtests(t *testing.T) {\n    scenarios := loadTestScenarios()\n    \n    for _, scenario := range scenarios {\n        scenario := scenario // Capture range variable\n        t.Run(scenario.Name, func(t *testing.T) {\n            t.Parallel()\n            \n            result := ProcessScenario(scenario)\n            if !result.Success {\n                t.Errorf(\"scenario %q failed: %v\", scenario.Name, result.Error)\n            }\n        })\n    }\n}\n```\n\n## Mocks and Stubs\n\n### Manual Mocks\n```go\n// Interface to mock\ntype DataStore interface {\n    Get(key string) (string, error)\n    Set(key, value string) error\n}\n\n// Mock implementation\ntype MockDataStore struct {\n    data      map[string]string\n    getCalls  []string\n    setCalls  []struct{ key, value string }\n    getError  error\n    setError  error\n}\n\nfunc NewMockDataStore() *MockDataStore {\n    return &MockDataStore{\n        data: make(map[string]string),\n    }\n}\n\nfunc (m *MockDataStore) Get(key string) (string, error) {\n    m.getCalls = append(m.getCalls, key)\n    if m.getError != nil {\n        return \"\", m.getError\n    }\n    return m.data[key], nil\n}\n\nfunc (m *MockDataStore) Set(key, value string) error {\n    m.setCalls = append(m.setCalls, struct{ key, value string }{key, value})\n    if m.setError != nil {\n        return m.setError\n    }\n    m.data[key] = value\n    return nil\n}\n\n// Using the mock in tests\nfunc TestService(t *testing.T) {\n    mock := NewMockDataStore()\n    mock.data[\"key1\"] = \"value1\"\n    \n    service := NewService(mock)\n    \n    result, err := service.Process(\"key1\")\n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n    \n    if result != \"processed: value1\" {\n        t.Errorf(\"got %q, want %q\", result, \"processed: value1\")\n    }\n    \n    // Verify mock was called correctly\n    if len(mock.getCalls) != 1 || mock.getCalls[0] != \"key1\" {\n        t.Errorf(\"unexpected Get calls: %v\", mock.getCalls)\n    }\n}\n\n// Stub with configurable behavior\ntype StubHTTPClient struct {\n    responses map[string]*http.Response\n    errors    map[string]error\n}\n\nfunc (s *StubHTTPClient) Do(req *http.Request) (*http.Response, error) {\n    key := req.Method + \" \" + req.URL.String()\n    \n    if err, ok := s.errors[key]; ok {\n        return nil, err\n    }\n    \n    if resp, ok := s.responses[key]; ok {\n        return resp, nil\n    }\n    \n    return &http.Response{\n        StatusCode: 404,\n        Body:       io.NopCloser(strings.NewReader(\"Not Found\")),\n    }, nil\n}\n```\n\n### Using testify/mock\n```go\nimport (\n    \"github.com/stretchr/testify/mock\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// Mock using testify\ntype MockRepository struct {\n    mock.Mock\n}\n\nfunc (m *MockRepository) GetUser(id int) (*User, error) {\n    args := m.Called(id)\n    if args.Get(0) == nil {\n        return nil, args.Error(1)\n    }\n    return args.Get(0).(*User), args.Error(1)\n}\n\nfunc (m *MockRepository) SaveUser(user *User) error {\n    args := m.Called(user)\n    return args.Error(0)\n}\n\nfunc TestUserService(t *testing.T) {\n    // Create mock\n    mockRepo := new(MockRepository)\n    \n    // Set expectations\n    mockRepo.On(\"GetUser\", 1).Return(&User{ID: 1, Name: \"Alice\"}, nil)\n    mockRepo.On(\"SaveUser\", mock.Anything).Return(nil)\n    \n    // Create service with mock\n    service := NewUserService(mockRepo)\n    \n    // Test\n    user, err := service.GetUser(1)\n    assert.NoError(t, err)\n    assert.Equal(t, \"Alice\", user.Name)\n    \n    // Verify expectations were met\n    mockRepo.AssertExpectations(t)\n}\n\n// Advanced mocking\nfunc TestComplexInteraction(t *testing.T) {\n    mockRepo := new(MockRepository)\n    \n    // Match specific arguments\n    mockRepo.On(\"GetUser\", mock.MatchedBy(func(id int) bool {\n        return id > 0\n    })).Return(&User{}, nil)\n    \n    // Return different values on successive calls\n    mockRepo.On(\"SaveUser\", mock.Anything).\n        Return(errors.New(\"first error\")).Once()\n    mockRepo.On(\"SaveUser\", mock.Anything).\n        Return(nil).Once()\n    \n    // Run function when called\n    mockRepo.On(\"GetUser\", 2).\n        Run(func(args mock.Arguments) {\n            id := args.Get(0).(int)\n            t.Logf(\"GetUser called with id: %d\", id)\n        }).\n        Return(&User{ID: 2}, nil)\n}\n```\n\n### Using gomock\n```go\n//go:generate mockgen -source=interface.go -destination=mocks/mock_interface.go\n\nimport (\n    \"github.com/golang/mock/gomock\"\n    \"myproject/mocks\"\n)\n\nfunc TestWithGoMock(t *testing.T) {\n    ctrl := gomock.NewController(t)\n    defer ctrl.Finish()\n    \n    mockStore := mocks.NewMockDataStore(ctrl)\n    \n    // Set expectations\n    mockStore.EXPECT().\n        Get(\"key1\").\n        Return(\"value1\", nil).\n        Times(1)\n    \n    mockStore.EXPECT().\n        Set(\"key2\", \"value2\").\n        Return(nil).\n        AnyTimes()\n    \n    // Ordered expectations\n    gomock.InOrder(\n        mockStore.EXPECT().Get(\"first\"),\n        mockStore.EXPECT().Get(\"second\"),\n        mockStore.EXPECT().Get(\"third\"),\n    )\n    \n    // Use mock in test\n    service := NewService(mockStore)\n    result := service.Process()\n    \n    assert.Equal(t, \"expected\", result)\n}\n```\n\n## Fuzz Testing\n\n### Basic Fuzzing\n```go\n// Fuzz test (Go 1.18+)\nfunc FuzzReverse(f *testing.F) {\n    // Add seed corpus\n    f.Add(\"hello\")\n    f.Add(\"world\")\n    f.Add(\"12345\")\n    f.Add(\"\")\n    f.Add(\"a\")\n    \n    // Fuzz target\n    f.Fuzz(func(t *testing.T, input string) {\n        reversed := Reverse(input)\n        doubleReversed := Reverse(reversed)\n        \n        // Property: reversing twice should give original\n        if input != doubleReversed {\n            t.Errorf(\"double reverse failed: input=%q, got=%q\", \n                input, doubleReversed)\n        }\n        \n        // Property: length should be same\n        if len(input) != len(reversed) {\n            t.Errorf(\"length mismatch: input=%d, reversed=%d\", \n                len(input), len(reversed))\n        }\n    })\n}\n\n// Fuzz with multiple inputs\nfunc FuzzAdd(f *testing.F) {\n    // Seed corpus\n    f.Add(int8(1), int8(2))\n    f.Add(int8(127), int8(1))\n    f.Add(int8(-128), int8(-1))\n    \n    f.Fuzz(func(t *testing.T, a, b int8) {\n        result := Add(a, b)\n        \n        // Check for overflow\n        if a > 0 && b > 0 && result < 0 {\n            t.Skip(\"overflow detected\")\n        }\n        if a < 0 && b < 0 && result > 0 {\n            t.Skip(\"underflow detected\")\n        }\n        \n        // Property: addition is commutative\n        if Add(a, b) != Add(b, a) {\n            t.Errorf(\"not commutative: Add(%d,%d) != Add(%d,%d)\", \n                a, b, b, a)\n        }\n    })\n}\n\n// Complex fuzzing\nfunc FuzzJSONParser(f *testing.F) {\n    // Add valid JSON seeds\n    f.Add(`{\"key\": \"value\"}`)\n    f.Add(`[1, 2, 3]`)\n    f.Add(`null`)\n    f.Add(`true`)\n    f.Add(`123.45`)\n    f.Add(`\"string\"`)\n    \n    f.Fuzz(func(t *testing.T, input string) {\n        parsed, err := ParseJSON(input)\n        if err != nil {\n            // Invalid JSON is expected sometimes\n            return\n        }\n        \n        // If parsing succeeded, marshaling should work\n        marshaled, err := json.Marshal(parsed)\n        if err != nil {\n            t.Fatalf(\"failed to marshal parsed JSON: %v\", err)\n        }\n        \n        // Parse again and compare\n        var reparsed interface{}\n        if err := json.Unmarshal(marshaled, &reparsed); err != nil {\n            t.Fatalf(\"failed to unmarshal: %v\", err)\n        }\n        \n        if !reflect.DeepEqual(parsed, reparsed) {\n            t.Errorf(\"roundtrip failed: %v != %v\", parsed, reparsed)\n        }\n    })\n}\n```\n\n## Benchmarks\n\n### Basic Benchmarks\n```go\nfunc BenchmarkAdd(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        Add(2, 3)\n    }\n}\n\n// Benchmark with setup\nfunc BenchmarkComplexOperation(b *testing.B) {\n    // Setup is not counted in benchmark time\n    data := generateTestData()\n    \n    b.ResetTimer() // Reset timer after setup\n    \n    for i := 0; i < b.N; i++ {\n        ProcessData(data)\n    }\n}\n\n// Benchmark with cleanup\nfunc BenchmarkWithCleanup(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        b.StopTimer() // Pause timer for cleanup\n        cleanup()\n        b.StartTimer() // Resume timer\n        \n        ExpensiveOperation()\n    }\n}\n\n// Parallel benchmarks\nfunc BenchmarkParallel(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            ConcurrentOperation()\n        }\n    })\n}\n\n// Sub-benchmarks\nfunc BenchmarkSort(b *testing.B) {\n    sizes := []int{10, 100, 1000, 10000}\n    \n    for _, size := range sizes {\n        b.Run(fmt.Sprintf(\"size-%d\", size), func(b *testing.B) {\n            data := generateData(size)\n            b.ResetTimer()\n            \n            for i := 0; i < b.N; i++ {\n                b.StopTimer()\n                unsorted := make([]int, len(data))\n                copy(unsorted, data)\n                b.StartTimer()\n                \n                Sort(unsorted)\n            }\n        })\n    }\n}\n\n// Memory allocation benchmarks\nfunc BenchmarkMemory(b *testing.B) {\n    b.ReportAllocs() // Report memory allocations\n    \n    for i := 0; i < b.N; i++ {\n        result := AllocatingFunction()\n        _ = result\n    }\n}\n\n// Custom metrics\nfunc BenchmarkCustomMetric(b *testing.B) {\n    var totalBytes int64\n    \n    for i := 0; i < b.N; i++ {\n        bytes := ProcessFile(\"test.txt\")\n        totalBytes += bytes\n    }\n    \n    b.SetBytes(totalBytes / int64(b.N)) // Bytes processed per operation\n    b.ReportMetric(float64(totalBytes)/float64(b.N), \"bytes/op\")\n}\n\n// Comparative benchmarks\nfunc BenchmarkImplementations(b *testing.B) {\n    b.Run(\"Implementation1\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            Implementation1()\n        }\n    })\n    \n    b.Run(\"Implementation2\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            Implementation2()\n        }\n    })\n    \n    b.Run(\"Implementation3\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            Implementation3()\n        }\n    })\n}\n```\n\n## Coverage\n\n### Running Coverage\n```bash\n# Run tests with coverage\ngo test -cover\n\n# Generate coverage profile\ngo test -coverprofile=coverage.out\n\n# View coverage in browser\ngo tool cover -html=coverage.out\n\n# Coverage for specific functions\ngo tool cover -func=coverage.out\n\n# Coverage with multiple packages\ngo test -coverprofile=coverage.out ./...\n\n# Coverage mode\ngo test -covermode=count -coverprofile=coverage.out\n# Modes: set (default), count, atomic\n\n# Exclude files from coverage\n# Use build tags\n//go:build !test\n```\n\n### Coverage in Code\n```go\n// Ensuring coverage\nfunc TestFullCoverage(t *testing.T) {\n    tests := []struct {\n        name  string\n        input int\n        want  string\n    }{\n        {\"positive\", 1, \"positive\"},\n        {\"negative\", -1, \"negative\"},\n        {\"zero\", 0, \"zero\"}, // Cover all branches\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got := Classify(tt.input)\n            if got != tt.want {\n                t.Errorf(\"Classify(%d) = %q, want %q\", \n                    tt.input, got, tt.want)\n            }\n        })\n    }\n}\n\n// Testing error paths for coverage\nfunc TestErrorPaths(t *testing.T) {\n    // Test success path\n    result, err := RiskyOperation(validInput)\n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n    \n    // Test error path 1\n    _, err = RiskyOperation(invalidInput1)\n    if err == nil {\n        t.Error(\"expected error for invalid input 1\")\n    }\n    \n    // Test error path 2\n    _, err = RiskyOperation(invalidInput2)\n    if err == nil {\n        t.Error(\"expected error for invalid input 2\")\n    }\n}\n```\n\n## Integration Tests\n\n### Database Integration Tests\n```go\n//go:build integration\n\npackage db_test\n\nimport (\n    \"database/sql\"\n    \"testing\"\n    _ \"github.com/lib/pq\"\n)\n\nfunc TestDatabaseIntegration(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"skipping integration test in short mode\")\n    }\n    \n    // Connect to test database\n    db, err := sql.Open(\"postgres\", getTestDatabaseURL())\n    if err != nil {\n        t.Fatalf(\"failed to connect: %v\", err)\n    }\n    defer db.Close()\n    \n    // Run migrations\n    if err := runMigrations(db); err != nil {\n        t.Fatalf(\"failed to run migrations: %v\", err)\n    }\n    \n    // Test repository\n    repo := NewUserRepository(db)\n    \n    t.Run(\"Create\", func(t *testing.T) {\n        user := &User{Name: \"Alice\", Email: \"alice@example.com\"}\n        err := repo.Create(user)\n        if err != nil {\n            t.Fatalf(\"failed to create user: %v\", err)\n        }\n        if user.ID == 0 {\n            t.Error(\"expected user ID to be set\")\n        }\n    })\n    \n    t.Run(\"Transaction\", func(t *testing.T) {\n        tx, err := db.Begin()\n        if err != nil {\n            t.Fatal(err)\n        }\n        defer tx.Rollback()\n        \n        // Operations in transaction\n        repoTx := NewUserRepositoryTx(tx)\n        // ... test operations\n        \n        if err := tx.Commit(); err != nil {\n            t.Fatal(err)\n        }\n    })\n}\n\n// HTTP Integration Tests\nfunc TestHTTPIntegration(t *testing.T) {\n    // Start test server\n    server := httptest.NewServer(NewRouter())\n    defer server.Close()\n    \n    client := server.Client()\n    \n    t.Run(\"GET /users\", func(t *testing.T) {\n        resp, err := client.Get(server.URL + \"/users\")\n        if err != nil {\n            t.Fatal(err)\n        }\n        defer resp.Body.Close()\n        \n        if resp.StatusCode != http.StatusOK {\n            t.Errorf(\"expected status 200, got %d\", resp.StatusCode)\n        }\n        \n        var users []User\n        if err := json.NewDecoder(resp.Body).Decode(&users); err != nil {\n            t.Fatal(err)\n        }\n    })\n    \n    t.Run(\"POST /users\", func(t *testing.T) {\n        user := User{Name: \"Bob\", Email: \"bob@example.com\"}\n        body, _ := json.Marshal(user)\n        \n        resp, err := client.Post(\n            server.URL+\"/users\",\n            \"application/json\",\n            bytes.NewReader(body),\n        )\n        if err != nil {\n            t.Fatal(err)\n        }\n        defer resp.Body.Close()\n        \n        if resp.StatusCode != http.StatusCreated {\n            t.Errorf(\"expected status 201, got %d\", resp.StatusCode)\n        }\n    })\n}\n```\n\n### Container Integration Tests\n```go\nimport (\n    \"github.com/testcontainers/testcontainers-go\"\n    \"github.com/testcontainers/testcontainers-go/wait\"\n)\n\nfunc TestWithRedis(t *testing.T) {\n    ctx := context.Background()\n    \n    // Start Redis container\n    req := testcontainers.ContainerRequest{\n        Image:        \"redis:latest\",\n        ExposedPorts: []string{\"6379/tcp\"},\n        WaitingFor:   wait.ForLog(\"Ready to accept connections\"),\n    }\n    \n    redis, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{\n        ContainerRequest: req,\n        Started:          true,\n    })\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer redis.Terminate(ctx)\n    \n    // Get connection details\n    host, err := redis.Host(ctx)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    port, err := redis.MappedPort(ctx, \"6379\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    // Connect to Redis\n    client := NewRedisClient(host, port.Port())\n    \n    // Run tests\n    t.Run(\"Set and Get\", func(t *testing.T) {\n        err := client.Set(\"key\", \"value\")\n        if err != nil {\n            t.Fatal(err)\n        }\n        \n        val, err := client.Get(\"key\")\n        if err != nil {\n            t.Fatal(err)\n        }\n        \n        if val != \"value\" {\n            t.Errorf(\"got %q, want %q\", val, \"value\")\n        }\n    })\n}\n```\n\n## Test Fixtures and Helpers\n\n### Test Fixtures\n```go\n// fixtures.go\npackage testutil\n\ntype Fixtures struct {\n    Users    []*User\n    Products []*Product\n    Orders   []*Order\n}\n\nfunc LoadFixtures() *Fixtures {\n    return &Fixtures{\n        Users: []*User{\n            {ID: 1, Name: \"Alice\", Email: \"alice@example.com\"},\n            {ID: 2, Name: \"Bob\", Email: \"bob@example.com\"},\n        },\n        Products: []*Product{\n            {ID: 1, Name: \"Widget\", Price: 9.99},\n            {ID: 2, Name: \"Gadget\", Price: 19.99},\n        },\n        Orders: []*Order{\n            {ID: 1, UserID: 1, Total: 29.98},\n        },\n    }\n}\n\n// Test data builders\ntype UserBuilder struct {\n    user User\n}\n\nfunc NewUserBuilder() *UserBuilder {\n    return &UserBuilder{\n        user: User{\n            ID:    1,\n            Name:  \"Test User\",\n            Email: \"test@example.com\",\n        },\n    }\n}\n\nfunc (b *UserBuilder) WithName(name string) *UserBuilder {\n    b.user.Name = name\n    return b\n}\n\nfunc (b *UserBuilder) WithEmail(email string) *UserBuilder {\n    b.user.Email = email\n    return b\n}\n\nfunc (b *UserBuilder) Build() *User {\n    return &b.user\n}\n\n// Usage\nfunc TestWithBuilder(t *testing.T) {\n    user := NewUserBuilder().\n        WithName(\"Alice\").\n        WithEmail(\"alice@test.com\").\n        Build()\n    \n    // Test with user...\n}\n```\n\n### Test Helpers\n```go\n// helpers.go\npackage testutil\n\n// Test database helper\nfunc SetupTestDB(t testing.TB) *sql.DB {\n    t.Helper()\n    \n    db, err := sql.Open(\"sqlite3\", \":memory:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if err := runMigrations(db); err != nil {\n        t.Fatal(err)\n    }\n    \n    t.Cleanup(func() {\n        db.Close()\n    })\n    \n    return db\n}\n\n// Temporary directory helper\nfunc TempDir(t testing.TB) string {\n    t.Helper()\n    \n    dir, err := os.MkdirTemp(\"\", \"test\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    t.Cleanup(func() {\n        os.RemoveAll(dir)\n    })\n    \n    return dir\n}\n\n// Assert helpers\nfunc AssertEqual(t testing.TB, got, want interface{}) {\n    t.Helper()\n    \n    if !reflect.DeepEqual(got, want) {\n        t.Errorf(\"got %v, want %v\", got, want)\n    }\n}\n\nfunc AssertNoError(t testing.TB, err error) {\n    t.Helper()\n    \n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n}\n\nfunc AssertError(t testing.TB, err error) {\n    t.Helper()\n    \n    if err == nil {\n        t.Fatal(\"expected error, got nil\")\n    }\n}\n\n// Golden file helper\nfunc GoldenFile(t testing.TB, name string, got []byte) {\n    t.Helper()\n    \n    golden := filepath.Join(\"testdata\", name+\".golden\")\n    \n    if *update {\n        os.WriteFile(golden, got, 0644)\n        return\n    }\n    \n    want, err := os.ReadFile(golden)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if !bytes.Equal(got, want) {\n        t.Errorf(\"output mismatch for %s\", name)\n    }\n}\n```\n\n## Advanced Testing Techniques\n\n### Property-Based Testing\n```go\nimport \"github.com/leanovate/gopter\"\n\nfunc TestPropertyBased(t *testing.T) {\n    properties := gopter.NewProperties(nil)\n    \n    properties.Property(\"reverse twice is identity\", prop.ForAll(\n        func(s string) bool {\n            return s == Reverse(Reverse(s))\n        },\n        gopter.Gen.String(),\n    ))\n    \n    properties.Property(\"list append preserves length\", prop.ForAll(\n        func(list []int, item int) bool {\n            original := len(list)\n            result := append(list, item)\n            return len(result) == original+1\n        },\n        gopter.Gen.SliceOf(gopter.Gen.Int()),\n        gopter.Gen.Int(),\n    ))\n    \n    properties.TestingRun(t)\n}\n```\n\n### Snapshot Testing\n```go\nfunc TestSnapshot(t *testing.T) {\n    data := generateComplexData()\n    output := RenderHTML(data)\n    \n    snapshot := filepath.Join(\"testdata\", t.Name()+\".snapshot\")\n    \n    if *updateSnapshots {\n        if err := os.WriteFile(snapshot, []byte(output), 0644); err != nil {\n            t.Fatal(err)\n        }\n        return\n    }\n    \n    expected, err := os.ReadFile(snapshot)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if output != string(expected) {\n        t.Error(\"snapshot mismatch\")\n        // Could use diff library to show differences\n    }\n}\n```\n\n### Contract Testing\n```go\n// Define contract that implementations must satisfy\ntype StorageContract struct {\n    t       testing.TB\n    storage Storage\n}\n\nfunc (c *StorageContract) TestStore() {\n    c.t.Helper()\n    \n    err := c.storage.Store(\"key\", \"value\")\n    if err != nil {\n        c.t.Errorf(\"Store failed: %v\", err)\n    }\n    \n    val, err := c.storage.Retrieve(\"key\")\n    if err != nil {\n        c.t.Errorf(\"Retrieve failed: %v\", err)\n    }\n    \n    if val != \"value\" {\n        c.t.Errorf(\"got %q, want %q\", val, \"value\")\n    }\n}\n\nfunc (c *StorageContract) TestDelete() {\n    c.t.Helper()\n    \n    c.storage.Store(\"key\", \"value\")\n    err := c.storage.Delete(\"key\")\n    if err != nil {\n        c.t.Errorf(\"Delete failed: %v\", err)\n    }\n    \n    _, err = c.storage.Retrieve(\"key\")\n    if err == nil {\n        c.t.Error(\"expected error after delete\")\n    }\n}\n\n// Test different implementations\nfunc TestMemoryStorage(t *testing.T) {\n    storage := NewMemoryStorage()\n    contract := &StorageContract{t: t, storage: storage}\n    contract.TestStore()\n    contract.TestDelete()\n}\n\nfunc TestDiskStorage(t *testing.T) {\n    storage := NewDiskStorage(t.TempDir())\n    contract := &StorageContract{t: t, storage: storage}\n    contract.TestStore()\n    contract.TestDelete()\n}\n```\n\n## Best Practices Summary\n\n1. **Write table-driven tests** - Comprehensive and maintainable\n2. **Use subtests** - Better organization and parallel execution\n3. **Mock external dependencies** - Fast and reliable tests\n4. **Test edge cases** - Empty inputs, nil values, errors\n5. **Benchmark critical paths** - Measure performance\n6. **Aim for high coverage** - But focus on meaningful tests\n7. **Use t.Helper()** - Better error reporting in test helpers\n8. **Cleanup with t.Cleanup()** - Guaranteed cleanup\n9. **Use build tags for integration tests** - Separate slow tests\n10. **Keep tests deterministic** - No random failures"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":70863,"cache_read_input_tokens":0,"output_tokens":10064,"service_tier":"standard"}},"requestId":"req_011CS5JYeqStg2k1P9kmXbaY","type":"assistant","uuid":"d2f07539-bf65-4669-9109-06387d54d880","timestamp":"2025-08-13T07:22:46.970Z"}
{"parentUuid":"d2f07539-bf65-4669-9109-06387d54d880","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016rCZU1ZfXJgwrcyeydJvuG","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/go-testing.md"}]},"uuid":"471dd8b0-0026-45cd-979f-6713dee7ffd1","timestamp":"2025-08-13T07:22:47.011Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-testing.md","content":"# Go Testing - Complete Testing Guide\n\n## Table of Contents\n1. [Unit Tests](#unit-tests)\n2. [Table-Driven Tests](#table-driven-tests)\n3. [Subtests](#subtests)\n4. [Mocks and Stubs](#mocks-and-stubs)\n5. [Fuzz Testing](#fuzz-testing)\n6. [Benchmarks](#benchmarks)\n7. [Coverage](#coverage)\n8. [Integration Tests](#integration-tests)\n9. [Test Fixtures and Helpers](#test-fixtures-and-helpers)\n10. [Advanced Testing Techniques](#advanced-testing-techniques)\n\n## Unit Tests\n\n### Basic Test Structure\n```go\n// File: math.go\npackage math\n\nfunc Add(a, b int) int {\n    return a + b\n}\n\n// File: math_test.go\npackage math\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n    result := Add(2, 3)\n    expected := 5\n    \n    if result != expected {\n        t.Errorf(\"Add(2, 3) = %d; want %d\", result, expected)\n    }\n}\n\n// Test with multiple assertions\nfunc TestMultipleAssertions(t *testing.T) {\n    // Arrange\n    input := \"test\"\n    \n    // Act\n    result := Process(input)\n    \n    // Assert\n    if result.Status != \"success\" {\n        t.Errorf(\"expected status 'success', got %q\", result.Status)\n    }\n    \n    if len(result.Data) == 0 {\n        t.Error(\"expected non-empty data\")\n    }\n    \n    if result.Timestamp.IsZero() {\n        t.Error(\"expected non-zero timestamp\")\n    }\n}\n\n// Using t.Fatal for critical failures\nfunc TestCriticalFailure(t *testing.T) {\n    db, err := connectDB()\n    if err != nil {\n        t.Fatalf(\"failed to connect to database: %v\", err)\n    }\n    defer db.Close()\n    \n    // Continue with test...\n}\n\n// Using t.Skip for conditional tests\nfunc TestRequiresDocker(t *testing.T) {\n    if !dockerAvailable() {\n        t.Skip(\"skipping test; Docker not available\")\n    }\n    \n    // Docker-dependent test...\n}\n\n// Parallel tests\nfunc TestParallel1(t *testing.T) {\n    t.Parallel() // Run in parallel with other parallel tests\n    // Test implementation...\n}\n\nfunc TestParallel2(t *testing.T) {\n    t.Parallel()\n    // Test implementation...\n}\n```\n\n### Test Organization\n```go\n// Testing exported functions\nfunc TestPublicFunction(t *testing.T) {\n    result := PublicFunction(\"input\")\n    if result != \"expected\" {\n        t.Errorf(\"got %q, want %q\", result, \"expected\")\n    }\n}\n\n// Testing unexported functions (same package)\nfunc TestPrivateFunction(t *testing.T) {\n    result := privateFunction(\"input\")\n    if result != \"expected\" {\n        t.Errorf(\"got %q, want %q\", result, \"expected\")\n    }\n}\n\n// Testing with external package (black-box testing)\npackage math_test\n\nimport (\n    \"testing\"\n    \"myproject/math\"\n)\n\nfunc TestAddExternal(t *testing.T) {\n    result := math.Add(2, 3)\n    if result != 5 {\n        t.Errorf(\"math.Add(2, 3) = %d; want 5\", result)\n    }\n}\n\n// Example tests (show up in documentation)\nfunc ExampleAdd() {\n    result := Add(2, 3)\n    fmt.Println(result)\n    // Output: 5\n}\n\nfunc ExampleAdd_negative() {\n    result := Add(-2, -3)\n    fmt.Println(result)\n    // Output: -5\n}\n\n// Testing main function\nfunc TestMain(m *testing.M) {\n    // Setup before tests\n    setup()\n    \n    // Run tests\n    code := m.Run()\n    \n    // Cleanup after tests\n    teardown()\n    \n    os.Exit(code)\n}\n```\n\n## Table-Driven Tests\n\n### Basic Table-Driven Tests\n```go\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name     string\n        a, b     int\n        expected int\n    }{\n        {\"positive numbers\", 2, 3, 5},\n        {\"negative numbers\", -2, -3, -5},\n        {\"mixed\", -5, 10, 5},\n        {\"with zero\", 0, 5, 5},\n        {\"both zero\", 0, 0, 0},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := Add(tt.a, tt.b)\n            if result != tt.expected {\n                t.Errorf(\"Add(%d, %d) = %d; want %d\", \n                    tt.a, tt.b, result, tt.expected)\n            }\n        })\n    }\n}\n\n// Table-driven tests with errors\nfunc TestDivide(t *testing.T) {\n    tests := []struct {\n        name      string\n        dividend  float64\n        divisor   float64\n        want      float64\n        wantErr   bool\n        errString string\n    }{\n        {\n            name:     \"normal division\",\n            dividend: 10,\n            divisor:  2,\n            want:     5,\n            wantErr:  false,\n        },\n        {\n            name:      \"divide by zero\",\n            dividend:  10,\n            divisor:   0,\n            want:      0,\n            wantErr:   true,\n            errString: \"division by zero\",\n        },\n        {\n            name:     \"negative division\",\n            dividend: -10,\n            divisor:  2,\n            want:     -5,\n            wantErr:  false,\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := Divide(tt.dividend, tt.divisor)\n            \n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Divide() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            \n            if tt.wantErr && err.Error() != tt.errString {\n                t.Errorf(\"Divide() error = %q, want %q\", err.Error(), tt.errString)\n                return\n            }\n            \n            if got != tt.want {\n                t.Errorf(\"Divide() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n\n// Complex table-driven tests\nfunc TestParser(t *testing.T) {\n    tests := []struct {\n        name    string\n        input   string\n        setup   func()\n        cleanup func()\n        want    *Result\n        wantErr bool\n        check   func(t *testing.T, got *Result)\n    }{\n        {\n            name:  \"valid JSON\",\n            input: `{\"key\": \"value\"}`,\n            want: &Result{\n                Type: \"object\",\n                Data: map[string]interface{}{\"key\": \"value\"},\n            },\n        },\n        {\n            name:  \"complex validation\",\n            input: `{\"items\": [1, 2, 3]}`,\n            check: func(t *testing.T, got *Result) {\n                if got.Type != \"object\" {\n                    t.Errorf(\"wrong type: %s\", got.Type)\n                }\n                items, ok := got.Data.(map[string]interface{})[\"items\"].([]interface{})\n                if !ok || len(items) != 3 {\n                    t.Error(\"expected 3 items\")\n                }\n            },\n        },\n        {\n            name: \"with setup\",\n            input: \"special\",\n            setup: func() {\n                // Prepare test environment\n                os.Setenv(\"TEST_MODE\", \"special\")\n            },\n            cleanup: func() {\n                os.Unsetenv(\"TEST_MODE\")\n            },\n            want: &Result{Type: \"special\"},\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if tt.setup != nil {\n                tt.setup()\n            }\n            if tt.cleanup != nil {\n                defer tt.cleanup()\n            }\n            \n            got, err := Parse(tt.input)\n            \n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            \n            if tt.check != nil {\n                tt.check(t, got)\n            } else if !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\n## Subtests\n\n### Using Subtests\n```go\nfunc TestFeature(t *testing.T) {\n    // Setup shared by all subtests\n    db := setupTestDB(t)\n    defer db.Close()\n    \n    t.Run(\"Create\", func(t *testing.T) {\n        // Can run in parallel with other subtests\n        t.Parallel()\n        \n        err := db.Create(&User{Name: \"Alice\"})\n        if err != nil {\n            t.Errorf(\"failed to create user: %v\", err)\n        }\n    })\n    \n    t.Run(\"Read\", func(t *testing.T) {\n        t.Parallel()\n        \n        user, err := db.Read(1)\n        if err != nil {\n            t.Errorf(\"failed to read user: %v\", err)\n        }\n        if user.Name != \"Alice\" {\n            t.Errorf(\"wrong name: got %q, want %q\", user.Name, \"Alice\")\n        }\n    })\n    \n    t.Run(\"Update\", func(t *testing.T) {\n        t.Parallel()\n        \n        err := db.Update(1, &User{Name: \"Bob\"})\n        if err != nil {\n            t.Errorf(\"failed to update user: %v\", err)\n        }\n    })\n    \n    t.Run(\"Delete\", func(t *testing.T) {\n        t.Parallel()\n        \n        err := db.Delete(1)\n        if err != nil {\n            t.Errorf(\"failed to delete user: %v\", err)\n        }\n    })\n}\n\n// Nested subtests\nfunc TestComplexFeature(t *testing.T) {\n    t.Run(\"Component1\", func(t *testing.T) {\n        t.Run(\"Subcomponent1\", func(t *testing.T) {\n            // Test specific functionality\n        })\n        \n        t.Run(\"Subcomponent2\", func(t *testing.T) {\n            // Test specific functionality\n        })\n    })\n    \n    t.Run(\"Component2\", func(t *testing.T) {\n        t.Run(\"Subcomponent1\", func(t *testing.T) {\n            // Test specific functionality\n        })\n    })\n}\n\n// Dynamic subtests\nfunc TestDynamicSubtests(t *testing.T) {\n    scenarios := loadTestScenarios()\n    \n    for _, scenario := range scenarios {\n        scenario := scenario // Capture range variable\n        t.Run(scenario.Name, func(t *testing.T) {\n            t.Parallel()\n            \n            result := ProcessScenario(scenario)\n            if !result.Success {\n                t.Errorf(\"scenario %q failed: %v\", scenario.Name, result.Error)\n            }\n        })\n    }\n}\n```\n\n## Mocks and Stubs\n\n### Manual Mocks\n```go\n// Interface to mock\ntype DataStore interface {\n    Get(key string) (string, error)\n    Set(key, value string) error\n}\n\n// Mock implementation\ntype MockDataStore struct {\n    data      map[string]string\n    getCalls  []string\n    setCalls  []struct{ key, value string }\n    getError  error\n    setError  error\n}\n\nfunc NewMockDataStore() *MockDataStore {\n    return &MockDataStore{\n        data: make(map[string]string),\n    }\n}\n\nfunc (m *MockDataStore) Get(key string) (string, error) {\n    m.getCalls = append(m.getCalls, key)\n    if m.getError != nil {\n        return \"\", m.getError\n    }\n    return m.data[key], nil\n}\n\nfunc (m *MockDataStore) Set(key, value string) error {\n    m.setCalls = append(m.setCalls, struct{ key, value string }{key, value})\n    if m.setError != nil {\n        return m.setError\n    }\n    m.data[key] = value\n    return nil\n}\n\n// Using the mock in tests\nfunc TestService(t *testing.T) {\n    mock := NewMockDataStore()\n    mock.data[\"key1\"] = \"value1\"\n    \n    service := NewService(mock)\n    \n    result, err := service.Process(\"key1\")\n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n    \n    if result != \"processed: value1\" {\n        t.Errorf(\"got %q, want %q\", result, \"processed: value1\")\n    }\n    \n    // Verify mock was called correctly\n    if len(mock.getCalls) != 1 || mock.getCalls[0] != \"key1\" {\n        t.Errorf(\"unexpected Get calls: %v\", mock.getCalls)\n    }\n}\n\n// Stub with configurable behavior\ntype StubHTTPClient struct {\n    responses map[string]*http.Response\n    errors    map[string]error\n}\n\nfunc (s *StubHTTPClient) Do(req *http.Request) (*http.Response, error) {\n    key := req.Method + \" \" + req.URL.String()\n    \n    if err, ok := s.errors[key]; ok {\n        return nil, err\n    }\n    \n    if resp, ok := s.responses[key]; ok {\n        return resp, nil\n    }\n    \n    return &http.Response{\n        StatusCode: 404,\n        Body:       io.NopCloser(strings.NewReader(\"Not Found\")),\n    }, nil\n}\n```\n\n### Using testify/mock\n```go\nimport (\n    \"github.com/stretchr/testify/mock\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n// Mock using testify\ntype MockRepository struct {\n    mock.Mock\n}\n\nfunc (m *MockRepository) GetUser(id int) (*User, error) {\n    args := m.Called(id)\n    if args.Get(0) == nil {\n        return nil, args.Error(1)\n    }\n    return args.Get(0).(*User), args.Error(1)\n}\n\nfunc (m *MockRepository) SaveUser(user *User) error {\n    args := m.Called(user)\n    return args.Error(0)\n}\n\nfunc TestUserService(t *testing.T) {\n    // Create mock\n    mockRepo := new(MockRepository)\n    \n    // Set expectations\n    mockRepo.On(\"GetUser\", 1).Return(&User{ID: 1, Name: \"Alice\"}, nil)\n    mockRepo.On(\"SaveUser\", mock.Anything).Return(nil)\n    \n    // Create service with mock\n    service := NewUserService(mockRepo)\n    \n    // Test\n    user, err := service.GetUser(1)\n    assert.NoError(t, err)\n    assert.Equal(t, \"Alice\", user.Name)\n    \n    // Verify expectations were met\n    mockRepo.AssertExpectations(t)\n}\n\n// Advanced mocking\nfunc TestComplexInteraction(t *testing.T) {\n    mockRepo := new(MockRepository)\n    \n    // Match specific arguments\n    mockRepo.On(\"GetUser\", mock.MatchedBy(func(id int) bool {\n        return id > 0\n    })).Return(&User{}, nil)\n    \n    // Return different values on successive calls\n    mockRepo.On(\"SaveUser\", mock.Anything).\n        Return(errors.New(\"first error\")).Once()\n    mockRepo.On(\"SaveUser\", mock.Anything).\n        Return(nil).Once()\n    \n    // Run function when called\n    mockRepo.On(\"GetUser\", 2).\n        Run(func(args mock.Arguments) {\n            id := args.Get(0).(int)\n            t.Logf(\"GetUser called with id: %d\", id)\n        }).\n        Return(&User{ID: 2}, nil)\n}\n```\n\n### Using gomock\n```go\n//go:generate mockgen -source=interface.go -destination=mocks/mock_interface.go\n\nimport (\n    \"github.com/golang/mock/gomock\"\n    \"myproject/mocks\"\n)\n\nfunc TestWithGoMock(t *testing.T) {\n    ctrl := gomock.NewController(t)\n    defer ctrl.Finish()\n    \n    mockStore := mocks.NewMockDataStore(ctrl)\n    \n    // Set expectations\n    mockStore.EXPECT().\n        Get(\"key1\").\n        Return(\"value1\", nil).\n        Times(1)\n    \n    mockStore.EXPECT().\n        Set(\"key2\", \"value2\").\n        Return(nil).\n        AnyTimes()\n    \n    // Ordered expectations\n    gomock.InOrder(\n        mockStore.EXPECT().Get(\"first\"),\n        mockStore.EXPECT().Get(\"second\"),\n        mockStore.EXPECT().Get(\"third\"),\n    )\n    \n    // Use mock in test\n    service := NewService(mockStore)\n    result := service.Process()\n    \n    assert.Equal(t, \"expected\", result)\n}\n```\n\n## Fuzz Testing\n\n### Basic Fuzzing\n```go\n// Fuzz test (Go 1.18+)\nfunc FuzzReverse(f *testing.F) {\n    // Add seed corpus\n    f.Add(\"hello\")\n    f.Add(\"world\")\n    f.Add(\"12345\")\n    f.Add(\"\")\n    f.Add(\"a\")\n    \n    // Fuzz target\n    f.Fuzz(func(t *testing.T, input string) {\n        reversed := Reverse(input)\n        doubleReversed := Reverse(reversed)\n        \n        // Property: reversing twice should give original\n        if input != doubleReversed {\n            t.Errorf(\"double reverse failed: input=%q, got=%q\", \n                input, doubleReversed)\n        }\n        \n        // Property: length should be same\n        if len(input) != len(reversed) {\n            t.Errorf(\"length mismatch: input=%d, reversed=%d\", \n                len(input), len(reversed))\n        }\n    })\n}\n\n// Fuzz with multiple inputs\nfunc FuzzAdd(f *testing.F) {\n    // Seed corpus\n    f.Add(int8(1), int8(2))\n    f.Add(int8(127), int8(1))\n    f.Add(int8(-128), int8(-1))\n    \n    f.Fuzz(func(t *testing.T, a, b int8) {\n        result := Add(a, b)\n        \n        // Check for overflow\n        if a > 0 && b > 0 && result < 0 {\n            t.Skip(\"overflow detected\")\n        }\n        if a < 0 && b < 0 && result > 0 {\n            t.Skip(\"underflow detected\")\n        }\n        \n        // Property: addition is commutative\n        if Add(a, b) != Add(b, a) {\n            t.Errorf(\"not commutative: Add(%d,%d) != Add(%d,%d)\", \n                a, b, b, a)\n        }\n    })\n}\n\n// Complex fuzzing\nfunc FuzzJSONParser(f *testing.F) {\n    // Add valid JSON seeds\n    f.Add(`{\"key\": \"value\"}`)\n    f.Add(`[1, 2, 3]`)\n    f.Add(`null`)\n    f.Add(`true`)\n    f.Add(`123.45`)\n    f.Add(`\"string\"`)\n    \n    f.Fuzz(func(t *testing.T, input string) {\n        parsed, err := ParseJSON(input)\n        if err != nil {\n            // Invalid JSON is expected sometimes\n            return\n        }\n        \n        // If parsing succeeded, marshaling should work\n        marshaled, err := json.Marshal(parsed)\n        if err != nil {\n            t.Fatalf(\"failed to marshal parsed JSON: %v\", err)\n        }\n        \n        // Parse again and compare\n        var reparsed interface{}\n        if err := json.Unmarshal(marshaled, &reparsed); err != nil {\n            t.Fatalf(\"failed to unmarshal: %v\", err)\n        }\n        \n        if !reflect.DeepEqual(parsed, reparsed) {\n            t.Errorf(\"roundtrip failed: %v != %v\", parsed, reparsed)\n        }\n    })\n}\n```\n\n## Benchmarks\n\n### Basic Benchmarks\n```go\nfunc BenchmarkAdd(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        Add(2, 3)\n    }\n}\n\n// Benchmark with setup\nfunc BenchmarkComplexOperation(b *testing.B) {\n    // Setup is not counted in benchmark time\n    data := generateTestData()\n    \n    b.ResetTimer() // Reset timer after setup\n    \n    for i := 0; i < b.N; i++ {\n        ProcessData(data)\n    }\n}\n\n// Benchmark with cleanup\nfunc BenchmarkWithCleanup(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        b.StopTimer() // Pause timer for cleanup\n        cleanup()\n        b.StartTimer() // Resume timer\n        \n        ExpensiveOperation()\n    }\n}\n\n// Parallel benchmarks\nfunc BenchmarkParallel(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            ConcurrentOperation()\n        }\n    })\n}\n\n// Sub-benchmarks\nfunc BenchmarkSort(b *testing.B) {\n    sizes := []int{10, 100, 1000, 10000}\n    \n    for _, size := range sizes {\n        b.Run(fmt.Sprintf(\"size-%d\", size), func(b *testing.B) {\n            data := generateData(size)\n            b.ResetTimer()\n            \n            for i := 0; i < b.N; i++ {\n                b.StopTimer()\n                unsorted := make([]int, len(data))\n                copy(unsorted, data)\n                b.StartTimer()\n                \n                Sort(unsorted)\n            }\n        })\n    }\n}\n\n// Memory allocation benchmarks\nfunc BenchmarkMemory(b *testing.B) {\n    b.ReportAllocs() // Report memory allocations\n    \n    for i := 0; i < b.N; i++ {\n        result := AllocatingFunction()\n        _ = result\n    }\n}\n\n// Custom metrics\nfunc BenchmarkCustomMetric(b *testing.B) {\n    var totalBytes int64\n    \n    for i := 0; i < b.N; i++ {\n        bytes := ProcessFile(\"test.txt\")\n        totalBytes += bytes\n    }\n    \n    b.SetBytes(totalBytes / int64(b.N)) // Bytes processed per operation\n    b.ReportMetric(float64(totalBytes)/float64(b.N), \"bytes/op\")\n}\n\n// Comparative benchmarks\nfunc BenchmarkImplementations(b *testing.B) {\n    b.Run(\"Implementation1\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            Implementation1()\n        }\n    })\n    \n    b.Run(\"Implementation2\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            Implementation2()\n        }\n    })\n    \n    b.Run(\"Implementation3\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            Implementation3()\n        }\n    })\n}\n```\n\n## Coverage\n\n### Running Coverage\n```bash\n# Run tests with coverage\ngo test -cover\n\n# Generate coverage profile\ngo test -coverprofile=coverage.out\n\n# View coverage in browser\ngo tool cover -html=coverage.out\n\n# Coverage for specific functions\ngo tool cover -func=coverage.out\n\n# Coverage with multiple packages\ngo test -coverprofile=coverage.out ./...\n\n# Coverage mode\ngo test -covermode=count -coverprofile=coverage.out\n# Modes: set (default), count, atomic\n\n# Exclude files from coverage\n# Use build tags\n//go:build !test\n```\n\n### Coverage in Code\n```go\n// Ensuring coverage\nfunc TestFullCoverage(t *testing.T) {\n    tests := []struct {\n        name  string\n        input int\n        want  string\n    }{\n        {\"positive\", 1, \"positive\"},\n        {\"negative\", -1, \"negative\"},\n        {\"zero\", 0, \"zero\"}, // Cover all branches\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got := Classify(tt.input)\n            if got != tt.want {\n                t.Errorf(\"Classify(%d) = %q, want %q\", \n                    tt.input, got, tt.want)\n            }\n        })\n    }\n}\n\n// Testing error paths for coverage\nfunc TestErrorPaths(t *testing.T) {\n    // Test success path\n    result, err := RiskyOperation(validInput)\n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n    \n    // Test error path 1\n    _, err = RiskyOperation(invalidInput1)\n    if err == nil {\n        t.Error(\"expected error for invalid input 1\")\n    }\n    \n    // Test error path 2\n    _, err = RiskyOperation(invalidInput2)\n    if err == nil {\n        t.Error(\"expected error for invalid input 2\")\n    }\n}\n```\n\n## Integration Tests\n\n### Database Integration Tests\n```go\n//go:build integration\n\npackage db_test\n\nimport (\n    \"database/sql\"\n    \"testing\"\n    _ \"github.com/lib/pq\"\n)\n\nfunc TestDatabaseIntegration(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"skipping integration test in short mode\")\n    }\n    \n    // Connect to test database\n    db, err := sql.Open(\"postgres\", getTestDatabaseURL())\n    if err != nil {\n        t.Fatalf(\"failed to connect: %v\", err)\n    }\n    defer db.Close()\n    \n    // Run migrations\n    if err := runMigrations(db); err != nil {\n        t.Fatalf(\"failed to run migrations: %v\", err)\n    }\n    \n    // Test repository\n    repo := NewUserRepository(db)\n    \n    t.Run(\"Create\", func(t *testing.T) {\n        user := &User{Name: \"Alice\", Email: \"alice@example.com\"}\n        err := repo.Create(user)\n        if err != nil {\n            t.Fatalf(\"failed to create user: %v\", err)\n        }\n        if user.ID == 0 {\n            t.Error(\"expected user ID to be set\")\n        }\n    })\n    \n    t.Run(\"Transaction\", func(t *testing.T) {\n        tx, err := db.Begin()\n        if err != nil {\n            t.Fatal(err)\n        }\n        defer tx.Rollback()\n        \n        // Operations in transaction\n        repoTx := NewUserRepositoryTx(tx)\n        // ... test operations\n        \n        if err := tx.Commit(); err != nil {\n            t.Fatal(err)\n        }\n    })\n}\n\n// HTTP Integration Tests\nfunc TestHTTPIntegration(t *testing.T) {\n    // Start test server\n    server := httptest.NewServer(NewRouter())\n    defer server.Close()\n    \n    client := server.Client()\n    \n    t.Run(\"GET /users\", func(t *testing.T) {\n        resp, err := client.Get(server.URL + \"/users\")\n        if err != nil {\n            t.Fatal(err)\n        }\n        defer resp.Body.Close()\n        \n        if resp.StatusCode != http.StatusOK {\n            t.Errorf(\"expected status 200, got %d\", resp.StatusCode)\n        }\n        \n        var users []User\n        if err := json.NewDecoder(resp.Body).Decode(&users); err != nil {\n            t.Fatal(err)\n        }\n    })\n    \n    t.Run(\"POST /users\", func(t *testing.T) {\n        user := User{Name: \"Bob\", Email: \"bob@example.com\"}\n        body, _ := json.Marshal(user)\n        \n        resp, err := client.Post(\n            server.URL+\"/users\",\n            \"application/json\",\n            bytes.NewReader(body),\n        )\n        if err != nil {\n            t.Fatal(err)\n        }\n        defer resp.Body.Close()\n        \n        if resp.StatusCode != http.StatusCreated {\n            t.Errorf(\"expected status 201, got %d\", resp.StatusCode)\n        }\n    })\n}\n```\n\n### Container Integration Tests\n```go\nimport (\n    \"github.com/testcontainers/testcontainers-go\"\n    \"github.com/testcontainers/testcontainers-go/wait\"\n)\n\nfunc TestWithRedis(t *testing.T) {\n    ctx := context.Background()\n    \n    // Start Redis container\n    req := testcontainers.ContainerRequest{\n        Image:        \"redis:latest\",\n        ExposedPorts: []string{\"6379/tcp\"},\n        WaitingFor:   wait.ForLog(\"Ready to accept connections\"),\n    }\n    \n    redis, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{\n        ContainerRequest: req,\n        Started:          true,\n    })\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer redis.Terminate(ctx)\n    \n    // Get connection details\n    host, err := redis.Host(ctx)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    port, err := redis.MappedPort(ctx, \"6379\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    // Connect to Redis\n    client := NewRedisClient(host, port.Port())\n    \n    // Run tests\n    t.Run(\"Set and Get\", func(t *testing.T) {\n        err := client.Set(\"key\", \"value\")\n        if err != nil {\n            t.Fatal(err)\n        }\n        \n        val, err := client.Get(\"key\")\n        if err != nil {\n            t.Fatal(err)\n        }\n        \n        if val != \"value\" {\n            t.Errorf(\"got %q, want %q\", val, \"value\")\n        }\n    })\n}\n```\n\n## Test Fixtures and Helpers\n\n### Test Fixtures\n```go\n// fixtures.go\npackage testutil\n\ntype Fixtures struct {\n    Users    []*User\n    Products []*Product\n    Orders   []*Order\n}\n\nfunc LoadFixtures() *Fixtures {\n    return &Fixtures{\n        Users: []*User{\n            {ID: 1, Name: \"Alice\", Email: \"alice@example.com\"},\n            {ID: 2, Name: \"Bob\", Email: \"bob@example.com\"},\n        },\n        Products: []*Product{\n            {ID: 1, Name: \"Widget\", Price: 9.99},\n            {ID: 2, Name: \"Gadget\", Price: 19.99},\n        },\n        Orders: []*Order{\n            {ID: 1, UserID: 1, Total: 29.98},\n        },\n    }\n}\n\n// Test data builders\ntype UserBuilder struct {\n    user User\n}\n\nfunc NewUserBuilder() *UserBuilder {\n    return &UserBuilder{\n        user: User{\n            ID:    1,\n            Name:  \"Test User\",\n            Email: \"test@example.com\",\n        },\n    }\n}\n\nfunc (b *UserBuilder) WithName(name string) *UserBuilder {\n    b.user.Name = name\n    return b\n}\n\nfunc (b *UserBuilder) WithEmail(email string) *UserBuilder {\n    b.user.Email = email\n    return b\n}\n\nfunc (b *UserBuilder) Build() *User {\n    return &b.user\n}\n\n// Usage\nfunc TestWithBuilder(t *testing.T) {\n    user := NewUserBuilder().\n        WithName(\"Alice\").\n        WithEmail(\"alice@test.com\").\n        Build()\n    \n    // Test with user...\n}\n```\n\n### Test Helpers\n```go\n// helpers.go\npackage testutil\n\n// Test database helper\nfunc SetupTestDB(t testing.TB) *sql.DB {\n    t.Helper()\n    \n    db, err := sql.Open(\"sqlite3\", \":memory:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if err := runMigrations(db); err != nil {\n        t.Fatal(err)\n    }\n    \n    t.Cleanup(func() {\n        db.Close()\n    })\n    \n    return db\n}\n\n// Temporary directory helper\nfunc TempDir(t testing.TB) string {\n    t.Helper()\n    \n    dir, err := os.MkdirTemp(\"\", \"test\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    t.Cleanup(func() {\n        os.RemoveAll(dir)\n    })\n    \n    return dir\n}\n\n// Assert helpers\nfunc AssertEqual(t testing.TB, got, want interface{}) {\n    t.Helper()\n    \n    if !reflect.DeepEqual(got, want) {\n        t.Errorf(\"got %v, want %v\", got, want)\n    }\n}\n\nfunc AssertNoError(t testing.TB, err error) {\n    t.Helper()\n    \n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n}\n\nfunc AssertError(t testing.TB, err error) {\n    t.Helper()\n    \n    if err == nil {\n        t.Fatal(\"expected error, got nil\")\n    }\n}\n\n// Golden file helper\nfunc GoldenFile(t testing.TB, name string, got []byte) {\n    t.Helper()\n    \n    golden := filepath.Join(\"testdata\", name+\".golden\")\n    \n    if *update {\n        os.WriteFile(golden, got, 0644)\n        return\n    }\n    \n    want, err := os.ReadFile(golden)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if !bytes.Equal(got, want) {\n        t.Errorf(\"output mismatch for %s\", name)\n    }\n}\n```\n\n## Advanced Testing Techniques\n\n### Property-Based Testing\n```go\nimport \"github.com/leanovate/gopter\"\n\nfunc TestPropertyBased(t *testing.T) {\n    properties := gopter.NewProperties(nil)\n    \n    properties.Property(\"reverse twice is identity\", prop.ForAll(\n        func(s string) bool {\n            return s == Reverse(Reverse(s))\n        },\n        gopter.Gen.String(),\n    ))\n    \n    properties.Property(\"list append preserves length\", prop.ForAll(\n        func(list []int, item int) bool {\n            original := len(list)\n            result := append(list, item)\n            return len(result) == original+1\n        },\n        gopter.Gen.SliceOf(gopter.Gen.Int()),\n        gopter.Gen.Int(),\n    ))\n    \n    properties.TestingRun(t)\n}\n```\n\n### Snapshot Testing\n```go\nfunc TestSnapshot(t *testing.T) {\n    data := generateComplexData()\n    output := RenderHTML(data)\n    \n    snapshot := filepath.Join(\"testdata\", t.Name()+\".snapshot\")\n    \n    if *updateSnapshots {\n        if err := os.WriteFile(snapshot, []byte(output), 0644); err != nil {\n            t.Fatal(err)\n        }\n        return\n    }\n    \n    expected, err := os.ReadFile(snapshot)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    if output != string(expected) {\n        t.Error(\"snapshot mismatch\")\n        // Could use diff library to show differences\n    }\n}\n```\n\n### Contract Testing\n```go\n// Define contract that implementations must satisfy\ntype StorageContract struct {\n    t       testing.TB\n    storage Storage\n}\n\nfunc (c *StorageContract) TestStore() {\n    c.t.Helper()\n    \n    err := c.storage.Store(\"key\", \"value\")\n    if err != nil {\n        c.t.Errorf(\"Store failed: %v\", err)\n    }\n    \n    val, err := c.storage.Retrieve(\"key\")\n    if err != nil {\n        c.t.Errorf(\"Retrieve failed: %v\", err)\n    }\n    \n    if val != \"value\" {\n        c.t.Errorf(\"got %q, want %q\", val, \"value\")\n    }\n}\n\nfunc (c *StorageContract) TestDelete() {\n    c.t.Helper()\n    \n    c.storage.Store(\"key\", \"value\")\n    err := c.storage.Delete(\"key\")\n    if err != nil {\n        c.t.Errorf(\"Delete failed: %v\", err)\n    }\n    \n    _, err = c.storage.Retrieve(\"key\")\n    if err == nil {\n        c.t.Error(\"expected error after delete\")\n    }\n}\n\n// Test different implementations\nfunc TestMemoryStorage(t *testing.T) {\n    storage := NewMemoryStorage()\n    contract := &StorageContract{t: t, storage: storage}\n    contract.TestStore()\n    contract.TestDelete()\n}\n\nfunc TestDiskStorage(t *testing.T) {\n    storage := NewDiskStorage(t.TempDir())\n    contract := &StorageContract{t: t, storage: storage}\n    contract.TestStore()\n    contract.TestDelete()\n}\n```\n\n## Best Practices Summary\n\n1. **Write table-driven tests** - Comprehensive and maintainable\n2. **Use subtests** - Better organization and parallel execution\n3. **Mock external dependencies** - Fast and reliable tests\n4. **Test edge cases** - Empty inputs, nil values, errors\n5. **Benchmark critical paths** - Measure performance\n6. **Aim for high coverage** - But focus on meaningful tests\n7. **Use t.Helper()** - Better error reporting in test helpers\n8. **Cleanup with t.Cleanup()** - Guaranteed cleanup\n9. **Use build tags for integration tests** - Separate slow tests\n10. **Keep tests deterministic** - No random failures","structuredPatch":[]}}
{"parentUuid":"471dd8b0-0026-45cd-979f-6713dee7ffd1","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01YFdUGGE7dHvBBEmzetWrBG","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"I'll continue with the remaining documentation files. Let me create the next batch:\n\n## 5. Go Performance"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":10104,"cache_read_input_tokens":70863,"output_tokens":9905,"service_tier":"standard"}},"requestId":"req_011CS5JmS2P2TBVmv4dDgHKN","type":"assistant","uuid":"411d72f3-355d-408b-852a-3f3b0d444e46","timestamp":"2025-08-13T07:22:52.241Z"}
{"parentUuid":"411d72f3-355d-408b-852a-3f3b0d444e46","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01YFdUGGE7dHvBBEmzetWrBG","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01C7rhhurPKjboB7yHsfRcRC","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-performance.md","content":"# Go Performance - Optimization Mastery\n\n## Table of Contents\n1. [Profiling](#profiling)\n2. [Benchmarking](#benchmarking)\n3. [Memory Management](#memory-management)\n4. [CPU Optimization](#cpu-optimization)\n5. [Compiler Optimizations](#compiler-optimizations)\n6. [Caching Strategies](#caching-strategies)\n7. [Concurrency Performance](#concurrency-performance)\n8. [I/O Optimization](#io-optimization)\n9. [Data Structure Optimization](#data-structure-optimization)\n10. [Performance Best Practices](#performance-best-practices)\n\n## Profiling\n\n### CPU Profiling\n```go\nimport (\n    \"runtime/pprof\"\n    \"os\"\n    \"runtime\"\n)\n\n// Basic CPU profiling\nfunc main() {\n    // Create CPU profile file\n    f, err := os.Create(\"cpu.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    // Start CPU profiling\n    if err := pprof.StartCPUProfile(f); err != nil {\n        log.Fatal(err)\n    }\n    defer pprof.StopCPUProfile()\n    \n    // Your application code\n    runApplication()\n}\n\n// HTTP profiling server\nimport _ \"net/http/pprof\"\n\nfunc main() {\n    go func() {\n        log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n    }()\n    \n    // Your application code\n    runApplication()\n}\n\n// Analyze profiles:\n// go tool pprof cpu.prof\n// go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n// go tool pprof -http=:8080 cpu.prof  # Web interface\n\n// Profile with benchmarks\nfunc BenchmarkFunction(b *testing.B) {\n    // Start profiling in benchmark\n    f, _ := os.Create(\"bench.prof\")\n    pprof.StartCPUProfile(f)\n    defer pprof.StopCPUProfile()\n    \n    for i := 0; i < b.N; i++ {\n        FunctionToProfile()\n    }\n}\n```\n\n### Memory Profiling\n```go\n// Memory profiling\nfunc writeMemProfile() {\n    f, err := os.Create(\"mem.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    runtime.GC() // Force GC before profiling\n    if err := pprof.WriteHeapProfile(f); err != nil {\n        log.Fatal(err)\n    }\n}\n\n// Allocation profiling\nfunc writeAllocProfile() {\n    f, err := os.Create(\"alloc.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    // Profile allocations\n    runtime.MemProfileRate = 1 // Profile every allocation\n    defer func() { runtime.MemProfileRate = 512 * 1024 }() // Reset\n    \n    // Run code\n    runApplication()\n    \n    pprof.Lookup(\"allocs\").WriteTo(f, 0)\n}\n\n// Memory stats\nfunc printMemStats() {\n    var m runtime.MemStats\n    runtime.ReadMemStats(&m)\n    \n    fmt.Printf(\"Alloc = %v MB\", m.Alloc / 1024 / 1024)\n    fmt.Printf(\"TotalAlloc = %v MB\", m.TotalAlloc / 1024 / 1024)\n    fmt.Printf(\"Sys = %v MB\", m.Sys / 1024 / 1024)\n    fmt.Printf(\"NumGC = %v\\n\", m.NumGC)\n    fmt.Printf(\"HeapAlloc = %v MB\", m.HeapAlloc / 1024 / 1024)\n    fmt.Printf(\"HeapObjects = %v\", m.HeapObjects)\n}\n\n// Track allocations in specific code\nfunc trackAllocations() {\n    var m1, m2 runtime.MemStats\n    \n    runtime.ReadMemStats(&m1)\n    \n    // Code to measure\n    expensiveOperation()\n    \n    runtime.ReadMemStats(&m2)\n    \n    fmt.Printf(\"Allocated: %d bytes\\n\", m2.Alloc - m1.Alloc)\n    fmt.Printf(\"Total Allocated: %d bytes\\n\", m2.TotalAlloc - m1.TotalAlloc)\n    fmt.Printf(\"Number of allocations: %d\\n\", m2.Mallocs - m1.Mallocs)\n}\n```\n\n### Goroutine Profiling\n```go\n// Goroutine profiling\nfunc writeGoroutineProfile() {\n    f, err := os.Create(\"goroutine.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    pprof.Lookup(\"goroutine\").WriteTo(f, 1)\n}\n\n// Monitor goroutine count\nfunc monitorGoroutines() {\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()\n    \n    for range ticker.C {\n        fmt.Printf(\"Goroutines: %d\\n\", runtime.NumGoroutine())\n    }\n}\n\n// Block profiling (mutex contention)\nfunc enableBlockProfiling() {\n    runtime.SetBlockProfileRate(1)\n    defer runtime.SetBlockProfileRate(0)\n    \n    // Run application\n    runApplication()\n    \n    f, _ := os.Create(\"block.prof\")\n    defer f.Close()\n    pprof.Lookup(\"block\").WriteTo(f, 0)\n}\n\n// Mutex profiling\nfunc enableMutexProfiling() {\n    runtime.SetMutexProfileFraction(1)\n    defer runtime.SetMutexProfileFraction(0)\n    \n    // Run application\n    runApplication()\n    \n    f, _ := os.Create(\"mutex.prof\")\n    defer f.Close()\n    pprof.Lookup(\"mutex\").WriteTo(f, 0)\n}\n```\n\n### Trace Profiling\n```go\nimport \"runtime/trace\"\n\n// Execution tracing\nfunc main() {\n    f, err := os.Create(\"trace.out\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    err = trace.Start(f)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer trace.Stop()\n    \n    // Your application\n    runApplication()\n}\n\n// Analyze: go tool trace trace.out\n\n// Custom trace regions\nfunc processRequest(ctx context.Context) {\n    defer trace.StartRegion(ctx, \"processRequest\").End()\n    \n    trace.WithRegion(ctx, \"validate\", func() {\n        validateInput()\n    })\n    \n    trace.WithRegion(ctx, \"compute\", func() {\n        computeResult()\n    })\n    \n    trace.WithRegion(ctx, \"respond\", func() {\n        sendResponse()\n    })\n}\n\n// Trace logging\nfunc traceLog(ctx context.Context, message string) {\n    trace.Log(ctx, \"app\", message)\n}\n```\n\n## Benchmarking\n\n### Advanced Benchmarking\n```go\n// Benchmark with different inputs\nfunc BenchmarkSort(b *testing.B) {\n    sizes := []int{10, 100, 1000, 10000}\n    \n    for _, size := range sizes {\n        b.Run(fmt.Sprintf(\"size-%d\", size), func(b *testing.B) {\n            data := generateRandomSlice(size)\n            \n            b.ResetTimer()\n            for i := 0; i < b.N; i++ {\n                b.StopTimer()\n                tmp := make([]int, len(data))\n                copy(tmp, data)\n                b.StartTimer()\n                \n                sort.Ints(tmp)\n            }\n        })\n    }\n}\n\n// Comparative benchmarks\nfunc BenchmarkStringBuilding(b *testing.B) {\n    strs := []string{\"hello\", \"world\", \"foo\", \"bar\", \"baz\"}\n    \n    b.Run(\"Concatenation\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            var result string\n            for _, s := range strs {\n                result += s\n            }\n        }\n    })\n    \n    b.Run(\"StringBuilder\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            var builder strings.Builder\n            for _, s := range strs {\n                builder.WriteString(s)\n            }\n            _ = builder.String()\n        }\n    })\n    \n    b.Run(\"BytesBuffer\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            var buffer bytes.Buffer\n            for _, s := range strs {\n                buffer.WriteString(s)\n            }\n            _ = buffer.String()\n        }\n    })\n    \n    b.Run(\"Join\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            _ = strings.Join(strs, \"\")\n        }\n    })\n}\n\n// Memory benchmarks\nfunc BenchmarkMemory(b *testing.B) {\n    b.Run(\"WithAllocation\", func(b *testing.B) {\n        b.ReportAllocs()\n        for i := 0; i < b.N; i++ {\n            s := make([]int, 1000)\n            _ = s\n        }\n    })\n    \n    b.Run(\"WithPool\", func(b *testing.B) {\n        b.ReportAllocs()\n        pool := sync.Pool{\n            New: func() interface{} {\n                return make([]int, 1000)\n            },\n        }\n        \n        for i := 0; i < b.N; i++ {\n            s := pool.Get().([]int)\n            pool.Put(s)\n        }\n    })\n}\n\n// Custom metrics\nfunc BenchmarkThroughput(b *testing.B) {\n    data := make([]byte, 1024*1024) // 1MB\n    \n    b.SetBytes(int64(len(data)))\n    b.ResetTimer()\n    \n    for i := 0; i < b.N; i++ {\n        process(data)\n    }\n    \n    b.ReportMetric(float64(b.N)*float64(len(data))/b.Elapsed().Seconds()/1024/1024, \"MB/s\")\n}\n```\n\n## Memory Management\n\n### Reducing Allocations\n```go\n// Avoid allocations in loops\n// Bad: Allocates in loop\nfunc bad() []string {\n    var results []string\n    for i := 0; i < 1000; i++ {\n        results = append(results, fmt.Sprintf(\"item-%d\", i))\n    }\n    return results\n}\n\n// Good: Preallocate\nfunc good() []string {\n    results := make([]string, 0, 1000)\n    for i := 0; i < 1000; i++ {\n        results = append(results, fmt.Sprintf(\"item-%d\", i))\n    }\n    return results\n}\n\n// Reuse buffers\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processWithPool(data []byte) string {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    // Process...\n    return buf.String()\n}\n\n// Avoid string allocations\nfunc avoidStringAllocs(b []byte) string {\n    // Bad: Multiple allocations\n    s := string(b)\n    s = strings.ToUpper(s)\n    s = strings.TrimSpace(s)\n    \n    // Better: Work with bytes\n    b = bytes.ToUpper(b)\n    b = bytes.TrimSpace(b)\n    return string(b)\n}\n\n// String interning for repeated strings\ntype StringInterner struct {\n    mu    sync.RWMutex\n    cache map[string]string\n}\n\nfunc (si *StringInterner) Intern(s string) string {\n    si.mu.RLock()\n    if interned, ok := si.cache[s]; ok {\n        si.mu.RUnlock()\n        return interned\n    }\n    si.mu.RUnlock()\n    \n    si.mu.Lock()\n    defer si.mu.Unlock()\n    \n    si.cache[s] = s\n    return s\n}\n```\n\n### Memory Layout Optimization\n```go\n// Struct field alignment\n// Bad: 32 bytes due to padding\ntype Inefficient struct {\n    a bool    // 1 byte + 7 padding\n    b int64   // 8 bytes\n    c bool    // 1 byte + 7 padding\n    d int64   // 8 bytes\n}\n\n// Good: 24 bytes with better alignment\ntype Efficient struct {\n    b int64   // 8 bytes\n    d int64   // 8 bytes\n    a bool    // 1 byte\n    c bool    // 1 byte + 6 padding\n}\n\n// Use smaller types when possible\ntype Flags struct {\n    // Bad: 4 bools = potentially 4 bytes + padding\n    IsActive   bool\n    IsVerified bool\n    IsPremium  bool\n    IsAdmin    bool\n}\n\n// Good: 1 byte using bit flags\ntype CompactFlags uint8\n\nconst (\n    FlagActive CompactFlags = 1 << iota\n    FlagVerified\n    FlagPremium\n    FlagAdmin\n)\n\nfunc (f CompactFlags) IsActive() bool { return f&FlagActive != 0 }\nfunc (f CompactFlags) IsVerified() bool { return f&FlagVerified != 0 }\n\n// Array vs slice for fixed size\ntype Record struct {\n    // Bad: slice has 24 bytes overhead (pointer, len, cap)\n    IDSlice []byte\n    \n    // Good: array for fixed size, no overhead\n    IDArray [16]byte\n}\n```\n\n### Escape Analysis\n```go\n// Understanding escape analysis\n// go build -gcflags=\"-m\" to see escape analysis\n\n// Doesn't escape - allocated on stack\nfunc noEscape() int {\n    x := 42\n    return x\n}\n\n// Escapes to heap - returned pointer\nfunc escapes() *int {\n    x := 42\n    return &x // x escapes to heap\n}\n\n// Avoid unnecessary escapes\ntype Data struct {\n    values [1000]int\n}\n\n// Bad: Escapes to heap\nfunc (d *Data) Sum() int {\n    sum := 0\n    for _, v := range d.values { // d.values escapes\n        sum += v\n    }\n    return sum\n}\n\n// Good: Doesn't escape\nfunc (d Data) SumValue() int {\n    sum := 0\n    for i := 0; i < len(d.values); i++ {\n        sum += d.values[i]\n    }\n    return sum\n}\n\n// Interface causes escape\nfunc processInterface(i interface{}) {\n    // i escapes to heap\n}\n\nfunc avoidEscape() {\n    x := 42\n    processInterface(x) // x escapes\n    \n    // Avoid by not using interface\n    processInt(x) // x doesn't escape\n}\n\nfunc processInt(i int) {\n    // Process int directly\n}\n```\n\n## CPU Optimization\n\n### Hot Path Optimization\n```go\n// Optimize hot paths\nfunc processData(data []int) int {\n    // Move invariants out of loop\n    length := len(data)\n    if length == 0 {\n        return 0\n    }\n    \n    sum := 0\n    // Unroll loop for better performance\n    for i := 0; i < length-3; i += 4 {\n        sum += data[i] + data[i+1] + data[i+2] + data[i+3]\n    }\n    \n    // Handle remaining elements\n    for i := length - length%4; i < length; i++ {\n        sum += data[i]\n    }\n    \n    return sum\n}\n\n// Branch prediction optimization\nfunc findMax(data []int) int {\n    if len(data) == 0 {\n        return 0\n    }\n    \n    max := data[0]\n    for i := 1; i < len(data); i++ {\n        // Branchless max (may be faster)\n        if data[i] > max {\n            max = data[i]\n        }\n    }\n    return max\n}\n\n// Cache-friendly iteration\nfunc sumMatrix(matrix [][]int) int {\n    sum := 0\n    // Row-major order (cache-friendly)\n    for i := 0; i < len(matrix); i++ {\n        for j := 0; j < len(matrix[i]); j++ {\n            sum += matrix[i][j]\n        }\n    }\n    return sum\n}\n\n// SIMD-friendly code\nfunc addSlices(a, b []float64) []float64 {\n    result := make([]float64, len(a))\n    \n    // Compiler may vectorize this\n    for i := range a {\n        result[i] = a[i] + b[i]\n    }\n    \n    return result\n}\n```\n\n### Inlining\n```go\n// Encourage inlining for small functions\n//go:inline\nfunc add(a, b int) int {\n    return a + b\n}\n\n// Prevent inlining for rarely used functions\n//go:noinline\nfunc rarelyUsedFunction() {\n    // Complex logic\n}\n\n// Check inlining decisions\n// go build -gcflags=\"-m=2\"\n\n// Inline-friendly functions\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n\n// Too complex to inline (default threshold ~80 nodes)\nfunc complexFunction(x int) int {\n    // Many operations...\n    return result\n}\n```\n\n## Compiler Optimizations\n\n### Compiler Directives\n```go\n// Bounds check elimination\nfunc sumArray(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    // Compiler can eliminate bounds checks\n    for i := 0; i < len(arr); i++ {\n        sum += arr[i]\n    }\n    return sum\n}\n\n// Help compiler with hints\nfunc process(data []byte) {\n    // Tell compiler minimum length\n    _ = data[3] // Bounds check once\n    \n    // Now these don't need bounds checks\n    a := data[0]\n    b := data[1]\n    c := data[2]\n    d := data[3]\n    \n    // Process a, b, c, d\n}\n\n// Const propagation\nconst bufferSize = 1024\n\nfunc allocateBuffer() []byte {\n    // Compiler knows size at compile time\n    return make([]byte, bufferSize)\n}\n\n// Dead code elimination\nfunc example(debug bool) {\n    if false { // Compiler removes this\n        expensiveDebugOperation()\n    }\n    \n    const debugMode = false\n    if debugMode { // Also removed\n        fmt.Println(\"Debug mode\")\n    }\n}\n```\n\n### Build Flags\n```go\n// Build tags for optimization\n//go:build !debug\n\npackage main\n\nfunc log(msg string) {\n    // No-op in release builds\n}\n\n// Alternative file for debug builds\n//go:build debug\n\npackage main\n\nfunc log(msg string) {\n    fmt.Println(msg)\n}\n\n// Compile with optimizations\n// go build -ldflags=\"-s -w\" # Strip debug info\n// go build -tags release\n// GOOS=linux GOARCH=amd64 go build # Cross-compile\n```\n\n## Caching Strategies\n\n### In-Memory Caching\n```go\n// Simple cache with TTL\ntype Cache struct {\n    mu      sync.RWMutex\n    items   map[string]*cacheItem\n    ttl     time.Duration\n}\n\ntype cacheItem struct {\n    value      interface{}\n    expiration time.Time\n}\n\nfunc NewCache(ttl time.Duration) *Cache {\n    c := &Cache{\n        items: make(map[string]*cacheItem),\n        ttl:   ttl,\n    }\n    go c.cleanup()\n    return c\n}\n\nfunc (c *Cache) Set(key string, value interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    c.items[key] = &cacheItem{\n        value:      value,\n        expiration: time.Now().Add(c.ttl),\n    }\n}\n\nfunc (c *Cache) Get(key string) (interface{}, bool) {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    \n    item, found := c.items[key]\n    if !found {\n        return nil, false\n    }\n    \n    if time.Now().After(item.expiration) {\n        return nil, false\n    }\n    \n    return item.value, true\n}\n\nfunc (c *Cache) cleanup() {\n    ticker := time.NewTicker(c.ttl / 2)\n    defer ticker.Stop()\n    \n    for range ticker.C {\n        c.mu.Lock()\n        now := time.Now()\n        for key, item := range c.items {\n            if now.After(item.expiration) {\n                delete(c.items, key)\n            }\n        }\n        c.mu.Unlock()\n    }\n}\n\n// LRU Cache\ntype LRUCache struct {\n    capacity int\n    items    map[string]*list.Element\n    order    *list.List\n    mu       sync.Mutex\n}\n\ntype lruItem struct {\n    key   string\n    value interface{}\n}\n\nfunc NewLRUCache(capacity int) *LRUCache {\n    return &LRUCache{\n        capacity: capacity,\n        items:    make(map[string]*list.Element),\n        order:    list.New(),\n    }\n}\n\nfunc (c *LRUCache) Get(key string) (interface{}, bool) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    if elem, ok := c.items[key]; ok {\n        c.order.MoveToFront(elem)\n        return elem.Value.(*lruItem).value, true\n    }\n    return nil, false\n}\n\nfunc (c *LRUCache) Set(key string, value interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    if elem, ok := c.items[key]; ok {\n        c.order.MoveToFront(elem)\n        elem.Value.(*lruItem).value = value\n        return\n    }\n    \n    if c.order.Len() >= c.capacity {\n        oldest := c.order.Back()\n        if oldest != nil {\n            c.order.Remove(oldest)\n            delete(c.items, oldest.Value.(*lruItem).key)\n        }\n    }\n    \n    item := &lruItem{key: key, value: value}\n    elem := c.order.PushFront(item)\n    c.items[key] = elem\n}\n```\n\n### Memoization\n```go\n// Function memoization\ntype Memoizer struct {\n    mu    sync.RWMutex\n    cache map[string]interface{}\n    fn    func(string) interface{}\n}\n\nfunc NewMemoizer(fn func(string) interface{}) *Memoizer {\n    return &Memoizer{\n        cache: make(map[string]interface{}),\n        fn:    fn,\n    }\n}\n\nfunc (m *Memoizer) Get(key string) interface{} {\n    m.mu.RLock()\n    if val, ok := m.cache[key]; ok {\n        m.mu.RUnlock()\n        return val\n    }\n    m.mu.RUnlock()\n    \n    m.mu.Lock()\n    defer m.mu.Unlock()\n    \n    // Double-check\n    if val, ok := m.cache[key]; ok {\n        return val\n    }\n    \n    val := m.fn(key)\n    m.cache[key] = val\n    return val\n}\n\n// Concurrent-safe memoization with singleflight\nimport \"golang.org/x/sync/singleflight\"\n\ntype ConcurrentMemoizer struct {\n    cache map[string]interface{}\n    mu    sync.RWMutex\n    group singleflight.Group\n}\n\nfunc (m *ConcurrentMemoizer) Get(key string) (interface{}, error) {\n    m.mu.RLock()\n    if val, ok := m.cache[key]; ok {\n        m.mu.RUnlock()\n        return val, nil\n    }\n    m.mu.RUnlock()\n    \n    // Ensure only one goroutine computes the value\n    val, err, _ := m.group.Do(key, func() (interface{}, error) {\n        result := expensiveComputation(key)\n        \n        m.mu.Lock()\n        m.cache[key] = result\n        m.mu.Unlock()\n        \n        return result, nil\n    })\n    \n    return val, err\n}\n```\n\n## Concurrency Performance\n\n### Goroutine Pool\n```go\n// Efficient goroutine pool\ntype WorkerPool struct {\n    workers   int\n    jobQueue  chan Job\n    results   chan Result\n    wg        sync.WaitGroup\n}\n\nfunc NewWorkerPool(workers int, queueSize int) *WorkerPool {\n    return &WorkerPool{\n        workers:  workers,\n        jobQueue: make(chan Job, queueSize),\n        results:  make(chan Result, queueSize),\n    }\n}\n\nfunc (p *WorkerPool) Start() {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go p.worker(i)\n    }\n}\n\nfunc (p *WorkerPool) worker(id int) {\n    defer p.wg.Done()\n    \n    for job := range p.jobQueue {\n        result := processJob(job)\n        p.results <- result\n    }\n}\n\nfunc (p *WorkerPool) Submit(job Job) {\n    p.jobQueue <- job\n}\n\nfunc (p *WorkerPool) Stop() {\n    close(p.jobQueue)\n    p.wg.Wait()\n    close(p.results)\n}\n\n// Lock-free structures\ntype LockFreeStack struct {\n    head atomic.Pointer[node]\n}\n\ntype node struct {\n    value interface{}\n    next  *node\n}\n\nfunc (s *LockFreeStack) Push(v interface{}) {\n    n := &node{value: v}\n    for {\n        head := s.head.Load()\n        n.next = head\n        if s.head.CompareAndSwap(head, n) {\n            return\n        }\n    }\n}\n\nfunc (s *LockFreeStack) Pop() interface{} {\n    for {\n        head := s.head.Load()\n        if head == nil {\n            return nil\n        }\n        if s.head.CompareAndSwap(head, head.next) {\n            return head.value\n        }\n    }\n}\n```\n\n### Channel Optimization\n```go\n// Buffered channels for performance\nfunc efficientPipeline() {\n    // Use buffered channels to reduce blocking\n    input := make(chan int, 100)\n    output := make(chan int, 100)\n    \n    // Producer\n    go func() {\n        defer close(input)\n        for i := 0; i < 1000; i++ {\n            input <- i\n        }\n    }()\n    \n    // Workers\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for val := range input {\n                output <- process(val)\n            }\n        }()\n    }\n    \n    // Close output when workers done\n    go func() {\n        wg.Wait()\n        close(output)\n    }()\n    \n    // Consumer\n    for result := range output {\n        handleResult(result)\n    }\n}\n\n// Batch processing for efficiency\nfunc batchProcessor(input <-chan Item) {\n    batch := make([]Item, 0, 100)\n    ticker := time.NewTicker(100 * time.Millisecond)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case item, ok := <-input:\n            if !ok {\n                if len(batch) > 0 {\n                    processBatch(batch)\n                }\n                return\n            }\n            batch = append(batch, item)\n            \n            if len(batch) >= 100 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n            \n        case <-ticker.C:\n            if len(batch) > 0 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n        }\n    }\n}\n```\n\n## I/O Optimization\n\n### Buffered I/O\n```go\n// Use buffered I/O\nfunc efficientFileRead(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n    \n    // Use buffered reader\n    reader := bufio.NewReader(file)\n    \n    for {\n        line, err := reader.ReadString('\\n')\n        if err == io.EOF {\n            break\n        }\n        if err != nil {\n            return err\n        }\n        \n        processLine(line)\n    }\n    \n    return nil\n}\n\n// Efficient file writing\nfunc efficientFileWrite(filename string, data []string) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n    \n    // Use buffered writer\n    writer := bufio.NewWriter(file)\n    defer writer.Flush()\n    \n    for _, line := range data {\n        _, err := writer.WriteString(line + \"\\n\")\n        if err != nil {\n            return err\n        }\n    }\n    \n    return nil\n}\n\n// Memory-mapped files for large files\nimport \"golang.org/x/exp/mmap\"\n\nfunc readLargeFile(filename string) error {\n    reader, err := mmap.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer reader.Close()\n    \n    // Read without loading entire file into memory\n    data := make([]byte, 1024)\n    for offset := int64(0); offset < reader.Len(); offset += 1024 {\n        n, err := reader.ReadAt(data, offset)\n        if err != nil && err != io.EOF {\n            return err\n        }\n        \n        processChunk(data[:n])\n    }\n    \n    return nil\n}\n```\n\n### Network I/O\n```go\n// Connection pooling\ntype ConnectionPool struct {\n    connections chan net.Conn\n    factory     func() (net.Conn, error)\n}\n\nfunc NewConnectionPool(size int, factory func() (net.Conn, error)) (*ConnectionPool, error) {\n    pool := &ConnectionPool{\n        connections: make(chan net.Conn, size),\n        factory:     factory,\n    }\n    \n    for i := 0; i < size; i++ {\n        conn, err := factory()\n        if err != nil {\n            return nil, err\n        }\n        pool.connections <- conn\n    }\n    \n    return pool, nil\n}\n\nfunc (p *ConnectionPool) Get() net.Conn {\n    return <-p.connections\n}\n\nfunc (p *ConnectionPool) Put(conn net.Conn) {\n    p.connections <- conn\n}\n\n// HTTP client optimization\nvar httpClient = &http.Client{\n    Timeout: 30 * time.Second,\n    Transport: &http.Transport{\n        MaxIdleConns:        100,\n        MaxIdleConnsPerHost: 10,\n        IdleConnTimeout:     90 * time.Second,\n        DisableCompression:  false,\n        DisableKeepAlives:   false,\n    },\n}\n\n// Batch HTTP requests\nfunc batchHTTPRequests(urls []string) []Response {\n    results := make([]Response, len(urls))\n    var wg sync.WaitGroup\n    \n    // Limit concurrent requests\n    sem := make(chan struct{}, 10)\n    \n    for i, url := range urls {\n        wg.Add(1)\n        go func(idx int, u string) {\n            defer wg.Done()\n            \n            sem <- struct{}{}\n            defer func() { <-sem }()\n            \n            resp, err := httpClient.Get(u)\n            if err != nil {\n                results[idx] = Response{Error: err}\n                return\n            }\n            defer resp.Body.Close()\n            \n            body, _ := io.ReadAll(resp.Body)\n            results[idx] = Response{Data: body}\n        }(i, url)\n    }\n    \n    wg.Wait()\n    return results\n}\n```\n\n## Data Structure Optimization\n\n### Slice Optimization\n```go\n// Preallocate slices\nfunc optimizedSliceOperations() {\n    // Know the capacity\n    slice := make([]int, 0, 1000)\n    \n    // Grow efficiently\n    if cap(slice) < requiredSize {\n        newSlice := make([]int, len(slice), requiredSize*2)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    \n    // Clear slice for reuse\n    slice = slice[:0]\n    \n    // Remove element efficiently\n    func removeAt(s []int, i int) []int {\n        s[i] = s[len(s)-1]\n        return s[:len(s)-1]\n    }\n}\n\n// Custom growing strategy\ntype GrowableBuffer struct {\n    data []byte\n}\n\nfunc (b *GrowableBuffer) grow(n int) {\n    if cap(b.data)-len(b.data) < n {\n        newCap := cap(b.data) * 2\n        if newCap < len(b.data)+n {\n            newCap = len(b.data) + n\n        }\n        newData := make([]byte, len(b.data), newCap)\n        copy(newData, b.data)\n        b.data = newData\n    }\n}\n```\n\n### Map Optimization\n```go\n// Preallocate maps\nm := make(map[string]int, 1000)\n\n// Use appropriate key types\n// Faster: int keys\nfastMap := make(map[int]string)\n\n// Slower: string keys (requires hashing)\nslowMap := make(map[string]string)\n\n// Custom hash map for specific use case\ntype FastStringMap struct {\n    buckets [][]entry\n    size    int\n}\n\ntype entry struct {\n    key   string\n    value interface{}\n}\n\nfunc (m *FastStringMap) hash(key string) uint32 {\n    // Fast hash function\n    h := uint32(2166136261)\n    for i := 0; i < len(key); i++ {\n        h *= 16777619\n        h ^= uint32(key[i])\n    }\n    return h\n}\n\nfunc (m *FastStringMap) Get(key string) (interface{}, bool) {\n    h := m.hash(key) % uint32(len(m.buckets))\n    bucket := m.buckets[h]\n    \n    for _, e := range bucket {\n        if e.key == key {\n            return e.value, true\n        }\n    }\n    return nil, false\n}\n```\n\n### String Optimization\n```go\n// String concatenation optimization\nfunc efficientStringConcat(strs []string) string {\n    // Calculate total length\n    var totalLen int\n    for _, s := range strs {\n        totalLen += len(s)\n    }\n    \n    // Preallocate builder\n    var builder strings.Builder\n    builder.Grow(totalLen)\n    \n    for _, s := range strs {\n        builder.WriteString(s)\n    }\n    \n    return builder.String()\n}\n\n// Avoid string copies\nfunc stringToBytes(s string) []byte {\n    // Safe conversion without copy (read-only)\n    return unsafe.Slice(unsafe.StringData(s), len(s))\n}\n\nfunc bytesToString(b []byte) string {\n    // Safe conversion without copy\n    return unsafe.String(unsafe.SliceData(b), len(b))\n}\n```\n\n## Performance Best Practices\n\n### Measurement and Profiling\n```go\n// Always measure before optimizing\nfunc measurePerformance() {\n    start := time.Now()\n    defer func() {\n        elapsed := time.Since(start)\n        log.Printf(\"Operation took %v\", elapsed)\n    }()\n    \n    // Operation to measure\n}\n\n// Use benchmarks for micro-optimizations\nfunc BenchmarkOptimization(b *testing.B) {\n    // Test different approaches\n}\n\n// Profile in production\nimport _ \"net/http/pprof\"\n// Access profiles at /debug/pprof/\n```\n\n### Common Optimizations\n```go\n// 1. Avoid premature optimization\n// Profile first, optimize bottlenecks\n\n// 2. Reduce allocations\n// Use sync.Pool, preallocate slices\n\n// 3. Optimize hot paths\n// Focus on frequently executed code\n\n// 4. Use efficient algorithms\n// O(n) vs O(n²) matters at scale\n\n// 5. Cache computed values\n// Memoization, lookup tables\n\n// 6. Batch operations\n// Reduce system calls, network requests\n\n// 7. Use appropriate data structures\n// Map vs slice, array vs slice\n\n// 8. Leverage concurrency wisely\n// Don't overuse goroutines\n\n// 9. Minimize interface conversions\n// Interfaces cause allocations\n\n// 10. Profile regularly\n// Performance can degrade over time\n```\n\n## Best Practices Summary\n\n1. **Profile before optimizing** - Measure, don't guess\n2. **Focus on algorithms first** - Better algorithm beats micro-optimizations\n3. **Reduce allocations** - Use pools, preallocate, reuse\n4. **Optimize hot paths** - 80/20 rule applies\n5. **Cache aggressively** - But invalidate correctly\n6. **Use buffered I/O** - For file and network operations\n7. **Batch operations** - Amortize overhead\n8. **Choose right data structures** - Map vs slice matters\n9. **Leverage compiler optimizations** - Write optimizer-friendly code\n10. **Monitor production performance** - Use pprof, metrics, tracing"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":10104,"cache_read_input_tokens":70863,"output_tokens":9905,"service_tier":"standard"}},"requestId":"req_011CS5JmS2P2TBVmv4dDgHKN","type":"assistant","uuid":"43e966ce-3b3d-47d8-87e0-deef8fec2275","timestamp":"2025-08-13T07:25:44.963Z"}
{"parentUuid":"43e966ce-3b3d-47d8-87e0-deef8fec2275","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C7rhhurPKjboB7yHsfRcRC","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/go-performance.md"}]},"uuid":"62467738-6f1a-4872-9e91-7c1a111c89a8","timestamp":"2025-08-13T07:25:45.023Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-performance.md","content":"# Go Performance - Optimization Mastery\n\n## Table of Contents\n1. [Profiling](#profiling)\n2. [Benchmarking](#benchmarking)\n3. [Memory Management](#memory-management)\n4. [CPU Optimization](#cpu-optimization)\n5. [Compiler Optimizations](#compiler-optimizations)\n6. [Caching Strategies](#caching-strategies)\n7. [Concurrency Performance](#concurrency-performance)\n8. [I/O Optimization](#io-optimization)\n9. [Data Structure Optimization](#data-structure-optimization)\n10. [Performance Best Practices](#performance-best-practices)\n\n## Profiling\n\n### CPU Profiling\n```go\nimport (\n    \"runtime/pprof\"\n    \"os\"\n    \"runtime\"\n)\n\n// Basic CPU profiling\nfunc main() {\n    // Create CPU profile file\n    f, err := os.Create(\"cpu.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    // Start CPU profiling\n    if err := pprof.StartCPUProfile(f); err != nil {\n        log.Fatal(err)\n    }\n    defer pprof.StopCPUProfile()\n    \n    // Your application code\n    runApplication()\n}\n\n// HTTP profiling server\nimport _ \"net/http/pprof\"\n\nfunc main() {\n    go func() {\n        log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n    }()\n    \n    // Your application code\n    runApplication()\n}\n\n// Analyze profiles:\n// go tool pprof cpu.prof\n// go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n// go tool pprof -http=:8080 cpu.prof  # Web interface\n\n// Profile with benchmarks\nfunc BenchmarkFunction(b *testing.B) {\n    // Start profiling in benchmark\n    f, _ := os.Create(\"bench.prof\")\n    pprof.StartCPUProfile(f)\n    defer pprof.StopCPUProfile()\n    \n    for i := 0; i < b.N; i++ {\n        FunctionToProfile()\n    }\n}\n```\n\n### Memory Profiling\n```go\n// Memory profiling\nfunc writeMemProfile() {\n    f, err := os.Create(\"mem.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    runtime.GC() // Force GC before profiling\n    if err := pprof.WriteHeapProfile(f); err != nil {\n        log.Fatal(err)\n    }\n}\n\n// Allocation profiling\nfunc writeAllocProfile() {\n    f, err := os.Create(\"alloc.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    // Profile allocations\n    runtime.MemProfileRate = 1 // Profile every allocation\n    defer func() { runtime.MemProfileRate = 512 * 1024 }() // Reset\n    \n    // Run code\n    runApplication()\n    \n    pprof.Lookup(\"allocs\").WriteTo(f, 0)\n}\n\n// Memory stats\nfunc printMemStats() {\n    var m runtime.MemStats\n    runtime.ReadMemStats(&m)\n    \n    fmt.Printf(\"Alloc = %v MB\", m.Alloc / 1024 / 1024)\n    fmt.Printf(\"TotalAlloc = %v MB\", m.TotalAlloc / 1024 / 1024)\n    fmt.Printf(\"Sys = %v MB\", m.Sys / 1024 / 1024)\n    fmt.Printf(\"NumGC = %v\\n\", m.NumGC)\n    fmt.Printf(\"HeapAlloc = %v MB\", m.HeapAlloc / 1024 / 1024)\n    fmt.Printf(\"HeapObjects = %v\", m.HeapObjects)\n}\n\n// Track allocations in specific code\nfunc trackAllocations() {\n    var m1, m2 runtime.MemStats\n    \n    runtime.ReadMemStats(&m1)\n    \n    // Code to measure\n    expensiveOperation()\n    \n    runtime.ReadMemStats(&m2)\n    \n    fmt.Printf(\"Allocated: %d bytes\\n\", m2.Alloc - m1.Alloc)\n    fmt.Printf(\"Total Allocated: %d bytes\\n\", m2.TotalAlloc - m1.TotalAlloc)\n    fmt.Printf(\"Number of allocations: %d\\n\", m2.Mallocs - m1.Mallocs)\n}\n```\n\n### Goroutine Profiling\n```go\n// Goroutine profiling\nfunc writeGoroutineProfile() {\n    f, err := os.Create(\"goroutine.prof\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    pprof.Lookup(\"goroutine\").WriteTo(f, 1)\n}\n\n// Monitor goroutine count\nfunc monitorGoroutines() {\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()\n    \n    for range ticker.C {\n        fmt.Printf(\"Goroutines: %d\\n\", runtime.NumGoroutine())\n    }\n}\n\n// Block profiling (mutex contention)\nfunc enableBlockProfiling() {\n    runtime.SetBlockProfileRate(1)\n    defer runtime.SetBlockProfileRate(0)\n    \n    // Run application\n    runApplication()\n    \n    f, _ := os.Create(\"block.prof\")\n    defer f.Close()\n    pprof.Lookup(\"block\").WriteTo(f, 0)\n}\n\n// Mutex profiling\nfunc enableMutexProfiling() {\n    runtime.SetMutexProfileFraction(1)\n    defer runtime.SetMutexProfileFraction(0)\n    \n    // Run application\n    runApplication()\n    \n    f, _ := os.Create(\"mutex.prof\")\n    defer f.Close()\n    pprof.Lookup(\"mutex\").WriteTo(f, 0)\n}\n```\n\n### Trace Profiling\n```go\nimport \"runtime/trace\"\n\n// Execution tracing\nfunc main() {\n    f, err := os.Create(\"trace.out\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    \n    err = trace.Start(f)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer trace.Stop()\n    \n    // Your application\n    runApplication()\n}\n\n// Analyze: go tool trace trace.out\n\n// Custom trace regions\nfunc processRequest(ctx context.Context) {\n    defer trace.StartRegion(ctx, \"processRequest\").End()\n    \n    trace.WithRegion(ctx, \"validate\", func() {\n        validateInput()\n    })\n    \n    trace.WithRegion(ctx, \"compute\", func() {\n        computeResult()\n    })\n    \n    trace.WithRegion(ctx, \"respond\", func() {\n        sendResponse()\n    })\n}\n\n// Trace logging\nfunc traceLog(ctx context.Context, message string) {\n    trace.Log(ctx, \"app\", message)\n}\n```\n\n## Benchmarking\n\n### Advanced Benchmarking\n```go\n// Benchmark with different inputs\nfunc BenchmarkSort(b *testing.B) {\n    sizes := []int{10, 100, 1000, 10000}\n    \n    for _, size := range sizes {\n        b.Run(fmt.Sprintf(\"size-%d\", size), func(b *testing.B) {\n            data := generateRandomSlice(size)\n            \n            b.ResetTimer()\n            for i := 0; i < b.N; i++ {\n                b.StopTimer()\n                tmp := make([]int, len(data))\n                copy(tmp, data)\n                b.StartTimer()\n                \n                sort.Ints(tmp)\n            }\n        })\n    }\n}\n\n// Comparative benchmarks\nfunc BenchmarkStringBuilding(b *testing.B) {\n    strs := []string{\"hello\", \"world\", \"foo\", \"bar\", \"baz\"}\n    \n    b.Run(\"Concatenation\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            var result string\n            for _, s := range strs {\n                result += s\n            }\n        }\n    })\n    \n    b.Run(\"StringBuilder\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            var builder strings.Builder\n            for _, s := range strs {\n                builder.WriteString(s)\n            }\n            _ = builder.String()\n        }\n    })\n    \n    b.Run(\"BytesBuffer\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            var buffer bytes.Buffer\n            for _, s := range strs {\n                buffer.WriteString(s)\n            }\n            _ = buffer.String()\n        }\n    })\n    \n    b.Run(\"Join\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            _ = strings.Join(strs, \"\")\n        }\n    })\n}\n\n// Memory benchmarks\nfunc BenchmarkMemory(b *testing.B) {\n    b.Run(\"WithAllocation\", func(b *testing.B) {\n        b.ReportAllocs()\n        for i := 0; i < b.N; i++ {\n            s := make([]int, 1000)\n            _ = s\n        }\n    })\n    \n    b.Run(\"WithPool\", func(b *testing.B) {\n        b.ReportAllocs()\n        pool := sync.Pool{\n            New: func() interface{} {\n                return make([]int, 1000)\n            },\n        }\n        \n        for i := 0; i < b.N; i++ {\n            s := pool.Get().([]int)\n            pool.Put(s)\n        }\n    })\n}\n\n// Custom metrics\nfunc BenchmarkThroughput(b *testing.B) {\n    data := make([]byte, 1024*1024) // 1MB\n    \n    b.SetBytes(int64(len(data)))\n    b.ResetTimer()\n    \n    for i := 0; i < b.N; i++ {\n        process(data)\n    }\n    \n    b.ReportMetric(float64(b.N)*float64(len(data))/b.Elapsed().Seconds()/1024/1024, \"MB/s\")\n}\n```\n\n## Memory Management\n\n### Reducing Allocations\n```go\n// Avoid allocations in loops\n// Bad: Allocates in loop\nfunc bad() []string {\n    var results []string\n    for i := 0; i < 1000; i++ {\n        results = append(results, fmt.Sprintf(\"item-%d\", i))\n    }\n    return results\n}\n\n// Good: Preallocate\nfunc good() []string {\n    results := make([]string, 0, 1000)\n    for i := 0; i < 1000; i++ {\n        results = append(results, fmt.Sprintf(\"item-%d\", i))\n    }\n    return results\n}\n\n// Reuse buffers\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc processWithPool(data []byte) string {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n    \n    buf.Write(data)\n    // Process...\n    return buf.String()\n}\n\n// Avoid string allocations\nfunc avoidStringAllocs(b []byte) string {\n    // Bad: Multiple allocations\n    s := string(b)\n    s = strings.ToUpper(s)\n    s = strings.TrimSpace(s)\n    \n    // Better: Work with bytes\n    b = bytes.ToUpper(b)\n    b = bytes.TrimSpace(b)\n    return string(b)\n}\n\n// String interning for repeated strings\ntype StringInterner struct {\n    mu    sync.RWMutex\n    cache map[string]string\n}\n\nfunc (si *StringInterner) Intern(s string) string {\n    si.mu.RLock()\n    if interned, ok := si.cache[s]; ok {\n        si.mu.RUnlock()\n        return interned\n    }\n    si.mu.RUnlock()\n    \n    si.mu.Lock()\n    defer si.mu.Unlock()\n    \n    si.cache[s] = s\n    return s\n}\n```\n\n### Memory Layout Optimization\n```go\n// Struct field alignment\n// Bad: 32 bytes due to padding\ntype Inefficient struct {\n    a bool    // 1 byte + 7 padding\n    b int64   // 8 bytes\n    c bool    // 1 byte + 7 padding\n    d int64   // 8 bytes\n}\n\n// Good: 24 bytes with better alignment\ntype Efficient struct {\n    b int64   // 8 bytes\n    d int64   // 8 bytes\n    a bool    // 1 byte\n    c bool    // 1 byte + 6 padding\n}\n\n// Use smaller types when possible\ntype Flags struct {\n    // Bad: 4 bools = potentially 4 bytes + padding\n    IsActive   bool\n    IsVerified bool\n    IsPremium  bool\n    IsAdmin    bool\n}\n\n// Good: 1 byte using bit flags\ntype CompactFlags uint8\n\nconst (\n    FlagActive CompactFlags = 1 << iota\n    FlagVerified\n    FlagPremium\n    FlagAdmin\n)\n\nfunc (f CompactFlags) IsActive() bool { return f&FlagActive != 0 }\nfunc (f CompactFlags) IsVerified() bool { return f&FlagVerified != 0 }\n\n// Array vs slice for fixed size\ntype Record struct {\n    // Bad: slice has 24 bytes overhead (pointer, len, cap)\n    IDSlice []byte\n    \n    // Good: array for fixed size, no overhead\n    IDArray [16]byte\n}\n```\n\n### Escape Analysis\n```go\n// Understanding escape analysis\n// go build -gcflags=\"-m\" to see escape analysis\n\n// Doesn't escape - allocated on stack\nfunc noEscape() int {\n    x := 42\n    return x\n}\n\n// Escapes to heap - returned pointer\nfunc escapes() *int {\n    x := 42\n    return &x // x escapes to heap\n}\n\n// Avoid unnecessary escapes\ntype Data struct {\n    values [1000]int\n}\n\n// Bad: Escapes to heap\nfunc (d *Data) Sum() int {\n    sum := 0\n    for _, v := range d.values { // d.values escapes\n        sum += v\n    }\n    return sum\n}\n\n// Good: Doesn't escape\nfunc (d Data) SumValue() int {\n    sum := 0\n    for i := 0; i < len(d.values); i++ {\n        sum += d.values[i]\n    }\n    return sum\n}\n\n// Interface causes escape\nfunc processInterface(i interface{}) {\n    // i escapes to heap\n}\n\nfunc avoidEscape() {\n    x := 42\n    processInterface(x) // x escapes\n    \n    // Avoid by not using interface\n    processInt(x) // x doesn't escape\n}\n\nfunc processInt(i int) {\n    // Process int directly\n}\n```\n\n## CPU Optimization\n\n### Hot Path Optimization\n```go\n// Optimize hot paths\nfunc processData(data []int) int {\n    // Move invariants out of loop\n    length := len(data)\n    if length == 0 {\n        return 0\n    }\n    \n    sum := 0\n    // Unroll loop for better performance\n    for i := 0; i < length-3; i += 4 {\n        sum += data[i] + data[i+1] + data[i+2] + data[i+3]\n    }\n    \n    // Handle remaining elements\n    for i := length - length%4; i < length; i++ {\n        sum += data[i]\n    }\n    \n    return sum\n}\n\n// Branch prediction optimization\nfunc findMax(data []int) int {\n    if len(data) == 0 {\n        return 0\n    }\n    \n    max := data[0]\n    for i := 1; i < len(data); i++ {\n        // Branchless max (may be faster)\n        if data[i] > max {\n            max = data[i]\n        }\n    }\n    return max\n}\n\n// Cache-friendly iteration\nfunc sumMatrix(matrix [][]int) int {\n    sum := 0\n    // Row-major order (cache-friendly)\n    for i := 0; i < len(matrix); i++ {\n        for j := 0; j < len(matrix[i]); j++ {\n            sum += matrix[i][j]\n        }\n    }\n    return sum\n}\n\n// SIMD-friendly code\nfunc addSlices(a, b []float64) []float64 {\n    result := make([]float64, len(a))\n    \n    // Compiler may vectorize this\n    for i := range a {\n        result[i] = a[i] + b[i]\n    }\n    \n    return result\n}\n```\n\n### Inlining\n```go\n// Encourage inlining for small functions\n//go:inline\nfunc add(a, b int) int {\n    return a + b\n}\n\n// Prevent inlining for rarely used functions\n//go:noinline\nfunc rarelyUsedFunction() {\n    // Complex logic\n}\n\n// Check inlining decisions\n// go build -gcflags=\"-m=2\"\n\n// Inline-friendly functions\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n\n// Too complex to inline (default threshold ~80 nodes)\nfunc complexFunction(x int) int {\n    // Many operations...\n    return result\n}\n```\n\n## Compiler Optimizations\n\n### Compiler Directives\n```go\n// Bounds check elimination\nfunc sumArray(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    // Compiler can eliminate bounds checks\n    for i := 0; i < len(arr); i++ {\n        sum += arr[i]\n    }\n    return sum\n}\n\n// Help compiler with hints\nfunc process(data []byte) {\n    // Tell compiler minimum length\n    _ = data[3] // Bounds check once\n    \n    // Now these don't need bounds checks\n    a := data[0]\n    b := data[1]\n    c := data[2]\n    d := data[3]\n    \n    // Process a, b, c, d\n}\n\n// Const propagation\nconst bufferSize = 1024\n\nfunc allocateBuffer() []byte {\n    // Compiler knows size at compile time\n    return make([]byte, bufferSize)\n}\n\n// Dead code elimination\nfunc example(debug bool) {\n    if false { // Compiler removes this\n        expensiveDebugOperation()\n    }\n    \n    const debugMode = false\n    if debugMode { // Also removed\n        fmt.Println(\"Debug mode\")\n    }\n}\n```\n\n### Build Flags\n```go\n// Build tags for optimization\n//go:build !debug\n\npackage main\n\nfunc log(msg string) {\n    // No-op in release builds\n}\n\n// Alternative file for debug builds\n//go:build debug\n\npackage main\n\nfunc log(msg string) {\n    fmt.Println(msg)\n}\n\n// Compile with optimizations\n// go build -ldflags=\"-s -w\" # Strip debug info\n// go build -tags release\n// GOOS=linux GOARCH=amd64 go build # Cross-compile\n```\n\n## Caching Strategies\n\n### In-Memory Caching\n```go\n// Simple cache with TTL\ntype Cache struct {\n    mu      sync.RWMutex\n    items   map[string]*cacheItem\n    ttl     time.Duration\n}\n\ntype cacheItem struct {\n    value      interface{}\n    expiration time.Time\n}\n\nfunc NewCache(ttl time.Duration) *Cache {\n    c := &Cache{\n        items: make(map[string]*cacheItem),\n        ttl:   ttl,\n    }\n    go c.cleanup()\n    return c\n}\n\nfunc (c *Cache) Set(key string, value interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    c.items[key] = &cacheItem{\n        value:      value,\n        expiration: time.Now().Add(c.ttl),\n    }\n}\n\nfunc (c *Cache) Get(key string) (interface{}, bool) {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    \n    item, found := c.items[key]\n    if !found {\n        return nil, false\n    }\n    \n    if time.Now().After(item.expiration) {\n        return nil, false\n    }\n    \n    return item.value, true\n}\n\nfunc (c *Cache) cleanup() {\n    ticker := time.NewTicker(c.ttl / 2)\n    defer ticker.Stop()\n    \n    for range ticker.C {\n        c.mu.Lock()\n        now := time.Now()\n        for key, item := range c.items {\n            if now.After(item.expiration) {\n                delete(c.items, key)\n            }\n        }\n        c.mu.Unlock()\n    }\n}\n\n// LRU Cache\ntype LRUCache struct {\n    capacity int\n    items    map[string]*list.Element\n    order    *list.List\n    mu       sync.Mutex\n}\n\ntype lruItem struct {\n    key   string\n    value interface{}\n}\n\nfunc NewLRUCache(capacity int) *LRUCache {\n    return &LRUCache{\n        capacity: capacity,\n        items:    make(map[string]*list.Element),\n        order:    list.New(),\n    }\n}\n\nfunc (c *LRUCache) Get(key string) (interface{}, bool) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    if elem, ok := c.items[key]; ok {\n        c.order.MoveToFront(elem)\n        return elem.Value.(*lruItem).value, true\n    }\n    return nil, false\n}\n\nfunc (c *LRUCache) Set(key string, value interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    if elem, ok := c.items[key]; ok {\n        c.order.MoveToFront(elem)\n        elem.Value.(*lruItem).value = value\n        return\n    }\n    \n    if c.order.Len() >= c.capacity {\n        oldest := c.order.Back()\n        if oldest != nil {\n            c.order.Remove(oldest)\n            delete(c.items, oldest.Value.(*lruItem).key)\n        }\n    }\n    \n    item := &lruItem{key: key, value: value}\n    elem := c.order.PushFront(item)\n    c.items[key] = elem\n}\n```\n\n### Memoization\n```go\n// Function memoization\ntype Memoizer struct {\n    mu    sync.RWMutex\n    cache map[string]interface{}\n    fn    func(string) interface{}\n}\n\nfunc NewMemoizer(fn func(string) interface{}) *Memoizer {\n    return &Memoizer{\n        cache: make(map[string]interface{}),\n        fn:    fn,\n    }\n}\n\nfunc (m *Memoizer) Get(key string) interface{} {\n    m.mu.RLock()\n    if val, ok := m.cache[key]; ok {\n        m.mu.RUnlock()\n        return val\n    }\n    m.mu.RUnlock()\n    \n    m.mu.Lock()\n    defer m.mu.Unlock()\n    \n    // Double-check\n    if val, ok := m.cache[key]; ok {\n        return val\n    }\n    \n    val := m.fn(key)\n    m.cache[key] = val\n    return val\n}\n\n// Concurrent-safe memoization with singleflight\nimport \"golang.org/x/sync/singleflight\"\n\ntype ConcurrentMemoizer struct {\n    cache map[string]interface{}\n    mu    sync.RWMutex\n    group singleflight.Group\n}\n\nfunc (m *ConcurrentMemoizer) Get(key string) (interface{}, error) {\n    m.mu.RLock()\n    if val, ok := m.cache[key]; ok {\n        m.mu.RUnlock()\n        return val, nil\n    }\n    m.mu.RUnlock()\n    \n    // Ensure only one goroutine computes the value\n    val, err, _ := m.group.Do(key, func() (interface{}, error) {\n        result := expensiveComputation(key)\n        \n        m.mu.Lock()\n        m.cache[key] = result\n        m.mu.Unlock()\n        \n        return result, nil\n    })\n    \n    return val, err\n}\n```\n\n## Concurrency Performance\n\n### Goroutine Pool\n```go\n// Efficient goroutine pool\ntype WorkerPool struct {\n    workers   int\n    jobQueue  chan Job\n    results   chan Result\n    wg        sync.WaitGroup\n}\n\nfunc NewWorkerPool(workers int, queueSize int) *WorkerPool {\n    return &WorkerPool{\n        workers:  workers,\n        jobQueue: make(chan Job, queueSize),\n        results:  make(chan Result, queueSize),\n    }\n}\n\nfunc (p *WorkerPool) Start() {\n    for i := 0; i < p.workers; i++ {\n        p.wg.Add(1)\n        go p.worker(i)\n    }\n}\n\nfunc (p *WorkerPool) worker(id int) {\n    defer p.wg.Done()\n    \n    for job := range p.jobQueue {\n        result := processJob(job)\n        p.results <- result\n    }\n}\n\nfunc (p *WorkerPool) Submit(job Job) {\n    p.jobQueue <- job\n}\n\nfunc (p *WorkerPool) Stop() {\n    close(p.jobQueue)\n    p.wg.Wait()\n    close(p.results)\n}\n\n// Lock-free structures\ntype LockFreeStack struct {\n    head atomic.Pointer[node]\n}\n\ntype node struct {\n    value interface{}\n    next  *node\n}\n\nfunc (s *LockFreeStack) Push(v interface{}) {\n    n := &node{value: v}\n    for {\n        head := s.head.Load()\n        n.next = head\n        if s.head.CompareAndSwap(head, n) {\n            return\n        }\n    }\n}\n\nfunc (s *LockFreeStack) Pop() interface{} {\n    for {\n        head := s.head.Load()\n        if head == nil {\n            return nil\n        }\n        if s.head.CompareAndSwap(head, head.next) {\n            return head.value\n        }\n    }\n}\n```\n\n### Channel Optimization\n```go\n// Buffered channels for performance\nfunc efficientPipeline() {\n    // Use buffered channels to reduce blocking\n    input := make(chan int, 100)\n    output := make(chan int, 100)\n    \n    // Producer\n    go func() {\n        defer close(input)\n        for i := 0; i < 1000; i++ {\n            input <- i\n        }\n    }()\n    \n    // Workers\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for val := range input {\n                output <- process(val)\n            }\n        }()\n    }\n    \n    // Close output when workers done\n    go func() {\n        wg.Wait()\n        close(output)\n    }()\n    \n    // Consumer\n    for result := range output {\n        handleResult(result)\n    }\n}\n\n// Batch processing for efficiency\nfunc batchProcessor(input <-chan Item) {\n    batch := make([]Item, 0, 100)\n    ticker := time.NewTicker(100 * time.Millisecond)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case item, ok := <-input:\n            if !ok {\n                if len(batch) > 0 {\n                    processBatch(batch)\n                }\n                return\n            }\n            batch = append(batch, item)\n            \n            if len(batch) >= 100 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n            \n        case <-ticker.C:\n            if len(batch) > 0 {\n                processBatch(batch)\n                batch = batch[:0]\n            }\n        }\n    }\n}\n```\n\n## I/O Optimization\n\n### Buffered I/O\n```go\n// Use buffered I/O\nfunc efficientFileRead(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n    \n    // Use buffered reader\n    reader := bufio.NewReader(file)\n    \n    for {\n        line, err := reader.ReadString('\\n')\n        if err == io.EOF {\n            break\n        }\n        if err != nil {\n            return err\n        }\n        \n        processLine(line)\n    }\n    \n    return nil\n}\n\n// Efficient file writing\nfunc efficientFileWrite(filename string, data []string) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n    \n    // Use buffered writer\n    writer := bufio.NewWriter(file)\n    defer writer.Flush()\n    \n    for _, line := range data {\n        _, err := writer.WriteString(line + \"\\n\")\n        if err != nil {\n            return err\n        }\n    }\n    \n    return nil\n}\n\n// Memory-mapped files for large files\nimport \"golang.org/x/exp/mmap\"\n\nfunc readLargeFile(filename string) error {\n    reader, err := mmap.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer reader.Close()\n    \n    // Read without loading entire file into memory\n    data := make([]byte, 1024)\n    for offset := int64(0); offset < reader.Len(); offset += 1024 {\n        n, err := reader.ReadAt(data, offset)\n        if err != nil && err != io.EOF {\n            return err\n        }\n        \n        processChunk(data[:n])\n    }\n    \n    return nil\n}\n```\n\n### Network I/O\n```go\n// Connection pooling\ntype ConnectionPool struct {\n    connections chan net.Conn\n    factory     func() (net.Conn, error)\n}\n\nfunc NewConnectionPool(size int, factory func() (net.Conn, error)) (*ConnectionPool, error) {\n    pool := &ConnectionPool{\n        connections: make(chan net.Conn, size),\n        factory:     factory,\n    }\n    \n    for i := 0; i < size; i++ {\n        conn, err := factory()\n        if err != nil {\n            return nil, err\n        }\n        pool.connections <- conn\n    }\n    \n    return pool, nil\n}\n\nfunc (p *ConnectionPool) Get() net.Conn {\n    return <-p.connections\n}\n\nfunc (p *ConnectionPool) Put(conn net.Conn) {\n    p.connections <- conn\n}\n\n// HTTP client optimization\nvar httpClient = &http.Client{\n    Timeout: 30 * time.Second,\n    Transport: &http.Transport{\n        MaxIdleConns:        100,\n        MaxIdleConnsPerHost: 10,\n        IdleConnTimeout:     90 * time.Second,\n        DisableCompression:  false,\n        DisableKeepAlives:   false,\n    },\n}\n\n// Batch HTTP requests\nfunc batchHTTPRequests(urls []string) []Response {\n    results := make([]Response, len(urls))\n    var wg sync.WaitGroup\n    \n    // Limit concurrent requests\n    sem := make(chan struct{}, 10)\n    \n    for i, url := range urls {\n        wg.Add(1)\n        go func(idx int, u string) {\n            defer wg.Done()\n            \n            sem <- struct{}{}\n            defer func() { <-sem }()\n            \n            resp, err := httpClient.Get(u)\n            if err != nil {\n                results[idx] = Response{Error: err}\n                return\n            }\n            defer resp.Body.Close()\n            \n            body, _ := io.ReadAll(resp.Body)\n            results[idx] = Response{Data: body}\n        }(i, url)\n    }\n    \n    wg.Wait()\n    return results\n}\n```\n\n## Data Structure Optimization\n\n### Slice Optimization\n```go\n// Preallocate slices\nfunc optimizedSliceOperations() {\n    // Know the capacity\n    slice := make([]int, 0, 1000)\n    \n    // Grow efficiently\n    if cap(slice) < requiredSize {\n        newSlice := make([]int, len(slice), requiredSize*2)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    \n    // Clear slice for reuse\n    slice = slice[:0]\n    \n    // Remove element efficiently\n    func removeAt(s []int, i int) []int {\n        s[i] = s[len(s)-1]\n        return s[:len(s)-1]\n    }\n}\n\n// Custom growing strategy\ntype GrowableBuffer struct {\n    data []byte\n}\n\nfunc (b *GrowableBuffer) grow(n int) {\n    if cap(b.data)-len(b.data) < n {\n        newCap := cap(b.data) * 2\n        if newCap < len(b.data)+n {\n            newCap = len(b.data) + n\n        }\n        newData := make([]byte, len(b.data), newCap)\n        copy(newData, b.data)\n        b.data = newData\n    }\n}\n```\n\n### Map Optimization\n```go\n// Preallocate maps\nm := make(map[string]int, 1000)\n\n// Use appropriate key types\n// Faster: int keys\nfastMap := make(map[int]string)\n\n// Slower: string keys (requires hashing)\nslowMap := make(map[string]string)\n\n// Custom hash map for specific use case\ntype FastStringMap struct {\n    buckets [][]entry\n    size    int\n}\n\ntype entry struct {\n    key   string\n    value interface{}\n}\n\nfunc (m *FastStringMap) hash(key string) uint32 {\n    // Fast hash function\n    h := uint32(2166136261)\n    for i := 0; i < len(key); i++ {\n        h *= 16777619\n        h ^= uint32(key[i])\n    }\n    return h\n}\n\nfunc (m *FastStringMap) Get(key string) (interface{}, bool) {\n    h := m.hash(key) % uint32(len(m.buckets))\n    bucket := m.buckets[h]\n    \n    for _, e := range bucket {\n        if e.key == key {\n            return e.value, true\n        }\n    }\n    return nil, false\n}\n```\n\n### String Optimization\n```go\n// String concatenation optimization\nfunc efficientStringConcat(strs []string) string {\n    // Calculate total length\n    var totalLen int\n    for _, s := range strs {\n        totalLen += len(s)\n    }\n    \n    // Preallocate builder\n    var builder strings.Builder\n    builder.Grow(totalLen)\n    \n    for _, s := range strs {\n        builder.WriteString(s)\n    }\n    \n    return builder.String()\n}\n\n// Avoid string copies\nfunc stringToBytes(s string) []byte {\n    // Safe conversion without copy (read-only)\n    return unsafe.Slice(unsafe.StringData(s), len(s))\n}\n\nfunc bytesToString(b []byte) string {\n    // Safe conversion without copy\n    return unsafe.String(unsafe.SliceData(b), len(b))\n}\n```\n\n## Performance Best Practices\n\n### Measurement and Profiling\n```go\n// Always measure before optimizing\nfunc measurePerformance() {\n    start := time.Now()\n    defer func() {\n        elapsed := time.Since(start)\n        log.Printf(\"Operation took %v\", elapsed)\n    }()\n    \n    // Operation to measure\n}\n\n// Use benchmarks for micro-optimizations\nfunc BenchmarkOptimization(b *testing.B) {\n    // Test different approaches\n}\n\n// Profile in production\nimport _ \"net/http/pprof\"\n// Access profiles at /debug/pprof/\n```\n\n### Common Optimizations\n```go\n// 1. Avoid premature optimization\n// Profile first, optimize bottlenecks\n\n// 2. Reduce allocations\n// Use sync.Pool, preallocate slices\n\n// 3. Optimize hot paths\n// Focus on frequently executed code\n\n// 4. Use efficient algorithms\n// O(n) vs O(n²) matters at scale\n\n// 5. Cache computed values\n// Memoization, lookup tables\n\n// 6. Batch operations\n// Reduce system calls, network requests\n\n// 7. Use appropriate data structures\n// Map vs slice, array vs slice\n\n// 8. Leverage concurrency wisely\n// Don't overuse goroutines\n\n// 9. Minimize interface conversions\n// Interfaces cause allocations\n\n// 10. Profile regularly\n// Performance can degrade over time\n```\n\n## Best Practices Summary\n\n1. **Profile before optimizing** - Measure, don't guess\n2. **Focus on algorithms first** - Better algorithm beats micro-optimizations\n3. **Reduce allocations** - Use pools, preallocate, reuse\n4. **Optimize hot paths** - 80/20 rule applies\n5. **Cache aggressively** - But invalidate correctly\n6. **Use buffered I/O** - For file and network operations\n7. **Batch operations** - Amortize overhead\n8. **Choose right data structures** - Map vs slice matters\n9. **Leverage compiler optimizations** - Write optimizer-friendly code\n10. **Monitor production performance** - Use pprof, metrics, tracing","structuredPatch":[]}}
{"parentUuid":"62467738-6f1a-4872-9e91-7c1a111c89a8","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_015mKmEoZHBnYnLdkfCjYpiS","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Let me continue with the remaining documentation files:\n\n## 6. Go Packages"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9945,"cache_read_input_tokens":80967,"output_tokens":7643,"service_tier":"standard"}},"requestId":"req_011CS5JzZD69Lv9iSR2AZ8Rp","type":"assistant","uuid":"77881a2e-c1b3-4b13-8d62-432667f5b373","timestamp":"2025-08-13T07:25:49.431Z"}
{"parentUuid":"77881a2e-c1b3-4b13-8d62-432667f5b373","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_015mKmEoZHBnYnLdkfCjYpiS","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01FbAmpZAG6ti8URBVRVRFmH","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-packages.md","content":"# Go Packages - Package Design and Management\n\n## Table of Contents\n1. [Package Design](#package-design)\n2. [API Design](#api-design)\n3. [Internal Packages](#internal-packages)\n4. [Versioning](#versioning)\n5. [Documentation](#documentation)\n6. [Module Management](#module-management)\n7. [Dependencies](#dependencies)\n8. [Package Patterns](#package-patterns)\n9. [Publishing Packages](#publishing-packages)\n10. [Best Practices](#best-practices)\n\n## Package Design\n\n### Package Structure\n```go\n// Package naming conventions\npackage user        // Good: singular, lowercase\npackage users       // Bad: plural\npackage userMgmt    // Bad: camelCase\npackage user_mgmt   // Bad: underscore\n\n// Package organization\nmyproject/\n├── cmd/\n│   ├── api/\n│   │   └── main.go\n│   └── worker/\n│       └── main.go\n├── internal/\n│   ├── auth/\n│   ├── database/\n│   └── models/\n├── pkg/\n│   ├── client/\n│   └── utils/\n├── api/\n│   └── v1/\n├── docs/\n├── scripts/\n├── go.mod\n└── go.sum\n\n// Package declaration with documentation\n// Package user provides user management functionality.\n// It includes user creation, authentication, and profile management.\npackage user\n\n// Import grouping\nimport (\n    // Standard library\n    \"context\"\n    \"fmt\"\n    \"time\"\n    \n    // Third-party packages\n    \"github.com/google/uuid\"\n    \"golang.org/x/crypto/bcrypt\"\n    \n    // Internal packages\n    \"myproject/internal/database\"\n    \"myproject/pkg/errors\"\n)\n```\n\n### Package Cohesion\n```go\n// High cohesion - related functionality\npackage auth\n\ntype Authenticator interface {\n    Authenticate(credentials Credentials) (*User, error)\n    Refresh(token string) (*Token, error)\n    Revoke(token string) error\n}\n\ntype Credentials struct {\n    Username string\n    Password string\n}\n\ntype Token struct {\n    AccessToken  string\n    RefreshToken string\n    ExpiresAt    time.Time\n}\n\ntype User struct {\n    ID       string\n    Username string\n    Roles    []string\n}\n\n// Low cohesion - avoid generic packages\npackage utils  // Bad: too generic\n\nfunc HashPassword(password string) string { }\nfunc SendEmail(to, subject, body string) error { }\nfunc ParseJSON(data []byte) (interface{}, error) { }\nfunc GenerateID() string { }\n\n// Better: specific packages\npackage password\npackage email\npackage json\npackage id\n```\n\n### Package Dependencies\n```go\n// Minimize dependencies\npackage user\n\n// Good: depends only on necessary packages\nimport (\n    \"context\"\n    \"myproject/internal/database\"\n)\n\n// Bad: too many dependencies\nimport (\n    \"myproject/internal/auth\"\n    \"myproject/internal/email\"\n    \"myproject/internal/sms\"\n    \"myproject/internal/push\"\n    \"myproject/internal/analytics\"\n    // ... many more\n)\n\n// Dependency inversion\npackage service\n\n// Define interface in the consumer package\ntype UserRepository interface {\n    GetUser(ctx context.Context, id string) (*User, error)\n    SaveUser(ctx context.Context, user *User) error\n}\n\ntype UserService struct {\n    repo UserRepository  // Depend on interface\n}\n\n// Implementation in another package\npackage database\n\ntype PostgresUserRepository struct {\n    db *sql.DB\n}\n\nfunc (r *PostgresUserRepository) GetUser(ctx context.Context, id string) (*User, error) {\n    // Implementation\n}\n\n// Avoid circular dependencies\npackage a\nimport \"b\"  // a depends on b\n\npackage b\nimport \"a\"  // b depends on a - CIRCULAR!\n\n// Solution: introduce interface or third package\npackage c\ntype SharedInterface interface { }\n\npackage a\nimport \"c\"\n\npackage b\nimport \"c\"\n```\n\n## API Design\n\n### Exported vs Unexported\n```go\npackage mypackage\n\n// Exported (public) - capitalized\ntype Client struct {\n    Endpoint string\n    Timeout  time.Duration\n}\n\nfunc NewClient(endpoint string) *Client {\n    return &Client{\n        Endpoint: endpoint,\n        Timeout:  30 * time.Second,\n    }\n}\n\nfunc (c *Client) Request(ctx context.Context, data []byte) (*Response, error) {\n    return c.doRequest(ctx, data)\n}\n\n// Unexported (private) - lowercase\ntype config struct {\n    retryCount int\n    backoff    time.Duration\n}\n\nfunc (c *Client) doRequest(ctx context.Context, data []byte) (*Response, error) {\n    // Internal implementation\n}\n\n// Partially exported struct\ntype Response struct {\n    Status  int         // Exported\n    Data    []byte      // Exported\n    headers http.Header // Unexported\n}\n```\n\n### API Stability\n```go\n// Stable API design\npackage stable\n\n// Use interfaces for flexibility\ntype Store interface {\n    Get(key string) ([]byte, error)\n    Set(key string, value []byte) error\n    Delete(key string) error\n}\n\n// Options pattern for extensibility\ntype ClientOptions struct {\n    Timeout     time.Duration\n    MaxRetries  int\n    Headers     map[string]string\n    // Can add new fields without breaking\n}\n\nfunc NewClient(opts ClientOptions) *Client {\n    // Set defaults for zero values\n    if opts.Timeout == 0 {\n        opts.Timeout = 30 * time.Second\n    }\n    if opts.MaxRetries == 0 {\n        opts.MaxRetries = 3\n    }\n    \n    return &Client{opts: opts}\n}\n\n// Functional options for better API\ntype Option func(*Client)\n\nfunc WithTimeout(d time.Duration) Option {\n    return func(c *Client) {\n        c.timeout = d\n    }\n}\n\nfunc WithRetries(n int) Option {\n    return func(c *Client) {\n        c.maxRetries = n\n    }\n}\n\nfunc NewClientWithOptions(opts ...Option) *Client {\n    c := &Client{\n        timeout:    30 * time.Second,\n        maxRetries: 3,\n    }\n    \n    for _, opt := range opts {\n        opt(c)\n    }\n    \n    return c\n}\n\n// Deprecation\n// Deprecated: Use NewClientWithOptions instead.\nfunc NewClientOld(endpoint string) *Client {\n    return NewClientWithOptions(WithEndpoint(endpoint))\n}\n```\n\n### Error Design\n```go\npackage mypackage\n\n// Sentinel errors\nvar (\n    ErrNotFound      = errors.New(\"not found\")\n    ErrUnauthorized  = errors.New(\"unauthorized\")\n    ErrInvalidInput  = errors.New(\"invalid input\")\n)\n\n// Error types\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error on field %s: %s\", e.Field, e.Message)\n}\n\n// Error wrapping\nfunc GetUser(id string) (*User, error) {\n    user, err := db.Query(id)\n    if err != nil {\n        if errors.Is(err, sql.ErrNoRows) {\n            return nil, ErrNotFound\n        }\n        return nil, fmt.Errorf(\"failed to get user %s: %w\", id, err)\n    }\n    return user, nil\n}\n\n// Custom error checking\nfunc IsNotFound(err error) bool {\n    return errors.Is(err, ErrNotFound)\n}\n\nfunc IsValidation(err error) bool {\n    var validationErr ValidationError\n    return errors.As(err, &validationErr)\n}\n```\n\n## Internal Packages\n\n### Using Internal\n```go\n// internal/ prevents external imports\nmyproject/\n├── internal/\n│   ├── auth/       // Only importable within myproject\n│   ├── database/\n│   └── config/\n├── pkg/\n│   └── public/     // Importable by anyone\n└── cmd/\n\n// In myproject/internal/auth/auth.go\npackage auth\n\ntype internalAuthenticator struct {\n    // Cannot be imported outside myproject\n}\n\n// In external project - FAILS\nimport \"github.com/user/myproject/internal/auth\" // Compile error!\n\n// Internal for sub-packages\nmyproject/\n├── feature/\n│   ├── internal/   // Only importable within feature/\n│   ├── api/\n│   └── service/\n\n// Organizing internal packages\ninternal/\n├── platform/       // Platform-specific code\n│   ├── database/\n│   ├── cache/\n│   └── queue/\n├── domain/         // Business logic\n│   ├── user/\n│   ├── order/\n│   └── payment/\n└── adapter/        // External adapters\n    ├── http/\n    ├── grpc/\n    └── cli/\n```\n\n### Internal Best Practices\n```go\n// Hide implementation details\n// Public package\npackage user\n\ntype Service interface {\n    GetUser(id string) (*User, error)\n}\n\nfunc NewService(db Database) Service {\n    return &service{\n        db: db,\n        validator: internal.NewValidator(),\n    }\n}\n\n// Internal package\npackage internal\n\ntype Validator struct {\n    rules []Rule\n}\n\nfunc NewValidator() *Validator {\n    // Hidden from external packages\n}\n\n// Share code between packages\ninternal/\n├── shared/\n│   ├── logger/\n│   ├── metrics/\n│   └── errors/\n\n// Use in multiple packages\npackage service1\nimport \"myproject/internal/shared/logger\"\n\npackage service2\nimport \"myproject/internal/shared/logger\"\n```\n\n## Versioning\n\n### Semantic Versioning\n```go\n// go.mod versioning\nmodule github.com/user/myproject\n\ngo 1.21\n\nrequire (\n    github.com/some/dep v1.2.3   // Exact version\n    github.com/other/dep v2.0.0+incompatible\n    github.com/new/dep/v2 v2.1.0 // Major version in path\n)\n\n// Version tags\n// git tag v1.0.0\n// git tag v1.0.1\n// git tag v1.1.0\n// git tag v2.0.0\n\n// Major version changes (v2+)\n// Update module path\nmodule github.com/user/myproject/v2\n\n// Import with version\nimport \"github.com/user/myproject/v2/pkg/client\"\n\n// Maintaining multiple versions\nmyproject/\n├── go.mod          // module github.com/user/myproject\n└── v2/\n    └── go.mod      // module github.com/user/myproject/v2\n\n// Version constraints\nrequire (\n    github.com/some/dep v1.2.3     // Exact\n    github.com/some/dep v1.2.x     // Patch updates\n    github.com/some/dep v1.x.x     // Minor updates\n    github.com/some/dep latest     // Latest\n    github.com/some/dep master     // Branch\n)\n```\n\n### API Versioning\n```go\n// Package versioning\napi/\n├── v1/\n│   └── client.go\n└── v2/\n    └── client.go\n\n// v1/client.go\npackage v1\n\ntype Client struct {\n    Endpoint string\n}\n\nfunc (c *Client) Request(data string) (string, error) {\n    // v1 implementation\n}\n\n// v2/client.go\npackage v2\n\ntype Client struct {\n    Endpoint string\n    Timeout  time.Duration  // New field\n}\n\nfunc (c *Client) Request(ctx context.Context, data []byte) ([]byte, error) {\n    // v2 implementation with context\n}\n\n// Supporting multiple versions\npackage api\n\nimport (\n    v1 \"myproject/api/v1\"\n    v2 \"myproject/api/v2\"\n)\n\nfunc NewClientV1() *v1.Client {\n    return &v1.Client{}\n}\n\nfunc NewClientV2() *v2.Client {\n    return &v2.Client{}\n}\n```\n\n## Documentation\n\n### Package Documentation\n```go\n// Package documentation (doc.go)\n/*\nPackage user provides user management functionality for the application.\n\nThe package includes:\n  - User CRUD operations\n  - Authentication and authorization\n  - Profile management\n  - Password reset functionality\n\nBasic usage:\n\n\tservice := user.NewService(db)\n\t\n\t// Create user\n\tu, err := service.Create(ctx, user.CreateRequest{\n\t\tEmail:    \"user@example.com\",\n\t\tPassword: \"secure123\",\n\t})\n\t\n\t// Authenticate\n\ttoken, err := service.Authenticate(ctx, email, password)\n\nFor more examples, see the examples directory.\n*/\npackage user\n\n// Type documentation\n// User represents a system user.\n// Users can have multiple roles and permissions.\ntype User struct {\n    // ID is the unique identifier for the user.\n    ID string\n    \n    // Email is the user's email address.\n    // It must be unique across all users.\n    Email string\n    \n    // CreatedAt is when the user was created.\n    CreatedAt time.Time\n    \n    // Roles contains the user's assigned roles.\n    Roles []Role\n}\n\n// Method documentation\n// Create creates a new user with the given request.\n// It returns an error if the email already exists or validation fails.\n//\n// Example:\n//\n//\tuser, err := service.Create(ctx, CreateRequest{\n//\t    Email:    \"user@example.com\",\n//\t    Password: \"secure123\",\n//\t})\n//\tif err != nil {\n//\t    log.Fatal(err)\n//\t}\nfunc (s *Service) Create(ctx context.Context, req CreateRequest) (*User, error) {\n    // Implementation\n}\n\n// Deprecated documentation\n// Deprecated: Use CreateWithOptions instead.\n// This function will be removed in v2.0.0.\nfunc (s *Service) CreateOld(email, password string) (*User, error) {\n    return s.CreateWithOptions(CreateOptions{\n        Email:    email,\n        Password: password,\n    })\n}\n```\n\n### Examples\n```go\n// Example functions (show in documentation)\nfunc ExampleService_Create() {\n    service := NewService(mockDB)\n    ctx := context.Background()\n    \n    user, err := service.Create(ctx, CreateRequest{\n        Email:    \"user@example.com\",\n        Password: \"secure123\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    \n    fmt.Println(user.Email)\n    // Output: user@example.com\n}\n\n// Example with suffix\nfunc ExampleService_Create_withRoles() {\n    service := NewService(mockDB)\n    ctx := context.Background()\n    \n    user, err := service.Create(ctx, CreateRequest{\n        Email:    \"admin@example.com\",\n        Password: \"secure123\",\n        Roles:    []string{\"admin\", \"user\"},\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    \n    fmt.Println(user.Roles)\n    // Output: [admin user]\n}\n\n// Package examples\nfunc Example() {\n    // Initialize service\n    db := setupDatabase()\n    service := NewService(db)\n    \n    // Create user\n    user, _ := service.Create(context.Background(), CreateRequest{\n        Email: \"user@example.com\",\n    })\n    \n    // Authenticate\n    token, _ := service.Authenticate(context.Background(), \n        user.Email, \"password\")\n    \n    fmt.Println(token != \"\")\n    // Output: true\n}\n\n// Testable examples\nfunc ExampleService_paginate() {\n    users := []User{\n        {Email: \"user1@example.com\"},\n        {Email: \"user2@example.com\"},\n        {Email: \"user3@example.com\"},\n    }\n    \n    page := Paginate(users, 2, 1)\n    for _, u := range page {\n        fmt.Println(u.Email)\n    }\n    // Output:\n    // user1@example.com\n    // user2@example.com\n}\n```\n\n## Module Management\n\n### Go Modules\n```go\n// Initialize module\n// go mod init github.com/user/project\n\n// go.mod structure\nmodule github.com/user/project\n\ngo 1.21\n\nrequire (\n    github.com/gorilla/mux v1.8.0\n    github.com/stretchr/testify v1.8.0\n)\n\nrequire (\n    // Indirect dependencies\n    github.com/davecgh/go-spew v1.1.1 // indirect\n    github.com/pmezard/go-difflib v1.0.0 // indirect\n)\n\n// Replace directive\nreplace github.com/old/package => github.com/new/package v1.0.0\n\n// Local replace for development\nreplace github.com/user/dependency => ../dependency\n\n// Exclude versions\nexclude github.com/bad/package v1.0.0\n\n// Retract versions (go 1.16+)\nretract (\n    v1.0.0 // Critical bug\n    v1.0.1 // Security issue\n)\n\n// Module commands\n// go mod download    - Download dependencies\n// go mod tidy       - Clean up dependencies\n// go mod verify     - Verify dependencies\n// go mod graph      - Show dependency graph\n// go mod vendor     - Create vendor directory\n// go mod why pkg    - Explain why package is needed\n```\n\n### Workspace Mode\n```go\n// go.work (Go 1.18+)\ngo 1.21\n\nuse (\n    ./project1\n    ./project2\n    ../shared\n)\n\nreplace github.com/example/lib => ../lib\n\n// Commands\n// go work init project1 project2\n// go work use ../another-project\n// go work sync\n\n// Development workflow\nworkspace/\n├── go.work\n├── project1/\n│   └── go.mod\n├── project2/\n│   └── go.mod\n└── shared/\n    └── go.mod\n\n// Each project has its own module\n// Work on multiple modules simultaneously\n```\n\n## Dependencies\n\n### Managing Dependencies\n```go\n// Adding dependencies\n// go get github.com/pkg/errors\n// go get github.com/pkg/errors@v0.9.1\n// go get github.com/pkg/errors@latest\n// go get github.com/pkg/errors@master\n\n// Updating dependencies\n// go get -u                    - Update all\n// go get -u ./...             - Update all in module\n// go get -u=patch ./...       - Update patch versions\n// go get -u github.com/pkg/...  - Update specific package\n\n// Removing dependencies\n// go mod tidy                  - Remove unused\n\n// Vendoring\n// go mod vendor               - Create vendor/\n// go build -mod=vendor        - Build with vendor/\n\n// Dependency analysis\nimport \"golang.org/x/mod/modfile\"\n\nfunc analyzeDependencies() {\n    data, _ := os.ReadFile(\"go.mod\")\n    file, _ := modfile.Parse(\"go.mod\", data, nil)\n    \n    for _, req := range file.Require {\n        fmt.Printf(\"%s: %s\\n\", req.Mod.Path, req.Mod.Version)\n    }\n}\n\n// Private dependencies\n// Set GOPRIVATE environment variable\n// GOPRIVATE=github.com/company/*\n\n// Use .netrc for authentication\n// machine github.com\n// login username\n// password token\n\n// Or use SSH\n// git config --global url.\"git@github.com:\".insteadOf \"https://github.com/\"\n```\n\n### Dependency Injection\n```go\n// Constructor injection\ntype Service struct {\n    db     Database\n    cache  Cache\n    logger Logger\n}\n\nfunc NewService(db Database, cache Cache, logger Logger) *Service {\n    return &Service{\n        db:     db,\n        cache:  cache,\n        logger: logger,\n    }\n}\n\n// Interface injection\ntype Database interface {\n    Query(string) ([]Row, error)\n}\n\ntype Cache interface {\n    Get(string) (interface{}, bool)\n    Set(string, interface{})\n}\n\n// Wire for dependency injection\n//go:build wireinject\n\nimport \"github.com/google/wire\"\n\nfunc InitializeService() (*Service, error) {\n    wire.Build(\n        NewDatabase,\n        NewCache,\n        NewLogger,\n        NewService,\n    )\n    return nil, nil\n}\n\n// Provider sets\nvar BasicSet = wire.NewSet(\n    NewDatabase,\n    NewCache,\n    NewLogger,\n)\n\nvar ServiceSet = wire.NewSet(\n    BasicSet,\n    NewService,\n    NewRepository,\n)\n```\n\n## Package Patterns\n\n### Plugin Pattern\n```go\n// Plugin interface\npackage plugin\n\ntype Plugin interface {\n    Name() string\n    Initialize(config map[string]interface{}) error\n    Execute(context.Context, interface{}) (interface{}, error)\n    Shutdown() error\n}\n\n// Registry\ntype Registry struct {\n    mu      sync.RWMutex\n    plugins map[string]Plugin\n}\n\nfunc (r *Registry) Register(p Plugin) {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    r.plugins[p.Name()] = p\n}\n\nfunc (r *Registry) Get(name string) (Plugin, bool) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    p, ok := r.plugins[name]\n    return p, ok\n}\n\n// Plugin implementation\npackage myplugin\n\ntype MyPlugin struct {\n    config map[string]interface{}\n}\n\nfunc (p *MyPlugin) Name() string {\n    return \"my-plugin\"\n}\n\nfunc (p *MyPlugin) Initialize(config map[string]interface{}) error {\n    p.config = config\n    return nil\n}\n\n// Auto-registration\nfunc init() {\n    plugin.DefaultRegistry.Register(&MyPlugin{})\n}\n```\n\n### Provider Pattern\n```go\n// Provider interface\npackage provider\n\ntype StorageProvider interface {\n    Read(key string) ([]byte, error)\n    Write(key string, data []byte) error\n    Delete(key string) error\n}\n\n// Factory\ntype ProviderFactory func(config Config) (StorageProvider, error)\n\nvar providers = make(map[string]ProviderFactory)\n\nfunc Register(name string, factory ProviderFactory) {\n    providers[name] = factory\n}\n\nfunc New(name string, config Config) (StorageProvider, error) {\n    factory, ok := providers[name]\n    if !ok {\n        return nil, fmt.Errorf(\"unknown provider: %s\", name)\n    }\n    return factory(config)\n}\n\n// S3 provider\npackage s3\n\nfunc init() {\n    provider.Register(\"s3\", NewS3Provider)\n}\n\nfunc NewS3Provider(config provider.Config) (provider.StorageProvider, error) {\n    return &S3Provider{\n        bucket: config.Get(\"bucket\"),\n        region: config.Get(\"region\"),\n    }, nil\n}\n```\n\n### Repository Pattern\n```go\npackage repository\n\n// Generic repository interface\ntype Repository[T any] interface {\n    Find(ctx context.Context, id string) (*T, error)\n    FindAll(ctx context.Context) ([]*T, error)\n    Create(ctx context.Context, entity *T) error\n    Update(ctx context.Context, entity *T) error\n    Delete(ctx context.Context, id string) error\n}\n\n// Specific implementation\ntype UserRepository interface {\n    Repository[User]\n    FindByEmail(ctx context.Context, email string) (*User, error)\n    FindByRole(ctx context.Context, role string) ([]*User, error)\n}\n\n// SQL implementation\ntype sqlUserRepository struct {\n    db *sql.DB\n}\n\nfunc NewSQLUserRepository(db *sql.DB) UserRepository {\n    return &sqlUserRepository{db: db}\n}\n\nfunc (r *sqlUserRepository) Find(ctx context.Context, id string) (*User, error) {\n    query := `SELECT id, email, created_at FROM users WHERE id = $1`\n    // Implementation\n}\n\n// MongoDB implementation\ntype mongoUserRepository struct {\n    collection *mongo.Collection\n}\n\nfunc NewMongoUserRepository(db *mongo.Database) UserRepository {\n    return &mongoUserRepository{\n        collection: db.Collection(\"users\"),\n    }\n}\n```\n\n## Publishing Packages\n\n### Preparing for Publication\n```go\n// 1. Choose a good name\n// - Descriptive and unique\n// - Avoid generic names (utils, helpers, common)\n// - Check if name is available\n\n// 2. Create comprehensive documentation\n// - README.md with examples\n// - Package documentation\n// - API documentation\n// - CONTRIBUTING.md\n// - LICENSE file\n\n// 3. Add examples\nexamples/\n├── basic/\n│   └── main.go\n├── advanced/\n│   └── main.go\n└── README.md\n\n// 4. Write comprehensive tests\n// - Unit tests\n// - Integration tests\n// - Benchmarks\n// - Examples\n\n// 5. Set up CI/CD\n// .github/workflows/test.yml\nname: Test\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: actions/setup-go@v2\n      with:\n        go-version: 1.21\n    - run: go test -v ./...\n    - run: go test -race ./...\n    - run: go test -cover ./...\n```\n\n### Publishing Process\n```bash\n# 1. Tag version\ngit tag v1.0.0\ngit push origin v1.0.0\n\n# 2. The package is automatically available\n# go get github.com/username/package@v1.0.0\n\n# 3. Update pkg.go.dev\n# Visit https://pkg.go.dev/github.com/username/package\n# Click \"Request\" button\n\n# 4. Add badges to README\n[![Go Reference](https://pkg.go.dev/badge/github.com/username/package.svg)](https://pkg.go.dev/github.com/username/package)\n[![Go Report Card](https://goreportcard.com/badge/github.com/username/package)](https://goreportcard.com/report/github.com/username/package)\n[![Coverage Status](https://coveralls.io/repos/github/username/package/badge.svg)](https://coveralls.io/github/username/package)\n\n# 5. Create release on GitHub\n# - Add release notes\n# - Attach binaries if applicable\n```\n\n### Package Maintenance\n```go\n// Deprecation process\n// 1. Mark as deprecated in documentation\n// Deprecated: Use NewFunction instead.\n// This will be removed in v2.0.0.\nfunc OldFunction() {}\n\n// 2. Log deprecation warnings\nfunc OldFunction() {\n    log.Println(\"Warning: OldFunction is deprecated. Use NewFunction instead.\")\n    // Existing implementation\n}\n\n// 3. Provide migration guide\n/*\nMigration Guide from v1 to v2:\n\n1. Replace OldFunction() with NewFunction()\n2. Update Client struct initialization:\n   Old: client := &Client{Endpoint: \"url\"}\n   New: client := NewClient(WithEndpoint(\"url\"))\n3. Change import path:\n   Old: import \"github.com/user/package\"\n   New: import \"github.com/user/package/v2\"\n*/\n\n// Version compatibility\n// Support multiple versions\npackage compat\n\nimport (\n    v1 \"mypackage/v1\"\n    v2 \"mypackage/v2\"\n)\n\nfunc MigrateV1ToV2(old *v1.Config) *v2.Config {\n    return &v2.Config{\n        // Map old fields to new\n    }\n}\n```\n\n## Best Practices\n\n### Package Design Principles\n```go\n// 1. Single Responsibility\n// Each package should have one clear purpose\n\n// 2. Minimal Public API\n// Export only what's necessary\npackage mypackage\n\ntype Client struct{} // Exported\n\ntype implementation struct{} // Unexported\n\n// 3. Accept Interfaces, Return Structs\nfunc Process(r io.Reader) *Result {\n    // Accept interface for flexibility\n    // Return concrete type for clarity\n}\n\n// 4. Avoid Init Functions\n// Bad: Side effects on import\nfunc init() {\n    database.Connect() // Side effect!\n}\n\n// Good: Explicit initialization\nfunc Initialize() error {\n    return database.Connect()\n}\n\n// 5. No Circular Dependencies\n// Use interfaces to break cycles\n\n// 6. Consistent Naming\n// Package name should match directory name\n// Avoid stuttering: user.User not user.UserUser\n\n// 7. Semantic Versioning\n// Follow semver strictly\n// Major.Minor.Patch\n\n// 8. Comprehensive Testing\n// Aim for >80% coverage\n// Include edge cases\n\n// 9. Clear Documentation\n// Document all exports\n// Provide examples\n\n// 10. Minimal Dependencies\n// Avoid unnecessary dependencies\n// Vendor or ensure stability\n```\n\n### Common Pitfalls\n```go\n// 1. Overusing init()\n// Avoid side effects on import\n\n// 2. God packages\n// Don't create packages that do everything\n\n// 3. Premature abstraction\n// Start simple, refactor when needed\n\n// 4. Ignoring internal/\n// Use internal/ for non-public code\n\n// 5. Poor error messages\n// Provide context in errors\n\n// 6. Breaking changes in minor versions\n// Use major version for breaking changes\n\n// 7. No examples\n// Always provide usage examples\n\n// 8. Inconsistent API\n// Maintain consistency across package\n\n// 9. Global state\n// Avoid package-level variables\n\n// 10. Missing context support\n// Accept context.Context in long operations\n```\n\n## Best Practices Summary\n\n1. **Design cohesive packages** - Single, clear purpose\n2. **Minimize public API** - Export only what's necessary  \n3. **Use internal packages** - Hide implementation details\n4. **Follow semantic versioning** - Major.Minor.Patch\n5. **Document thoroughly** - Package, types, functions\n6. **Provide examples** - Show common usage patterns\n7. **Accept interfaces** - Return concrete types\n8. **Avoid circular dependencies** - Use interfaces to break cycles\n9. **Test comprehensively** - Unit, integration, benchmarks\n10. **Maintain backwards compatibility** - Use versioning for breaking changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9945,"cache_read_input_tokens":80967,"output_tokens":7643,"service_tier":"standard"}},"requestId":"req_011CS5JzZD69Lv9iSR2AZ8Rp","type":"assistant","uuid":"430366c1-62c6-459f-a055-8ed49bc07f38","timestamp":"2025-08-13T07:27:58.710Z"}
{"parentUuid":"430366c1-62c6-459f-a055-8ed49bc07f38","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FbAmpZAG6ti8URBVRVRFmH","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/go-packages.md"}]},"uuid":"8c6dc011-211f-426b-bda4-09fdeac10443","timestamp":"2025-08-13T07:27:58.745Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-packages.md","content":"# Go Packages - Package Design and Management\n\n## Table of Contents\n1. [Package Design](#package-design)\n2. [API Design](#api-design)\n3. [Internal Packages](#internal-packages)\n4. [Versioning](#versioning)\n5. [Documentation](#documentation)\n6. [Module Management](#module-management)\n7. [Dependencies](#dependencies)\n8. [Package Patterns](#package-patterns)\n9. [Publishing Packages](#publishing-packages)\n10. [Best Practices](#best-practices)\n\n## Package Design\n\n### Package Structure\n```go\n// Package naming conventions\npackage user        // Good: singular, lowercase\npackage users       // Bad: plural\npackage userMgmt    // Bad: camelCase\npackage user_mgmt   // Bad: underscore\n\n// Package organization\nmyproject/\n├── cmd/\n│   ├── api/\n│   │   └── main.go\n│   └── worker/\n│       └── main.go\n├── internal/\n│   ├── auth/\n│   ├── database/\n│   └── models/\n├── pkg/\n│   ├── client/\n│   └── utils/\n├── api/\n│   └── v1/\n├── docs/\n├── scripts/\n├── go.mod\n└── go.sum\n\n// Package declaration with documentation\n// Package user provides user management functionality.\n// It includes user creation, authentication, and profile management.\npackage user\n\n// Import grouping\nimport (\n    // Standard library\n    \"context\"\n    \"fmt\"\n    \"time\"\n    \n    // Third-party packages\n    \"github.com/google/uuid\"\n    \"golang.org/x/crypto/bcrypt\"\n    \n    // Internal packages\n    \"myproject/internal/database\"\n    \"myproject/pkg/errors\"\n)\n```\n\n### Package Cohesion\n```go\n// High cohesion - related functionality\npackage auth\n\ntype Authenticator interface {\n    Authenticate(credentials Credentials) (*User, error)\n    Refresh(token string) (*Token, error)\n    Revoke(token string) error\n}\n\ntype Credentials struct {\n    Username string\n    Password string\n}\n\ntype Token struct {\n    AccessToken  string\n    RefreshToken string\n    ExpiresAt    time.Time\n}\n\ntype User struct {\n    ID       string\n    Username string\n    Roles    []string\n}\n\n// Low cohesion - avoid generic packages\npackage utils  // Bad: too generic\n\nfunc HashPassword(password string) string { }\nfunc SendEmail(to, subject, body string) error { }\nfunc ParseJSON(data []byte) (interface{}, error) { }\nfunc GenerateID() string { }\n\n// Better: specific packages\npackage password\npackage email\npackage json\npackage id\n```\n\n### Package Dependencies\n```go\n// Minimize dependencies\npackage user\n\n// Good: depends only on necessary packages\nimport (\n    \"context\"\n    \"myproject/internal/database\"\n)\n\n// Bad: too many dependencies\nimport (\n    \"myproject/internal/auth\"\n    \"myproject/internal/email\"\n    \"myproject/internal/sms\"\n    \"myproject/internal/push\"\n    \"myproject/internal/analytics\"\n    // ... many more\n)\n\n// Dependency inversion\npackage service\n\n// Define interface in the consumer package\ntype UserRepository interface {\n    GetUser(ctx context.Context, id string) (*User, error)\n    SaveUser(ctx context.Context, user *User) error\n}\n\ntype UserService struct {\n    repo UserRepository  // Depend on interface\n}\n\n// Implementation in another package\npackage database\n\ntype PostgresUserRepository struct {\n    db *sql.DB\n}\n\nfunc (r *PostgresUserRepository) GetUser(ctx context.Context, id string) (*User, error) {\n    // Implementation\n}\n\n// Avoid circular dependencies\npackage a\nimport \"b\"  // a depends on b\n\npackage b\nimport \"a\"  // b depends on a - CIRCULAR!\n\n// Solution: introduce interface or third package\npackage c\ntype SharedInterface interface { }\n\npackage a\nimport \"c\"\n\npackage b\nimport \"c\"\n```\n\n## API Design\n\n### Exported vs Unexported\n```go\npackage mypackage\n\n// Exported (public) - capitalized\ntype Client struct {\n    Endpoint string\n    Timeout  time.Duration\n}\n\nfunc NewClient(endpoint string) *Client {\n    return &Client{\n        Endpoint: endpoint,\n        Timeout:  30 * time.Second,\n    }\n}\n\nfunc (c *Client) Request(ctx context.Context, data []byte) (*Response, error) {\n    return c.doRequest(ctx, data)\n}\n\n// Unexported (private) - lowercase\ntype config struct {\n    retryCount int\n    backoff    time.Duration\n}\n\nfunc (c *Client) doRequest(ctx context.Context, data []byte) (*Response, error) {\n    // Internal implementation\n}\n\n// Partially exported struct\ntype Response struct {\n    Status  int         // Exported\n    Data    []byte      // Exported\n    headers http.Header // Unexported\n}\n```\n\n### API Stability\n```go\n// Stable API design\npackage stable\n\n// Use interfaces for flexibility\ntype Store interface {\n    Get(key string) ([]byte, error)\n    Set(key string, value []byte) error\n    Delete(key string) error\n}\n\n// Options pattern for extensibility\ntype ClientOptions struct {\n    Timeout     time.Duration\n    MaxRetries  int\n    Headers     map[string]string\n    // Can add new fields without breaking\n}\n\nfunc NewClient(opts ClientOptions) *Client {\n    // Set defaults for zero values\n    if opts.Timeout == 0 {\n        opts.Timeout = 30 * time.Second\n    }\n    if opts.MaxRetries == 0 {\n        opts.MaxRetries = 3\n    }\n    \n    return &Client{opts: opts}\n}\n\n// Functional options for better API\ntype Option func(*Client)\n\nfunc WithTimeout(d time.Duration) Option {\n    return func(c *Client) {\n        c.timeout = d\n    }\n}\n\nfunc WithRetries(n int) Option {\n    return func(c *Client) {\n        c.maxRetries = n\n    }\n}\n\nfunc NewClientWithOptions(opts ...Option) *Client {\n    c := &Client{\n        timeout:    30 * time.Second,\n        maxRetries: 3,\n    }\n    \n    for _, opt := range opts {\n        opt(c)\n    }\n    \n    return c\n}\n\n// Deprecation\n// Deprecated: Use NewClientWithOptions instead.\nfunc NewClientOld(endpoint string) *Client {\n    return NewClientWithOptions(WithEndpoint(endpoint))\n}\n```\n\n### Error Design\n```go\npackage mypackage\n\n// Sentinel errors\nvar (\n    ErrNotFound      = errors.New(\"not found\")\n    ErrUnauthorized  = errors.New(\"unauthorized\")\n    ErrInvalidInput  = errors.New(\"invalid input\")\n)\n\n// Error types\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error on field %s: %s\", e.Field, e.Message)\n}\n\n// Error wrapping\nfunc GetUser(id string) (*User, error) {\n    user, err := db.Query(id)\n    if err != nil {\n        if errors.Is(err, sql.ErrNoRows) {\n            return nil, ErrNotFound\n        }\n        return nil, fmt.Errorf(\"failed to get user %s: %w\", id, err)\n    }\n    return user, nil\n}\n\n// Custom error checking\nfunc IsNotFound(err error) bool {\n    return errors.Is(err, ErrNotFound)\n}\n\nfunc IsValidation(err error) bool {\n    var validationErr ValidationError\n    return errors.As(err, &validationErr)\n}\n```\n\n## Internal Packages\n\n### Using Internal\n```go\n// internal/ prevents external imports\nmyproject/\n├── internal/\n│   ├── auth/       // Only importable within myproject\n│   ├── database/\n│   └── config/\n├── pkg/\n│   └── public/     // Importable by anyone\n└── cmd/\n\n// In myproject/internal/auth/auth.go\npackage auth\n\ntype internalAuthenticator struct {\n    // Cannot be imported outside myproject\n}\n\n// In external project - FAILS\nimport \"github.com/user/myproject/internal/auth\" // Compile error!\n\n// Internal for sub-packages\nmyproject/\n├── feature/\n│   ├── internal/   // Only importable within feature/\n│   ├── api/\n│   └── service/\n\n// Organizing internal packages\ninternal/\n├── platform/       // Platform-specific code\n│   ├── database/\n│   ├── cache/\n│   └── queue/\n├── domain/         // Business logic\n│   ├── user/\n│   ├── order/\n│   └── payment/\n└── adapter/        // External adapters\n    ├── http/\n    ├── grpc/\n    └── cli/\n```\n\n### Internal Best Practices\n```go\n// Hide implementation details\n// Public package\npackage user\n\ntype Service interface {\n    GetUser(id string) (*User, error)\n}\n\nfunc NewService(db Database) Service {\n    return &service{\n        db: db,\n        validator: internal.NewValidator(),\n    }\n}\n\n// Internal package\npackage internal\n\ntype Validator struct {\n    rules []Rule\n}\n\nfunc NewValidator() *Validator {\n    // Hidden from external packages\n}\n\n// Share code between packages\ninternal/\n├── shared/\n│   ├── logger/\n│   ├── metrics/\n│   └── errors/\n\n// Use in multiple packages\npackage service1\nimport \"myproject/internal/shared/logger\"\n\npackage service2\nimport \"myproject/internal/shared/logger\"\n```\n\n## Versioning\n\n### Semantic Versioning\n```go\n// go.mod versioning\nmodule github.com/user/myproject\n\ngo 1.21\n\nrequire (\n    github.com/some/dep v1.2.3   // Exact version\n    github.com/other/dep v2.0.0+incompatible\n    github.com/new/dep/v2 v2.1.0 // Major version in path\n)\n\n// Version tags\n// git tag v1.0.0\n// git tag v1.0.1\n// git tag v1.1.0\n// git tag v2.0.0\n\n// Major version changes (v2+)\n// Update module path\nmodule github.com/user/myproject/v2\n\n// Import with version\nimport \"github.com/user/myproject/v2/pkg/client\"\n\n// Maintaining multiple versions\nmyproject/\n├── go.mod          // module github.com/user/myproject\n└── v2/\n    └── go.mod      // module github.com/user/myproject/v2\n\n// Version constraints\nrequire (\n    github.com/some/dep v1.2.3     // Exact\n    github.com/some/dep v1.2.x     // Patch updates\n    github.com/some/dep v1.x.x     // Minor updates\n    github.com/some/dep latest     // Latest\n    github.com/some/dep master     // Branch\n)\n```\n\n### API Versioning\n```go\n// Package versioning\napi/\n├── v1/\n│   └── client.go\n└── v2/\n    └── client.go\n\n// v1/client.go\npackage v1\n\ntype Client struct {\n    Endpoint string\n}\n\nfunc (c *Client) Request(data string) (string, error) {\n    // v1 implementation\n}\n\n// v2/client.go\npackage v2\n\ntype Client struct {\n    Endpoint string\n    Timeout  time.Duration  // New field\n}\n\nfunc (c *Client) Request(ctx context.Context, data []byte) ([]byte, error) {\n    // v2 implementation with context\n}\n\n// Supporting multiple versions\npackage api\n\nimport (\n    v1 \"myproject/api/v1\"\n    v2 \"myproject/api/v2\"\n)\n\nfunc NewClientV1() *v1.Client {\n    return &v1.Client{}\n}\n\nfunc NewClientV2() *v2.Client {\n    return &v2.Client{}\n}\n```\n\n## Documentation\n\n### Package Documentation\n```go\n// Package documentation (doc.go)\n/*\nPackage user provides user management functionality for the application.\n\nThe package includes:\n  - User CRUD operations\n  - Authentication and authorization\n  - Profile management\n  - Password reset functionality\n\nBasic usage:\n\n\tservice := user.NewService(db)\n\t\n\t// Create user\n\tu, err := service.Create(ctx, user.CreateRequest{\n\t\tEmail:    \"user@example.com\",\n\t\tPassword: \"secure123\",\n\t})\n\t\n\t// Authenticate\n\ttoken, err := service.Authenticate(ctx, email, password)\n\nFor more examples, see the examples directory.\n*/\npackage user\n\n// Type documentation\n// User represents a system user.\n// Users can have multiple roles and permissions.\ntype User struct {\n    // ID is the unique identifier for the user.\n    ID string\n    \n    // Email is the user's email address.\n    // It must be unique across all users.\n    Email string\n    \n    // CreatedAt is when the user was created.\n    CreatedAt time.Time\n    \n    // Roles contains the user's assigned roles.\n    Roles []Role\n}\n\n// Method documentation\n// Create creates a new user with the given request.\n// It returns an error if the email already exists or validation fails.\n//\n// Example:\n//\n//\tuser, err := service.Create(ctx, CreateRequest{\n//\t    Email:    \"user@example.com\",\n//\t    Password: \"secure123\",\n//\t})\n//\tif err != nil {\n//\t    log.Fatal(err)\n//\t}\nfunc (s *Service) Create(ctx context.Context, req CreateRequest) (*User, error) {\n    // Implementation\n}\n\n// Deprecated documentation\n// Deprecated: Use CreateWithOptions instead.\n// This function will be removed in v2.0.0.\nfunc (s *Service) CreateOld(email, password string) (*User, error) {\n    return s.CreateWithOptions(CreateOptions{\n        Email:    email,\n        Password: password,\n    })\n}\n```\n\n### Examples\n```go\n// Example functions (show in documentation)\nfunc ExampleService_Create() {\n    service := NewService(mockDB)\n    ctx := context.Background()\n    \n    user, err := service.Create(ctx, CreateRequest{\n        Email:    \"user@example.com\",\n        Password: \"secure123\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    \n    fmt.Println(user.Email)\n    // Output: user@example.com\n}\n\n// Example with suffix\nfunc ExampleService_Create_withRoles() {\n    service := NewService(mockDB)\n    ctx := context.Background()\n    \n    user, err := service.Create(ctx, CreateRequest{\n        Email:    \"admin@example.com\",\n        Password: \"secure123\",\n        Roles:    []string{\"admin\", \"user\"},\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    \n    fmt.Println(user.Roles)\n    // Output: [admin user]\n}\n\n// Package examples\nfunc Example() {\n    // Initialize service\n    db := setupDatabase()\n    service := NewService(db)\n    \n    // Create user\n    user, _ := service.Create(context.Background(), CreateRequest{\n        Email: \"user@example.com\",\n    })\n    \n    // Authenticate\n    token, _ := service.Authenticate(context.Background(), \n        user.Email, \"password\")\n    \n    fmt.Println(token != \"\")\n    // Output: true\n}\n\n// Testable examples\nfunc ExampleService_paginate() {\n    users := []User{\n        {Email: \"user1@example.com\"},\n        {Email: \"user2@example.com\"},\n        {Email: \"user3@example.com\"},\n    }\n    \n    page := Paginate(users, 2, 1)\n    for _, u := range page {\n        fmt.Println(u.Email)\n    }\n    // Output:\n    // user1@example.com\n    // user2@example.com\n}\n```\n\n## Module Management\n\n### Go Modules\n```go\n// Initialize module\n// go mod init github.com/user/project\n\n// go.mod structure\nmodule github.com/user/project\n\ngo 1.21\n\nrequire (\n    github.com/gorilla/mux v1.8.0\n    github.com/stretchr/testify v1.8.0\n)\n\nrequire (\n    // Indirect dependencies\n    github.com/davecgh/go-spew v1.1.1 // indirect\n    github.com/pmezard/go-difflib v1.0.0 // indirect\n)\n\n// Replace directive\nreplace github.com/old/package => github.com/new/package v1.0.0\n\n// Local replace for development\nreplace github.com/user/dependency => ../dependency\n\n// Exclude versions\nexclude github.com/bad/package v1.0.0\n\n// Retract versions (go 1.16+)\nretract (\n    v1.0.0 // Critical bug\n    v1.0.1 // Security issue\n)\n\n// Module commands\n// go mod download    - Download dependencies\n// go mod tidy       - Clean up dependencies\n// go mod verify     - Verify dependencies\n// go mod graph      - Show dependency graph\n// go mod vendor     - Create vendor directory\n// go mod why pkg    - Explain why package is needed\n```\n\n### Workspace Mode\n```go\n// go.work (Go 1.18+)\ngo 1.21\n\nuse (\n    ./project1\n    ./project2\n    ../shared\n)\n\nreplace github.com/example/lib => ../lib\n\n// Commands\n// go work init project1 project2\n// go work use ../another-project\n// go work sync\n\n// Development workflow\nworkspace/\n├── go.work\n├── project1/\n│   └── go.mod\n├── project2/\n│   └── go.mod\n└── shared/\n    └── go.mod\n\n// Each project has its own module\n// Work on multiple modules simultaneously\n```\n\n## Dependencies\n\n### Managing Dependencies\n```go\n// Adding dependencies\n// go get github.com/pkg/errors\n// go get github.com/pkg/errors@v0.9.1\n// go get github.com/pkg/errors@latest\n// go get github.com/pkg/errors@master\n\n// Updating dependencies\n// go get -u                    - Update all\n// go get -u ./...             - Update all in module\n// go get -u=patch ./...       - Update patch versions\n// go get -u github.com/pkg/...  - Update specific package\n\n// Removing dependencies\n// go mod tidy                  - Remove unused\n\n// Vendoring\n// go mod vendor               - Create vendor/\n// go build -mod=vendor        - Build with vendor/\n\n// Dependency analysis\nimport \"golang.org/x/mod/modfile\"\n\nfunc analyzeDependencies() {\n    data, _ := os.ReadFile(\"go.mod\")\n    file, _ := modfile.Parse(\"go.mod\", data, nil)\n    \n    for _, req := range file.Require {\n        fmt.Printf(\"%s: %s\\n\", req.Mod.Path, req.Mod.Version)\n    }\n}\n\n// Private dependencies\n// Set GOPRIVATE environment variable\n// GOPRIVATE=github.com/company/*\n\n// Use .netrc for authentication\n// machine github.com\n// login username\n// password token\n\n// Or use SSH\n// git config --global url.\"git@github.com:\".insteadOf \"https://github.com/\"\n```\n\n### Dependency Injection\n```go\n// Constructor injection\ntype Service struct {\n    db     Database\n    cache  Cache\n    logger Logger\n}\n\nfunc NewService(db Database, cache Cache, logger Logger) *Service {\n    return &Service{\n        db:     db,\n        cache:  cache,\n        logger: logger,\n    }\n}\n\n// Interface injection\ntype Database interface {\n    Query(string) ([]Row, error)\n}\n\ntype Cache interface {\n    Get(string) (interface{}, bool)\n    Set(string, interface{})\n}\n\n// Wire for dependency injection\n//go:build wireinject\n\nimport \"github.com/google/wire\"\n\nfunc InitializeService() (*Service, error) {\n    wire.Build(\n        NewDatabase,\n        NewCache,\n        NewLogger,\n        NewService,\n    )\n    return nil, nil\n}\n\n// Provider sets\nvar BasicSet = wire.NewSet(\n    NewDatabase,\n    NewCache,\n    NewLogger,\n)\n\nvar ServiceSet = wire.NewSet(\n    BasicSet,\n    NewService,\n    NewRepository,\n)\n```\n\n## Package Patterns\n\n### Plugin Pattern\n```go\n// Plugin interface\npackage plugin\n\ntype Plugin interface {\n    Name() string\n    Initialize(config map[string]interface{}) error\n    Execute(context.Context, interface{}) (interface{}, error)\n    Shutdown() error\n}\n\n// Registry\ntype Registry struct {\n    mu      sync.RWMutex\n    plugins map[string]Plugin\n}\n\nfunc (r *Registry) Register(p Plugin) {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    r.plugins[p.Name()] = p\n}\n\nfunc (r *Registry) Get(name string) (Plugin, bool) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    p, ok := r.plugins[name]\n    return p, ok\n}\n\n// Plugin implementation\npackage myplugin\n\ntype MyPlugin struct {\n    config map[string]interface{}\n}\n\nfunc (p *MyPlugin) Name() string {\n    return \"my-plugin\"\n}\n\nfunc (p *MyPlugin) Initialize(config map[string]interface{}) error {\n    p.config = config\n    return nil\n}\n\n// Auto-registration\nfunc init() {\n    plugin.DefaultRegistry.Register(&MyPlugin{})\n}\n```\n\n### Provider Pattern\n```go\n// Provider interface\npackage provider\n\ntype StorageProvider interface {\n    Read(key string) ([]byte, error)\n    Write(key string, data []byte) error\n    Delete(key string) error\n}\n\n// Factory\ntype ProviderFactory func(config Config) (StorageProvider, error)\n\nvar providers = make(map[string]ProviderFactory)\n\nfunc Register(name string, factory ProviderFactory) {\n    providers[name] = factory\n}\n\nfunc New(name string, config Config) (StorageProvider, error) {\n    factory, ok := providers[name]\n    if !ok {\n        return nil, fmt.Errorf(\"unknown provider: %s\", name)\n    }\n    return factory(config)\n}\n\n// S3 provider\npackage s3\n\nfunc init() {\n    provider.Register(\"s3\", NewS3Provider)\n}\n\nfunc NewS3Provider(config provider.Config) (provider.StorageProvider, error) {\n    return &S3Provider{\n        bucket: config.Get(\"bucket\"),\n        region: config.Get(\"region\"),\n    }, nil\n}\n```\n\n### Repository Pattern\n```go\npackage repository\n\n// Generic repository interface\ntype Repository[T any] interface {\n    Find(ctx context.Context, id string) (*T, error)\n    FindAll(ctx context.Context) ([]*T, error)\n    Create(ctx context.Context, entity *T) error\n    Update(ctx context.Context, entity *T) error\n    Delete(ctx context.Context, id string) error\n}\n\n// Specific implementation\ntype UserRepository interface {\n    Repository[User]\n    FindByEmail(ctx context.Context, email string) (*User, error)\n    FindByRole(ctx context.Context, role string) ([]*User, error)\n}\n\n// SQL implementation\ntype sqlUserRepository struct {\n    db *sql.DB\n}\n\nfunc NewSQLUserRepository(db *sql.DB) UserRepository {\n    return &sqlUserRepository{db: db}\n}\n\nfunc (r *sqlUserRepository) Find(ctx context.Context, id string) (*User, error) {\n    query := `SELECT id, email, created_at FROM users WHERE id = $1`\n    // Implementation\n}\n\n// MongoDB implementation\ntype mongoUserRepository struct {\n    collection *mongo.Collection\n}\n\nfunc NewMongoUserRepository(db *mongo.Database) UserRepository {\n    return &mongoUserRepository{\n        collection: db.Collection(\"users\"),\n    }\n}\n```\n\n## Publishing Packages\n\n### Preparing for Publication\n```go\n// 1. Choose a good name\n// - Descriptive and unique\n// - Avoid generic names (utils, helpers, common)\n// - Check if name is available\n\n// 2. Create comprehensive documentation\n// - README.md with examples\n// - Package documentation\n// - API documentation\n// - CONTRIBUTING.md\n// - LICENSE file\n\n// 3. Add examples\nexamples/\n├── basic/\n│   └── main.go\n├── advanced/\n│   └── main.go\n└── README.md\n\n// 4. Write comprehensive tests\n// - Unit tests\n// - Integration tests\n// - Benchmarks\n// - Examples\n\n// 5. Set up CI/CD\n// .github/workflows/test.yml\nname: Test\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: actions/setup-go@v2\n      with:\n        go-version: 1.21\n    - run: go test -v ./...\n    - run: go test -race ./...\n    - run: go test -cover ./...\n```\n\n### Publishing Process\n```bash\n# 1. Tag version\ngit tag v1.0.0\ngit push origin v1.0.0\n\n# 2. The package is automatically available\n# go get github.com/username/package@v1.0.0\n\n# 3. Update pkg.go.dev\n# Visit https://pkg.go.dev/github.com/username/package\n# Click \"Request\" button\n\n# 4. Add badges to README\n[![Go Reference](https://pkg.go.dev/badge/github.com/username/package.svg)](https://pkg.go.dev/github.com/username/package)\n[![Go Report Card](https://goreportcard.com/badge/github.com/username/package)](https://goreportcard.com/report/github.com/username/package)\n[![Coverage Status](https://coveralls.io/repos/github/username/package/badge.svg)](https://coveralls.io/github/username/package)\n\n# 5. Create release on GitHub\n# - Add release notes\n# - Attach binaries if applicable\n```\n\n### Package Maintenance\n```go\n// Deprecation process\n// 1. Mark as deprecated in documentation\n// Deprecated: Use NewFunction instead.\n// This will be removed in v2.0.0.\nfunc OldFunction() {}\n\n// 2. Log deprecation warnings\nfunc OldFunction() {\n    log.Println(\"Warning: OldFunction is deprecated. Use NewFunction instead.\")\n    // Existing implementation\n}\n\n// 3. Provide migration guide\n/*\nMigration Guide from v1 to v2:\n\n1. Replace OldFunction() with NewFunction()\n2. Update Client struct initialization:\n   Old: client := &Client{Endpoint: \"url\"}\n   New: client := NewClient(WithEndpoint(\"url\"))\n3. Change import path:\n   Old: import \"github.com/user/package\"\n   New: import \"github.com/user/package/v2\"\n*/\n\n// Version compatibility\n// Support multiple versions\npackage compat\n\nimport (\n    v1 \"mypackage/v1\"\n    v2 \"mypackage/v2\"\n)\n\nfunc MigrateV1ToV2(old *v1.Config) *v2.Config {\n    return &v2.Config{\n        // Map old fields to new\n    }\n}\n```\n\n## Best Practices\n\n### Package Design Principles\n```go\n// 1. Single Responsibility\n// Each package should have one clear purpose\n\n// 2. Minimal Public API\n// Export only what's necessary\npackage mypackage\n\ntype Client struct{} // Exported\n\ntype implementation struct{} // Unexported\n\n// 3. Accept Interfaces, Return Structs\nfunc Process(r io.Reader) *Result {\n    // Accept interface for flexibility\n    // Return concrete type for clarity\n}\n\n// 4. Avoid Init Functions\n// Bad: Side effects on import\nfunc init() {\n    database.Connect() // Side effect!\n}\n\n// Good: Explicit initialization\nfunc Initialize() error {\n    return database.Connect()\n}\n\n// 5. No Circular Dependencies\n// Use interfaces to break cycles\n\n// 6. Consistent Naming\n// Package name should match directory name\n// Avoid stuttering: user.User not user.UserUser\n\n// 7. Semantic Versioning\n// Follow semver strictly\n// Major.Minor.Patch\n\n// 8. Comprehensive Testing\n// Aim for >80% coverage\n// Include edge cases\n\n// 9. Clear Documentation\n// Document all exports\n// Provide examples\n\n// 10. Minimal Dependencies\n// Avoid unnecessary dependencies\n// Vendor or ensure stability\n```\n\n### Common Pitfalls\n```go\n// 1. Overusing init()\n// Avoid side effects on import\n\n// 2. God packages\n// Don't create packages that do everything\n\n// 3. Premature abstraction\n// Start simple, refactor when needed\n\n// 4. Ignoring internal/\n// Use internal/ for non-public code\n\n// 5. Poor error messages\n// Provide context in errors\n\n// 6. Breaking changes in minor versions\n// Use major version for breaking changes\n\n// 7. No examples\n// Always provide usage examples\n\n// 8. Inconsistent API\n// Maintain consistency across package\n\n// 9. Global state\n// Avoid package-level variables\n\n// 10. Missing context support\n// Accept context.Context in long operations\n```\n\n## Best Practices Summary\n\n1. **Design cohesive packages** - Single, clear purpose\n2. **Minimize public API** - Export only what's necessary  \n3. **Use internal packages** - Hide implementation details\n4. **Follow semantic versioning** - Major.Minor.Patch\n5. **Document thoroughly** - Package, types, functions\n6. **Provide examples** - Show common usage patterns\n7. **Accept interfaces** - Return concrete types\n8. **Avoid circular dependencies** - Use interfaces to break cycles\n9. **Test comprehensively** - Unit, integration, benchmarks\n10. **Maintain backwards compatibility** - Use versioning for breaking changes","structuredPatch":[]}}
{"parentUuid":"8c6dc011-211f-426b-bda4-09fdeac10443","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_012XVzuPwdgdfUbQer2eqG1z","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Let me continue with the remaining files:\n\n## 7. Go Errors"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7683,"cache_read_input_tokens":90912,"output_tokens":9930,"service_tier":"standard"}},"requestId":"req_011CS5KAQdgPLx2zgNzPqR33","type":"assistant","uuid":"0d250406-d8f8-439b-bdd1-d96fd9ab4816","timestamp":"2025-08-13T07:28:02.883Z"}
{"parentUuid":"0d250406-d8f8-439b-bdd1-d96fd9ab4816","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_012XVzuPwdgdfUbQer2eqG1z","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01AiNo8FLbtvV4bDL3vzoPcv","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-errors.md","content":"# Go Error Handling - Excellence in Error Management\n\n## Table of Contents\n1. [Error Basics](#error-basics)\n2. [Error Types](#error-types)\n3. [Error Wrapping](#error-wrapping)\n4. [Sentinel Errors](#sentinel-errors)\n5. [Custom Errors](#custom-errors)\n6. [Error Design Patterns](#error-design-patterns)\n7. [Panic and Recover](#panic-and-recover)\n8. [Error Handling Strategies](#error-handling-strategies)\n9. [Testing Errors](#testing-errors)\n10. [Best Practices](#best-practices)\n\n## Error Basics\n\n### The Error Interface\n```go\n// Built-in error interface\ntype error interface {\n    Error() string\n}\n\n// Basic error creation\nimport \"errors\"\n\nerr := errors.New(\"something went wrong\")\n\n// Formatted errors\nerr := fmt.Errorf(\"failed to process item %d: %s\", id, reason)\n\n// Checking errors\nresult, err := doSomething()\nif err != nil {\n    // Handle error\n    return err\n}\n\n// Multiple return values with error\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// Named returns with error\nfunc readFile(path string) (data []byte, err error) {\n    data, err = os.ReadFile(path)\n    if err != nil {\n        return nil, err // Explicit return preferred\n    }\n    return data, nil\n}\n\n// Defer with error handling\nfunc writeFile(path string, data []byte) (err error) {\n    f, err := os.Create(path)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if cerr := f.Close(); cerr != nil && err == nil {\n            err = cerr // Capture close error if no other error\n        }\n    }()\n    \n    _, err = f.Write(data)\n    return err\n}\n```\n\n### Error Checking Patterns\n```go\n// Immediate return pattern\nif err := doSomething(); err != nil {\n    return fmt.Errorf(\"doSomething failed: %w\", err)\n}\n\n// Guard clause pattern\nfunc process(input string) error {\n    if input == \"\" {\n        return errors.New(\"input cannot be empty\")\n    }\n    \n    if len(input) > 100 {\n        return errors.New(\"input too long\")\n    }\n    \n    // Main logic here\n    return nil\n}\n\n// Error accumulation\nfunc processMultiple(items []Item) error {\n    var errs []error\n    \n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            errs = append(errs, fmt.Errorf(\"item %v: %w\", item.ID, err))\n        }\n    }\n    \n    if len(errs) > 0 {\n        return fmt.Errorf(\"multiple errors: %v\", errs)\n    }\n    \n    return nil\n}\n\n// First error wins\nfunc firstErrorWins(tasks []func() error) error {\n    for _, task := range tasks {\n        if err := task(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\n// All errors matter\nimport \"golang.org/x/sync/errgroup\"\n\nfunc allErrorsMatter(ctx context.Context) error {\n    g, ctx := errgroup.WithContext(ctx)\n    \n    g.Go(func() error {\n        return task1(ctx)\n    })\n    \n    g.Go(func() error {\n        return task2(ctx)\n    })\n    \n    g.Go(func() error {\n        return task3(ctx)\n    })\n    \n    return g.Wait() // Returns first error\n}\n```\n\n## Error Types\n\n### Implementing Error Types\n```go\n// Simple error type\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Msg   string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for %s with value %v: %s\", \n        e.Field, e.Value, e.Msg)\n}\n\n// Error type with code\ntype APIError struct {\n    Code    int\n    Message string\n    Details map[string]interface{}\n}\n\nfunc (e APIError) Error() string {\n    return fmt.Sprintf(\"API error %d: %s\", e.Code, e.Message)\n}\n\n// Temporary error interface\ntype temporary interface {\n    Temporary() bool\n}\n\ntype NetworkError struct {\n    Op         string\n    Err        error\n    Temporary  bool\n    Timeout    bool\n}\n\nfunc (e NetworkError) Error() string {\n    return fmt.Sprintf(\"network error during %s: %v\", e.Op, e.Err)\n}\n\nfunc (e NetworkError) Unwrap() error {\n    return e.Err\n}\n\nfunc (e NetworkError) IsTemporary() bool {\n    return e.Temporary\n}\n\nfunc (e NetworkError) IsTimeout() bool {\n    return e.Timeout\n}\n\n// Rich error type\ntype RichError struct {\n    Op         string                 // Operation\n    Kind       ErrorKind              // Category\n    Err        error                  // Wrapped error\n    Severity   Severity               // Error severity\n    Context    map[string]interface{} // Additional context\n    StackTrace string                 // Stack trace\n    Timestamp  time.Time              // When it occurred\n}\n\ntype ErrorKind int\n\nconst (\n    KindOther ErrorKind = iota\n    KindInvalid\n    KindPermission\n    KindIO\n    KindExist\n    KindNotExist\n    KindNetwork\n)\n\ntype Severity int\n\nconst (\n    SeverityLow Severity = iota\n    SeverityMedium\n    SeverityHigh\n    SeverityCritical\n)\n\nfunc (e *RichError) Error() string {\n    var b strings.Builder\n    b.WriteString(e.Op)\n    b.WriteString(\": \")\n    b.WriteString(e.Kind.String())\n    if e.Err != nil {\n        b.WriteString(\": \")\n        b.WriteString(e.Err.Error())\n    }\n    return b.String()\n}\n\nfunc (e *RichError) Unwrap() error {\n    return e.Err\n}\n```\n\n### Structured Errors\n```go\n// Multi-error type\ntype MultiError struct {\n    Errors []error\n}\n\nfunc (m *MultiError) Error() string {\n    var msgs []string\n    for _, err := range m.Errors {\n        msgs = append(msgs, err.Error())\n    }\n    return strings.Join(msgs, \"; \")\n}\n\nfunc (m *MultiError) Add(err error) {\n    if err != nil {\n        m.Errors = append(m.Errors, err)\n    }\n}\n\nfunc (m *MultiError) HasErrors() bool {\n    return len(m.Errors) > 0\n}\n\n// Causal error chain\ntype CausalError struct {\n    Op    string\n    Cause error\n}\n\nfunc (e *CausalError) Error() string {\n    if e.Cause != nil {\n        return fmt.Sprintf(\"%s: %v\", e.Op, e.Cause)\n    }\n    return e.Op\n}\n\nfunc (e *CausalError) Unwrap() error {\n    return e.Cause\n}\n\n// HTTP error response\ntype HTTPError struct {\n    Status  int         `json:\"status\"`\n    Code    string      `json:\"code\"`\n    Message string      `json:\"message\"`\n    Details interface{} `json:\"details,omitempty\"`\n    TraceID string      `json:\"trace_id,omitempty\"`\n}\n\nfunc (e HTTPError) Error() string {\n    return fmt.Sprintf(\"HTTP %d: %s\", e.Status, e.Message)\n}\n\nfunc (e HTTPError) StatusCode() int {\n    return e.Status\n}\n```\n\n## Error Wrapping\n\n### Wrapping with fmt.Errorf\n```go\n// Basic wrapping (Go 1.13+)\nfunc readConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read config file %s: %w\", path, err)\n    }\n    \n    var config Config\n    if err := json.Unmarshal(data, &config); err != nil {\n        return nil, fmt.Errorf(\"failed to parse config: %w\", err)\n    }\n    \n    return &config, nil\n}\n\n// Multiple wrapping layers\nfunc highlevel() error {\n    if err := midlevel(); err != nil {\n        return fmt.Errorf(\"highlevel failed: %w\", err)\n    }\n    return nil\n}\n\nfunc midlevel() error {\n    if err := lowlevel(); err != nil {\n        return fmt.Errorf(\"midlevel failed: %w\", err)\n    }\n    return nil\n}\n\nfunc lowlevel() error {\n    return errors.New(\"disk full\")\n}\n\n// Result: \"highlevel failed: midlevel failed: disk full\"\n\n// Wrapping with additional context\ntype contextError struct {\n    op      string\n    path    string\n    user    string\n    wrapped error\n}\n\nfunc (e *contextError) Error() string {\n    return fmt.Sprintf(\"op=%s path=%s user=%s: %v\", \n        e.op, e.path, e.user, e.wrapped)\n}\n\nfunc (e *contextError) Unwrap() error {\n    return e.wrapped\n}\n\nfunc wrapWithContext(op, path, user string, err error) error {\n    if err == nil {\n        return nil\n    }\n    return &contextError{\n        op:      op,\n        path:    path,\n        user:    user,\n        wrapped: err,\n    }\n}\n```\n\n### Unwrapping Errors\n```go\n// Using errors.Is (Go 1.13+)\nvar ErrPermission = errors.New(\"permission denied\")\n\nfunc checkPermission() error {\n    // Some checks...\n    return fmt.Errorf(\"user %s: %w\", username, ErrPermission)\n}\n\nfunc main() {\n    err := checkPermission()\n    if errors.Is(err, ErrPermission) {\n        // Handle permission error\n    }\n}\n\n// Using errors.As (Go 1.13+)\ntype PathError struct {\n    Op   string\n    Path string\n    Err  error\n}\n\nfunc (e *PathError) Error() string {\n    return fmt.Sprintf(\"%s %s: %v\", e.Op, e.Path, e.Err)\n}\n\nfunc handleError(err error) {\n    var pathErr *PathError\n    if errors.As(err, &pathErr) {\n        fmt.Printf(\"Path error: %s\\n\", pathErr.Path)\n    }\n}\n\n// Custom Is implementation\ntype MyError struct {\n    Code string\n    Msg  string\n}\n\nfunc (e MyError) Error() string {\n    return fmt.Sprintf(\"%s: %s\", e.Code, e.Msg)\n}\n\nfunc (e MyError) Is(target error) bool {\n    t, ok := target.(MyError)\n    if !ok {\n        return false\n    }\n    return e.Code == t.Code\n}\n\n// Custom As implementation\nfunc (e *MyError) As(target interface{}) bool {\n    switch v := target.(type) {\n    case **MyError:\n        *v = e\n        return true\n    case *MyError:\n        *v = *e\n        return true\n    default:\n        return false\n    }\n}\n```\n\n## Sentinel Errors\n\n### Defining Sentinel Errors\n```go\n// Package-level sentinel errors\npackage mypackage\n\nvar (\n    // ErrNotFound is returned when a requested resource is not found.\n    ErrNotFound = errors.New(\"not found\")\n    \n    // ErrAlreadyExists is returned when attempting to create a resource that already exists.\n    ErrAlreadyExists = errors.New(\"already exists\")\n    \n    // ErrInvalidInput is returned when input validation fails.\n    ErrInvalidInput = errors.New(\"invalid input\")\n    \n    // ErrUnauthorized is returned when authentication fails.\n    ErrUnauthorized = errors.New(\"unauthorized\")\n    \n    // ErrForbidden is returned when the user lacks permission.\n    ErrForbidden = errors.New(\"forbidden\")\n    \n    // ErrTimeout is returned when an operation times out.\n    ErrTimeout = errors.New(\"operation timeout\")\n    \n    // ErrCanceled is returned when an operation is canceled.\n    ErrCanceled = errors.New(\"operation canceled\")\n)\n\n// Using sentinel errors\nfunc GetUser(id string) (*User, error) {\n    user, err := db.Query(id)\n    if err != nil {\n        if errors.Is(err, sql.ErrNoRows) {\n            return nil, ErrNotFound\n        }\n        return nil, fmt.Errorf(\"database query failed: %w\", err)\n    }\n    return user, nil\n}\n\n// Checking sentinel errors\nuser, err := GetUser(id)\nif err != nil {\n    if errors.Is(err, ErrNotFound) {\n        // Handle not found case\n        return http.StatusNotFound\n    }\n    // Handle other errors\n    return http.StatusInternalServerError\n}\n\n// Sentinel errors with types\ntype NotFoundError struct {\n    Resource string\n    ID       string\n}\n\nfunc (e NotFoundError) Error() string {\n    return fmt.Sprintf(\"%s with ID %s not found\", e.Resource, e.ID)\n}\n\nvar errNotFoundSentinel = NotFoundError{}\n\nfunc (e NotFoundError) Is(target error) bool {\n    _, ok := target.(NotFoundError)\n    return ok\n}\n```\n\n### Sentinel Error Best Practices\n```go\n// DO: Export sentinel errors that callers need to check\nvar ErrInvalidFormat = errors.New(\"invalid format\")\n\n// DON'T: Export errors that are implementation details\nvar errInternalState = errors.New(\"internal state corrupted\") // unexported\n\n// DO: Use descriptive names\nvar ErrUserNotFound = errors.New(\"user not found\")\nvar ErrInsufficientFunds = errors.New(\"insufficient funds\")\n\n// DON'T: Use generic names\nvar ErrBad = errors.New(\"bad\")\nvar ErrFail = errors.New(\"fail\")\n\n// DO: Document sentinel errors\n// ErrRateLimitExceeded is returned when the rate limit is exceeded.\n// Callers should implement exponential backoff when receiving this error.\nvar ErrRateLimitExceeded = errors.New(\"rate limit exceeded\")\n\n// DO: Group related errors\nvar (\n    // Database errors\n    ErrDBConnection = errors.New(\"database connection failed\")\n    ErrDBTimeout    = errors.New(\"database timeout\")\n    ErrDBLocked     = errors.New(\"database locked\")\n    \n    // Validation errors\n    ErrValidationFailed = errors.New(\"validation failed\")\n    ErrMissingField     = errors.New(\"required field missing\")\n    ErrInvalidFormat    = errors.New(\"invalid format\")\n)\n```\n\n## Custom Errors\n\n### Domain-Specific Errors\n```go\n// Business logic errors\ntype InsufficientFundsError struct {\n    Account   string\n    Available decimal.Decimal\n    Required  decimal.Decimal\n}\n\nfunc (e InsufficientFundsError) Error() string {\n    return fmt.Sprintf(\"insufficient funds in account %s: available %s, required %s\",\n        e.Account, e.Available, e.Required)\n}\n\n// Validation errors\ntype ValidationErrors struct {\n    Errors map[string][]string\n}\n\nfunc (v ValidationErrors) Error() string {\n    var msgs []string\n    for field, errors := range v.Errors {\n        msgs = append(msgs, fmt.Sprintf(\"%s: %s\", field, strings.Join(errors, \", \")))\n    }\n    return \"validation failed: \" + strings.Join(msgs, \"; \")\n}\n\nfunc (v *ValidationErrors) Add(field, message string) {\n    if v.Errors == nil {\n        v.Errors = make(map[string][]string)\n    }\n    v.Errors[field] = append(v.Errors[field], message)\n}\n\nfunc (v ValidationErrors) HasErrors() bool {\n    return len(v.Errors) > 0\n}\n\n// State machine errors\ntype StateTransitionError struct {\n    From  State\n    To    State\n    Event Event\n}\n\nfunc (e StateTransitionError) Error() string {\n    return fmt.Sprintf(\"invalid state transition from %s to %s on event %s\",\n        e.From, e.To, e.Event)\n}\n\n// Configuration errors\ntype ConfigError struct {\n    File    string\n    Section string\n    Key     string\n    Value   interface{}\n    Reason  string\n}\n\nfunc (e ConfigError) Error() string {\n    return fmt.Sprintf(\"config error in %s [%s] %s=%v: %s\",\n        e.File, e.Section, e.Key, e.Value, e.Reason)\n}\n```\n\n### Error Builders\n```go\n// Fluent error builder\ntype ErrorBuilder struct {\n    err      error\n    code     string\n    message  string\n    details  map[string]interface{}\n    wrapped  error\n}\n\nfunc NewError() *ErrorBuilder {\n    return &ErrorBuilder{\n        details: make(map[string]interface{}),\n    }\n}\n\nfunc (b *ErrorBuilder) WithCode(code string) *ErrorBuilder {\n    b.code = code\n    return b\n}\n\nfunc (b *ErrorBuilder) WithMessage(msg string) *ErrorBuilder {\n    b.message = msg\n    return b\n}\n\nfunc (b *ErrorBuilder) WithDetail(key string, value interface{}) *ErrorBuilder {\n    b.details[key] = value\n    return b\n}\n\nfunc (b *ErrorBuilder) Wrap(err error) *ErrorBuilder {\n    b.wrapped = err\n    return b\n}\n\nfunc (b *ErrorBuilder) Build() error {\n    return &builtError{\n        code:    b.code,\n        message: b.message,\n        details: b.details,\n        wrapped: b.wrapped,\n    }\n}\n\ntype builtError struct {\n    code    string\n    message string\n    details map[string]interface{}\n    wrapped error\n}\n\nfunc (e builtError) Error() string {\n    if e.wrapped != nil {\n        return fmt.Sprintf(\"[%s] %s: %v\", e.code, e.message, e.wrapped)\n    }\n    return fmt.Sprintf(\"[%s] %s\", e.code, e.message)\n}\n\nfunc (e builtError) Unwrap() error {\n    return e.wrapped\n}\n\n// Usage\nerr := NewError().\n    WithCode(\"VALIDATION_ERROR\").\n    WithMessage(\"Invalid user input\").\n    WithDetail(\"field\", \"email\").\n    WithDetail(\"value\", userEmail).\n    Wrap(originalErr).\n    Build()\n```\n\n## Error Design Patterns\n\n### Error Handler Pattern\n```go\n// Centralized error handler\ntype ErrorHandler interface {\n    Handle(error) error\n}\n\ntype errorHandler struct {\n    logger    Logger\n    metrics   Metrics\n    notifier  Notifier\n}\n\nfunc (h *errorHandler) Handle(err error) error {\n    // Log error\n    h.logger.Error(\"error occurred\", \"error\", err)\n    \n    // Record metrics\n    h.metrics.IncrementErrorCount(errorType(err))\n    \n    // Notify if critical\n    if isCritical(err) {\n        h.notifier.NotifyCritical(err)\n    }\n    \n    // Transform for client\n    return transformError(err)\n}\n\nfunc errorType(err error) string {\n    switch {\n    case errors.Is(err, ErrNotFound):\n        return \"not_found\"\n    case errors.Is(err, ErrUnauthorized):\n        return \"unauthorized\"\n    default:\n        return \"internal\"\n    }\n}\n\nfunc isCritical(err error) bool {\n    var criticalErr CriticalError\n    return errors.As(err, &criticalErr)\n}\n\nfunc transformError(err error) error {\n    // Hide internal details from client\n    switch {\n    case errors.Is(err, ErrNotFound):\n        return NewHTTPError(404, \"Resource not found\")\n    case errors.Is(err, ErrUnauthorized):\n        return NewHTTPError(401, \"Unauthorized\")\n    default:\n        return NewHTTPError(500, \"Internal server error\")\n    }\n}\n```\n\n### Result Type Pattern\n```go\n// Result type for explicit error handling\ntype Result[T any] struct {\n    value T\n    err   error\n}\n\nfunc Ok[T any](value T) Result[T] {\n    return Result[T]{value: value}\n}\n\nfunc Err[T any](err error) Result[T] {\n    return Result[T]{err: err}\n}\n\nfunc (r Result[T]) IsOk() bool {\n    return r.err == nil\n}\n\nfunc (r Result[T]) IsErr() bool {\n    return r.err != nil\n}\n\nfunc (r Result[T]) Unwrap() (T, error) {\n    return r.value, r.err\n}\n\nfunc (r Result[T]) UnwrapOr(defaultValue T) T {\n    if r.err != nil {\n        return defaultValue\n    }\n    return r.value\n}\n\nfunc (r Result[T]) Map(fn func(T) T) Result[T] {\n    if r.err != nil {\n        return r\n    }\n    return Ok(fn(r.value))\n}\n\n// Usage\nfunc divide(a, b float64) Result[float64] {\n    if b == 0 {\n        return Err[float64](errors.New(\"division by zero\"))\n    }\n    return Ok(a / b)\n}\n\nresult := divide(10, 2)\nif result.IsOk() {\n    value, _ := result.Unwrap()\n    fmt.Println(value)\n}\n```\n\n### Error Recovery Pattern\n```go\n// Retry with exponential backoff\nfunc retryWithBackoff(fn func() error, maxRetries int) error {\n    var err error\n    backoff := 100 * time.Millisecond\n    \n    for i := 0; i < maxRetries; i++ {\n        err = fn()\n        if err == nil {\n            return nil\n        }\n        \n        // Check if error is retryable\n        if !isRetryable(err) {\n            return err\n        }\n        \n        if i < maxRetries-1 {\n            time.Sleep(backoff)\n            backoff *= 2\n            if backoff > 10*time.Second {\n                backoff = 10 * time.Second\n            }\n        }\n    }\n    \n    return fmt.Errorf(\"failed after %d retries: %w\", maxRetries, err)\n}\n\nfunc isRetryable(err error) bool {\n    // Check for temporary errors\n    var tempErr interface{ Temporary() bool }\n    if errors.As(err, &tempErr) && tempErr.Temporary() {\n        return true\n    }\n    \n    // Check for specific retryable errors\n    return errors.Is(err, ErrTimeout) || \n           errors.Is(err, ErrRateLimited) ||\n           errors.Is(err, ErrServiceUnavailable)\n}\n\n// Circuit breaker pattern\ntype CircuitBreaker struct {\n    mu           sync.RWMutex\n    failureCount int\n    lastFailTime time.Time\n    state        string // \"closed\", \"open\", \"half-open\"\n    threshold    int\n    timeout      time.Duration\n}\n\nfunc (cb *CircuitBreaker) Call(fn func() error) error {\n    cb.mu.RLock()\n    state := cb.state\n    cb.mu.RUnlock()\n    \n    if state == \"open\" {\n        cb.mu.RLock()\n        if time.Since(cb.lastFailTime) > cb.timeout {\n            cb.mu.RUnlock()\n            cb.mu.Lock()\n            cb.state = \"half-open\"\n            cb.mu.Unlock()\n        } else {\n            cb.mu.RUnlock()\n            return ErrCircuitBreakerOpen\n        }\n    }\n    \n    err := fn()\n    \n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n    \n    if err != nil {\n        cb.failureCount++\n        cb.lastFailTime = time.Now()\n        \n        if cb.failureCount >= cb.threshold {\n            cb.state = \"open\"\n        }\n        return err\n    }\n    \n    if cb.state == \"half-open\" {\n        cb.state = \"closed\"\n    }\n    cb.failureCount = 0\n    return nil\n}\n```\n\n## Panic and Recover\n\n### When to Panic\n```go\n// Panic for unrecoverable errors during initialization\nfunc MustConnect(dsn string) *sql.DB {\n    db, err := sql.Open(\"postgres\", dsn)\n    if err != nil {\n        panic(fmt.Sprintf(\"failed to connect to database: %v\", err))\n    }\n    return db\n}\n\n// Panic for programming errors\nfunc (s *Stack) Pop() interface{} {\n    if len(s.items) == 0 {\n        panic(\"pop from empty stack\") // Programming error\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item\n}\n\n// Panic for impossible conditions\nfunc processValue(v interface{}) {\n    switch v := v.(type) {\n    case int:\n        // handle int\n    case string:\n        // handle string\n    default:\n        panic(fmt.Sprintf(\"unexpected type %T\", v))\n    }\n}\n\n// DON'T panic for normal errors\nfunc badExample(input string) {\n    if input == \"\" {\n        panic(\"input is empty\") // Bad! Use error return instead\n    }\n}\n\nfunc goodExample(input string) error {\n    if input == \"\" {\n        return errors.New(\"input is empty\")\n    }\n    return nil\n}\n```\n\n### Recover Pattern\n```go\n// Basic recover\nfunc safeCall(fn func()) (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    \n    fn()\n    return nil\n}\n\n// Recover with stack trace\nimport \"runtime/debug\"\n\nfunc recoverWithStack() {\n    if r := recover(); r != nil {\n        log.Printf(\"Panic: %v\\nStack: %s\", r, debug.Stack())\n    }\n}\n\n// HTTP middleware with recover\nfunc RecoverMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"Panic in handler: %v\\nStack: %s\", err, debug.Stack())\n                http.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n            }\n        }()\n        \n        next.ServeHTTP(w, r)\n    })\n}\n\n// Goroutine with recover\nfunc SafeGo(fn func()) {\n    go func() {\n        defer func() {\n            if r := recover(); r != nil {\n                log.Printf(\"Panic in goroutine: %v\\nStack: %s\", r, debug.Stack())\n            }\n        }()\n        \n        fn()\n    }()\n}\n\n// Convert panic to error\nfunc callExternalLibrary() (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"external library panicked: %v\", r)\n        }\n    }()\n    \n    // Call potentially panicking external code\n    externalLibrary.DangerousOperation()\n    \n    return nil\n}\n```\n\n## Error Handling Strategies\n\n### Fail Fast\n```go\n// Fail fast on critical errors\nfunc Initialize() error {\n    // Check prerequisites first\n    if err := checkDependencies(); err != nil {\n        return fmt.Errorf(\"dependency check failed: %w\", err)\n    }\n    \n    if err := validateConfig(); err != nil {\n        return fmt.Errorf(\"config validation failed: %w\", err)\n    }\n    \n    // Only proceed if everything is valid\n    return startServices()\n}\n\n// Validate early\nfunc ProcessRequest(req Request) error {\n    // Validate input immediately\n    if err := req.Validate(); err != nil {\n        return fmt.Errorf(\"invalid request: %w\", err)\n    }\n    \n    // Check permissions early\n    if err := checkPermissions(req.UserID); err != nil {\n        return fmt.Errorf(\"permission denied: %w\", err)\n    }\n    \n    // Process only after validation\n    return process(req)\n}\n```\n\n### Graceful Degradation\n```go\n// Fallback on error\nfunc GetUserPreferences(userID string) (*Preferences, error) {\n    // Try to get from cache\n    prefs, err := cache.Get(userID)\n    if err == nil {\n        return prefs, nil\n    }\n    \n    // Fallback to database\n    prefs, err = db.GetPreferences(userID)\n    if err == nil {\n        // Update cache for next time\n        go cache.Set(userID, prefs)\n        return prefs, nil\n    }\n    \n    // Return defaults if all fails\n    log.Printf(\"Failed to get preferences for %s: %v\", userID, err)\n    return DefaultPreferences(), nil\n}\n\n// Partial success\nfunc ProcessBatch(items []Item) error {\n    var successCount int\n    var errors []error\n    \n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            errors = append(errors, fmt.Errorf(\"item %v: %w\", item.ID, err))\n            continue\n        }\n        successCount++\n    }\n    \n    if len(errors) > 0 {\n        log.Printf(\"Processed %d/%d items successfully\", successCount, len(items))\n        return &PartialError{\n            Successful: successCount,\n            Failed:     len(errors),\n            Errors:     errors,\n        }\n    }\n    \n    return nil\n}\n```\n\n### Error Aggregation\n```go\n// Collect all errors\ntype ErrorCollector struct {\n    mu     sync.Mutex\n    errors []error\n}\n\nfunc (c *ErrorCollector) Add(err error) {\n    if err == nil {\n        return\n    }\n    \n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.errors = append(c.errors, err)\n}\n\nfunc (c *ErrorCollector) Error() error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    switch len(c.errors) {\n    case 0:\n        return nil\n    case 1:\n        return c.errors[0]\n    default:\n        return &MultiError{Errors: c.errors}\n    }\n}\n\n// Usage with goroutines\nfunc ProcessConcurrently(items []Item) error {\n    var wg sync.WaitGroup\n    collector := &ErrorCollector{}\n    \n    for _, item := range items {\n        wg.Add(1)\n        go func(i Item) {\n            defer wg.Done()\n            if err := processItem(i); err != nil {\n                collector.Add(fmt.Errorf(\"item %v: %w\", i.ID, err))\n            }\n        }(item)\n    }\n    \n    wg.Wait()\n    return collector.Error()\n}\n```\n\n## Testing Errors\n\n### Testing Error Cases\n```go\nfunc TestDivide(t *testing.T) {\n    tests := []struct {\n        name    string\n        a, b    float64\n        want    float64\n        wantErr bool\n        errMsg  string\n    }{\n        {\n            name: \"normal division\",\n            a:    10,\n            b:    2,\n            want: 5,\n        },\n        {\n            name:    \"divide by zero\",\n            a:       10,\n            b:       0,\n            wantErr: true,\n            errMsg:  \"division by zero\",\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := Divide(tt.a, tt.b)\n            \n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Divide() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            \n            if tt.wantErr {\n                if !strings.Contains(err.Error(), tt.errMsg) {\n                    t.Errorf(\"Divide() error = %v, want error containing %v\", \n                        err, tt.errMsg)\n                }\n                return\n            }\n            \n            if got != tt.want {\n                t.Errorf(\"Divide() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n\n// Testing sentinel errors\nfunc TestGetUser_NotFound(t *testing.T) {\n    repo := NewMockRepository()\n    repo.ReturnError = sql.ErrNoRows\n    \n    service := NewService(repo)\n    _, err := service.GetUser(\"123\")\n    \n    if !errors.Is(err, ErrNotFound) {\n        t.Errorf(\"expected ErrNotFound, got %v\", err)\n    }\n}\n\n// Testing error types\nfunc TestValidationError(t *testing.T) {\n    err := ValidateUser(User{})\n    \n    var validationErr ValidationError\n    if !errors.As(err, &validationErr) {\n        t.Fatalf(\"expected ValidationError, got %T\", err)\n    }\n    \n    if validationErr.Field != \"email\" {\n        t.Errorf(\"expected field 'email', got %s\", validationErr.Field)\n    }\n}\n\n// Testing error wrapping\nfunc TestErrorWrapping(t *testing.T) {\n    rootErr := errors.New(\"root cause\")\n    wrappedErr := fmt.Errorf(\"wrapped: %w\", rootErr)\n    \n    if !errors.Is(wrappedErr, rootErr) {\n        t.Error(\"expected wrapped error to contain root cause\")\n    }\n}\n```\n\n### Mocking Errors\n```go\n// Error injection for testing\ntype ErrorInjector struct {\n    errors map[string]error\n    calls  map[string]int\n}\n\nfunc (e *ErrorInjector) ShouldFail(operation string) error {\n    e.calls[operation]++\n    \n    if err, ok := e.errors[operation]; ok {\n        // Return error on specific call count\n        if callErr, ok := err.(*CallCountError); ok {\n            if e.calls[operation] == callErr.OnCall {\n                return callErr.Err\n            }\n            return nil\n        }\n        return err\n    }\n    \n    return nil\n}\n\ntype CallCountError struct {\n    OnCall int\n    Err    error\n}\n\n// Usage in tests\nfunc TestRetry(t *testing.T) {\n    injector := &ErrorInjector{\n        errors: map[string]error{\n            \"connect\": &CallCountError{\n                OnCall: 1, // Fail on first call\n                Err:    errors.New(\"connection failed\"),\n            },\n        },\n        calls: make(map[string]int),\n    }\n    \n    service := NewService(injector)\n    err := service.ConnectWithRetry()\n    \n    if err != nil {\n        t.Errorf(\"expected success after retry, got %v\", err)\n    }\n    \n    if injector.calls[\"connect\"] != 2 {\n        t.Errorf(\"expected 2 connection attempts, got %d\", \n            injector.calls[\"connect\"])\n    }\n}\n```\n\n## Best Practices\n\n### Error Design Guidelines\n```go\n// 1. Return error as last value\nfunc Good() (Result, error)\nfunc Bad() (error, Result)  // Don't do this\n\n// 2. Check errors immediately\nresult, err := doSomething()\nif err != nil {\n    return err\n}\n\n// 3. Add context when wrapping\nif err != nil {\n    return fmt.Errorf(\"failed to process user %s: %w\", userID, err)\n}\n\n// 4. Use sentinel errors for known conditions\nvar ErrNotFound = errors.New(\"not found\")\n\n// 5. Create specific error types for rich information\ntype ValidationError struct {\n    Field string\n    Value interface{}\n}\n\n// 6. Don't ignore errors\n_ = os.Remove(tempFile)  // Bad\nif err := os.Remove(tempFile); err != nil {\n    log.Printf(\"failed to remove temp file: %v\", err)\n}\n\n// 7. Handle errors once\n// Don't log AND return - let caller decide\n\n// 8. Use errors.Is and errors.As for checking\nif errors.Is(err, ErrNotFound) { }\nvar validErr ValidationError\nif errors.As(err, &validErr) { }\n\n// 9. Keep error messages lowercase\nerrors.New(\"not found\")  // Good\nerrors.New(\"Not Found\")  // Bad\n\n// 10. Include relevant context\nfmt.Errorf(\"user %s: %w\", userID, err)  // Good\nfmt.Errorf(\"error: %w\", err)  // Too generic\n```\n\n### Common Pitfalls\n```go\n// Shadowing err variable\nerr := doFirst()\nif err != nil {\n    err := doSecond()  // Shadows outer err!\n    if err != nil {\n        return err\n    }\n}\n\n// Checking wrong error\nresult, err := doSomething()\nif err != nil {\n    anotherResult, err := doAnother()  // Reuses err\n    if err != nil {  // Might be checking wrong error\n        return err\n    }\n}\n\n// Nil interface gotcha\nfunc returnsError() error {\n    var err *MyError  // nil pointer\n    return err        // Returns non-nil error interface!\n}\n\n// Fix:\nfunc returnsError() error {\n    var err *MyError\n    if someCondition {\n        err = &MyError{}\n    }\n    if err != nil {\n        return err\n    }\n    return nil  // Explicitly return nil\n}\n```\n\n## Best Practices Summary\n\n1. **Always check errors** - Never ignore returned errors\n2. **Add context when wrapping** - Help debugging with good messages\n3. **Use sentinel errors wisely** - For known, actionable conditions\n4. **Create custom error types** - When you need rich error information\n5. **Fail fast** - Return early on errors\n6. **Don't panic** - Reserve for truly exceptional cases\n7. **Test error paths** - Ensure error handling works correctly\n8. **Use errors.Is/As** - For robust error checking\n9. **Keep errors actionable** - Help users understand what went wrong\n10. **Document error behavior** - Specify what errors functions can return"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7683,"cache_read_input_tokens":90912,"output_tokens":9930,"service_tier":"standard"}},"requestId":"req_011CS5KAQdgPLx2zgNzPqR33","type":"assistant","uuid":"08a85640-48c4-469e-a238-93fa8ee8b8e6","timestamp":"2025-08-13T07:30:51.962Z"}
{"parentUuid":"08a85640-48c4-469e-a238-93fa8ee8b8e6","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AiNo8FLbtvV4bDL3vzoPcv","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/go-errors.md"}]},"uuid":"430037d0-ee62-46be-a363-d41e1b0e5fb2","timestamp":"2025-08-13T07:30:52.019Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-errors.md","content":"# Go Error Handling - Excellence in Error Management\n\n## Table of Contents\n1. [Error Basics](#error-basics)\n2. [Error Types](#error-types)\n3. [Error Wrapping](#error-wrapping)\n4. [Sentinel Errors](#sentinel-errors)\n5. [Custom Errors](#custom-errors)\n6. [Error Design Patterns](#error-design-patterns)\n7. [Panic and Recover](#panic-and-recover)\n8. [Error Handling Strategies](#error-handling-strategies)\n9. [Testing Errors](#testing-errors)\n10. [Best Practices](#best-practices)\n\n## Error Basics\n\n### The Error Interface\n```go\n// Built-in error interface\ntype error interface {\n    Error() string\n}\n\n// Basic error creation\nimport \"errors\"\n\nerr := errors.New(\"something went wrong\")\n\n// Formatted errors\nerr := fmt.Errorf(\"failed to process item %d: %s\", id, reason)\n\n// Checking errors\nresult, err := doSomething()\nif err != nil {\n    // Handle error\n    return err\n}\n\n// Multiple return values with error\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// Named returns with error\nfunc readFile(path string) (data []byte, err error) {\n    data, err = os.ReadFile(path)\n    if err != nil {\n        return nil, err // Explicit return preferred\n    }\n    return data, nil\n}\n\n// Defer with error handling\nfunc writeFile(path string, data []byte) (err error) {\n    f, err := os.Create(path)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if cerr := f.Close(); cerr != nil && err == nil {\n            err = cerr // Capture close error if no other error\n        }\n    }()\n    \n    _, err = f.Write(data)\n    return err\n}\n```\n\n### Error Checking Patterns\n```go\n// Immediate return pattern\nif err := doSomething(); err != nil {\n    return fmt.Errorf(\"doSomething failed: %w\", err)\n}\n\n// Guard clause pattern\nfunc process(input string) error {\n    if input == \"\" {\n        return errors.New(\"input cannot be empty\")\n    }\n    \n    if len(input) > 100 {\n        return errors.New(\"input too long\")\n    }\n    \n    // Main logic here\n    return nil\n}\n\n// Error accumulation\nfunc processMultiple(items []Item) error {\n    var errs []error\n    \n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            errs = append(errs, fmt.Errorf(\"item %v: %w\", item.ID, err))\n        }\n    }\n    \n    if len(errs) > 0 {\n        return fmt.Errorf(\"multiple errors: %v\", errs)\n    }\n    \n    return nil\n}\n\n// First error wins\nfunc firstErrorWins(tasks []func() error) error {\n    for _, task := range tasks {\n        if err := task(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\n// All errors matter\nimport \"golang.org/x/sync/errgroup\"\n\nfunc allErrorsMatter(ctx context.Context) error {\n    g, ctx := errgroup.WithContext(ctx)\n    \n    g.Go(func() error {\n        return task1(ctx)\n    })\n    \n    g.Go(func() error {\n        return task2(ctx)\n    })\n    \n    g.Go(func() error {\n        return task3(ctx)\n    })\n    \n    return g.Wait() // Returns first error\n}\n```\n\n## Error Types\n\n### Implementing Error Types\n```go\n// Simple error type\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Msg   string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for %s with value %v: %s\", \n        e.Field, e.Value, e.Msg)\n}\n\n// Error type with code\ntype APIError struct {\n    Code    int\n    Message string\n    Details map[string]interface{}\n}\n\nfunc (e APIError) Error() string {\n    return fmt.Sprintf(\"API error %d: %s\", e.Code, e.Message)\n}\n\n// Temporary error interface\ntype temporary interface {\n    Temporary() bool\n}\n\ntype NetworkError struct {\n    Op         string\n    Err        error\n    Temporary  bool\n    Timeout    bool\n}\n\nfunc (e NetworkError) Error() string {\n    return fmt.Sprintf(\"network error during %s: %v\", e.Op, e.Err)\n}\n\nfunc (e NetworkError) Unwrap() error {\n    return e.Err\n}\n\nfunc (e NetworkError) IsTemporary() bool {\n    return e.Temporary\n}\n\nfunc (e NetworkError) IsTimeout() bool {\n    return e.Timeout\n}\n\n// Rich error type\ntype RichError struct {\n    Op         string                 // Operation\n    Kind       ErrorKind              // Category\n    Err        error                  // Wrapped error\n    Severity   Severity               // Error severity\n    Context    map[string]interface{} // Additional context\n    StackTrace string                 // Stack trace\n    Timestamp  time.Time              // When it occurred\n}\n\ntype ErrorKind int\n\nconst (\n    KindOther ErrorKind = iota\n    KindInvalid\n    KindPermission\n    KindIO\n    KindExist\n    KindNotExist\n    KindNetwork\n)\n\ntype Severity int\n\nconst (\n    SeverityLow Severity = iota\n    SeverityMedium\n    SeverityHigh\n    SeverityCritical\n)\n\nfunc (e *RichError) Error() string {\n    var b strings.Builder\n    b.WriteString(e.Op)\n    b.WriteString(\": \")\n    b.WriteString(e.Kind.String())\n    if e.Err != nil {\n        b.WriteString(\": \")\n        b.WriteString(e.Err.Error())\n    }\n    return b.String()\n}\n\nfunc (e *RichError) Unwrap() error {\n    return e.Err\n}\n```\n\n### Structured Errors\n```go\n// Multi-error type\ntype MultiError struct {\n    Errors []error\n}\n\nfunc (m *MultiError) Error() string {\n    var msgs []string\n    for _, err := range m.Errors {\n        msgs = append(msgs, err.Error())\n    }\n    return strings.Join(msgs, \"; \")\n}\n\nfunc (m *MultiError) Add(err error) {\n    if err != nil {\n        m.Errors = append(m.Errors, err)\n    }\n}\n\nfunc (m *MultiError) HasErrors() bool {\n    return len(m.Errors) > 0\n}\n\n// Causal error chain\ntype CausalError struct {\n    Op    string\n    Cause error\n}\n\nfunc (e *CausalError) Error() string {\n    if e.Cause != nil {\n        return fmt.Sprintf(\"%s: %v\", e.Op, e.Cause)\n    }\n    return e.Op\n}\n\nfunc (e *CausalError) Unwrap() error {\n    return e.Cause\n}\n\n// HTTP error response\ntype HTTPError struct {\n    Status  int         `json:\"status\"`\n    Code    string      `json:\"code\"`\n    Message string      `json:\"message\"`\n    Details interface{} `json:\"details,omitempty\"`\n    TraceID string      `json:\"trace_id,omitempty\"`\n}\n\nfunc (e HTTPError) Error() string {\n    return fmt.Sprintf(\"HTTP %d: %s\", e.Status, e.Message)\n}\n\nfunc (e HTTPError) StatusCode() int {\n    return e.Status\n}\n```\n\n## Error Wrapping\n\n### Wrapping with fmt.Errorf\n```go\n// Basic wrapping (Go 1.13+)\nfunc readConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read config file %s: %w\", path, err)\n    }\n    \n    var config Config\n    if err := json.Unmarshal(data, &config); err != nil {\n        return nil, fmt.Errorf(\"failed to parse config: %w\", err)\n    }\n    \n    return &config, nil\n}\n\n// Multiple wrapping layers\nfunc highlevel() error {\n    if err := midlevel(); err != nil {\n        return fmt.Errorf(\"highlevel failed: %w\", err)\n    }\n    return nil\n}\n\nfunc midlevel() error {\n    if err := lowlevel(); err != nil {\n        return fmt.Errorf(\"midlevel failed: %w\", err)\n    }\n    return nil\n}\n\nfunc lowlevel() error {\n    return errors.New(\"disk full\")\n}\n\n// Result: \"highlevel failed: midlevel failed: disk full\"\n\n// Wrapping with additional context\ntype contextError struct {\n    op      string\n    path    string\n    user    string\n    wrapped error\n}\n\nfunc (e *contextError) Error() string {\n    return fmt.Sprintf(\"op=%s path=%s user=%s: %v\", \n        e.op, e.path, e.user, e.wrapped)\n}\n\nfunc (e *contextError) Unwrap() error {\n    return e.wrapped\n}\n\nfunc wrapWithContext(op, path, user string, err error) error {\n    if err == nil {\n        return nil\n    }\n    return &contextError{\n        op:      op,\n        path:    path,\n        user:    user,\n        wrapped: err,\n    }\n}\n```\n\n### Unwrapping Errors\n```go\n// Using errors.Is (Go 1.13+)\nvar ErrPermission = errors.New(\"permission denied\")\n\nfunc checkPermission() error {\n    // Some checks...\n    return fmt.Errorf(\"user %s: %w\", username, ErrPermission)\n}\n\nfunc main() {\n    err := checkPermission()\n    if errors.Is(err, ErrPermission) {\n        // Handle permission error\n    }\n}\n\n// Using errors.As (Go 1.13+)\ntype PathError struct {\n    Op   string\n    Path string\n    Err  error\n}\n\nfunc (e *PathError) Error() string {\n    return fmt.Sprintf(\"%s %s: %v\", e.Op, e.Path, e.Err)\n}\n\nfunc handleError(err error) {\n    var pathErr *PathError\n    if errors.As(err, &pathErr) {\n        fmt.Printf(\"Path error: %s\\n\", pathErr.Path)\n    }\n}\n\n// Custom Is implementation\ntype MyError struct {\n    Code string\n    Msg  string\n}\n\nfunc (e MyError) Error() string {\n    return fmt.Sprintf(\"%s: %s\", e.Code, e.Msg)\n}\n\nfunc (e MyError) Is(target error) bool {\n    t, ok := target.(MyError)\n    if !ok {\n        return false\n    }\n    return e.Code == t.Code\n}\n\n// Custom As implementation\nfunc (e *MyError) As(target interface{}) bool {\n    switch v := target.(type) {\n    case **MyError:\n        *v = e\n        return true\n    case *MyError:\n        *v = *e\n        return true\n    default:\n        return false\n    }\n}\n```\n\n## Sentinel Errors\n\n### Defining Sentinel Errors\n```go\n// Package-level sentinel errors\npackage mypackage\n\nvar (\n    // ErrNotFound is returned when a requested resource is not found.\n    ErrNotFound = errors.New(\"not found\")\n    \n    // ErrAlreadyExists is returned when attempting to create a resource that already exists.\n    ErrAlreadyExists = errors.New(\"already exists\")\n    \n    // ErrInvalidInput is returned when input validation fails.\n    ErrInvalidInput = errors.New(\"invalid input\")\n    \n    // ErrUnauthorized is returned when authentication fails.\n    ErrUnauthorized = errors.New(\"unauthorized\")\n    \n    // ErrForbidden is returned when the user lacks permission.\n    ErrForbidden = errors.New(\"forbidden\")\n    \n    // ErrTimeout is returned when an operation times out.\n    ErrTimeout = errors.New(\"operation timeout\")\n    \n    // ErrCanceled is returned when an operation is canceled.\n    ErrCanceled = errors.New(\"operation canceled\")\n)\n\n// Using sentinel errors\nfunc GetUser(id string) (*User, error) {\n    user, err := db.Query(id)\n    if err != nil {\n        if errors.Is(err, sql.ErrNoRows) {\n            return nil, ErrNotFound\n        }\n        return nil, fmt.Errorf(\"database query failed: %w\", err)\n    }\n    return user, nil\n}\n\n// Checking sentinel errors\nuser, err := GetUser(id)\nif err != nil {\n    if errors.Is(err, ErrNotFound) {\n        // Handle not found case\n        return http.StatusNotFound\n    }\n    // Handle other errors\n    return http.StatusInternalServerError\n}\n\n// Sentinel errors with types\ntype NotFoundError struct {\n    Resource string\n    ID       string\n}\n\nfunc (e NotFoundError) Error() string {\n    return fmt.Sprintf(\"%s with ID %s not found\", e.Resource, e.ID)\n}\n\nvar errNotFoundSentinel = NotFoundError{}\n\nfunc (e NotFoundError) Is(target error) bool {\n    _, ok := target.(NotFoundError)\n    return ok\n}\n```\n\n### Sentinel Error Best Practices\n```go\n// DO: Export sentinel errors that callers need to check\nvar ErrInvalidFormat = errors.New(\"invalid format\")\n\n// DON'T: Export errors that are implementation details\nvar errInternalState = errors.New(\"internal state corrupted\") // unexported\n\n// DO: Use descriptive names\nvar ErrUserNotFound = errors.New(\"user not found\")\nvar ErrInsufficientFunds = errors.New(\"insufficient funds\")\n\n// DON'T: Use generic names\nvar ErrBad = errors.New(\"bad\")\nvar ErrFail = errors.New(\"fail\")\n\n// DO: Document sentinel errors\n// ErrRateLimitExceeded is returned when the rate limit is exceeded.\n// Callers should implement exponential backoff when receiving this error.\nvar ErrRateLimitExceeded = errors.New(\"rate limit exceeded\")\n\n// DO: Group related errors\nvar (\n    // Database errors\n    ErrDBConnection = errors.New(\"database connection failed\")\n    ErrDBTimeout    = errors.New(\"database timeout\")\n    ErrDBLocked     = errors.New(\"database locked\")\n    \n    // Validation errors\n    ErrValidationFailed = errors.New(\"validation failed\")\n    ErrMissingField     = errors.New(\"required field missing\")\n    ErrInvalidFormat    = errors.New(\"invalid format\")\n)\n```\n\n## Custom Errors\n\n### Domain-Specific Errors\n```go\n// Business logic errors\ntype InsufficientFundsError struct {\n    Account   string\n    Available decimal.Decimal\n    Required  decimal.Decimal\n}\n\nfunc (e InsufficientFundsError) Error() string {\n    return fmt.Sprintf(\"insufficient funds in account %s: available %s, required %s\",\n        e.Account, e.Available, e.Required)\n}\n\n// Validation errors\ntype ValidationErrors struct {\n    Errors map[string][]string\n}\n\nfunc (v ValidationErrors) Error() string {\n    var msgs []string\n    for field, errors := range v.Errors {\n        msgs = append(msgs, fmt.Sprintf(\"%s: %s\", field, strings.Join(errors, \", \")))\n    }\n    return \"validation failed: \" + strings.Join(msgs, \"; \")\n}\n\nfunc (v *ValidationErrors) Add(field, message string) {\n    if v.Errors == nil {\n        v.Errors = make(map[string][]string)\n    }\n    v.Errors[field] = append(v.Errors[field], message)\n}\n\nfunc (v ValidationErrors) HasErrors() bool {\n    return len(v.Errors) > 0\n}\n\n// State machine errors\ntype StateTransitionError struct {\n    From  State\n    To    State\n    Event Event\n}\n\nfunc (e StateTransitionError) Error() string {\n    return fmt.Sprintf(\"invalid state transition from %s to %s on event %s\",\n        e.From, e.To, e.Event)\n}\n\n// Configuration errors\ntype ConfigError struct {\n    File    string\n    Section string\n    Key     string\n    Value   interface{}\n    Reason  string\n}\n\nfunc (e ConfigError) Error() string {\n    return fmt.Sprintf(\"config error in %s [%s] %s=%v: %s\",\n        e.File, e.Section, e.Key, e.Value, e.Reason)\n}\n```\n\n### Error Builders\n```go\n// Fluent error builder\ntype ErrorBuilder struct {\n    err      error\n    code     string\n    message  string\n    details  map[string]interface{}\n    wrapped  error\n}\n\nfunc NewError() *ErrorBuilder {\n    return &ErrorBuilder{\n        details: make(map[string]interface{}),\n    }\n}\n\nfunc (b *ErrorBuilder) WithCode(code string) *ErrorBuilder {\n    b.code = code\n    return b\n}\n\nfunc (b *ErrorBuilder) WithMessage(msg string) *ErrorBuilder {\n    b.message = msg\n    return b\n}\n\nfunc (b *ErrorBuilder) WithDetail(key string, value interface{}) *ErrorBuilder {\n    b.details[key] = value\n    return b\n}\n\nfunc (b *ErrorBuilder) Wrap(err error) *ErrorBuilder {\n    b.wrapped = err\n    return b\n}\n\nfunc (b *ErrorBuilder) Build() error {\n    return &builtError{\n        code:    b.code,\n        message: b.message,\n        details: b.details,\n        wrapped: b.wrapped,\n    }\n}\n\ntype builtError struct {\n    code    string\n    message string\n    details map[string]interface{}\n    wrapped error\n}\n\nfunc (e builtError) Error() string {\n    if e.wrapped != nil {\n        return fmt.Sprintf(\"[%s] %s: %v\", e.code, e.message, e.wrapped)\n    }\n    return fmt.Sprintf(\"[%s] %s\", e.code, e.message)\n}\n\nfunc (e builtError) Unwrap() error {\n    return e.wrapped\n}\n\n// Usage\nerr := NewError().\n    WithCode(\"VALIDATION_ERROR\").\n    WithMessage(\"Invalid user input\").\n    WithDetail(\"field\", \"email\").\n    WithDetail(\"value\", userEmail).\n    Wrap(originalErr).\n    Build()\n```\n\n## Error Design Patterns\n\n### Error Handler Pattern\n```go\n// Centralized error handler\ntype ErrorHandler interface {\n    Handle(error) error\n}\n\ntype errorHandler struct {\n    logger    Logger\n    metrics   Metrics\n    notifier  Notifier\n}\n\nfunc (h *errorHandler) Handle(err error) error {\n    // Log error\n    h.logger.Error(\"error occurred\", \"error\", err)\n    \n    // Record metrics\n    h.metrics.IncrementErrorCount(errorType(err))\n    \n    // Notify if critical\n    if isCritical(err) {\n        h.notifier.NotifyCritical(err)\n    }\n    \n    // Transform for client\n    return transformError(err)\n}\n\nfunc errorType(err error) string {\n    switch {\n    case errors.Is(err, ErrNotFound):\n        return \"not_found\"\n    case errors.Is(err, ErrUnauthorized):\n        return \"unauthorized\"\n    default:\n        return \"internal\"\n    }\n}\n\nfunc isCritical(err error) bool {\n    var criticalErr CriticalError\n    return errors.As(err, &criticalErr)\n}\n\nfunc transformError(err error) error {\n    // Hide internal details from client\n    switch {\n    case errors.Is(err, ErrNotFound):\n        return NewHTTPError(404, \"Resource not found\")\n    case errors.Is(err, ErrUnauthorized):\n        return NewHTTPError(401, \"Unauthorized\")\n    default:\n        return NewHTTPError(500, \"Internal server error\")\n    }\n}\n```\n\n### Result Type Pattern\n```go\n// Result type for explicit error handling\ntype Result[T any] struct {\n    value T\n    err   error\n}\n\nfunc Ok[T any](value T) Result[T] {\n    return Result[T]{value: value}\n}\n\nfunc Err[T any](err error) Result[T] {\n    return Result[T]{err: err}\n}\n\nfunc (r Result[T]) IsOk() bool {\n    return r.err == nil\n}\n\nfunc (r Result[T]) IsErr() bool {\n    return r.err != nil\n}\n\nfunc (r Result[T]) Unwrap() (T, error) {\n    return r.value, r.err\n}\n\nfunc (r Result[T]) UnwrapOr(defaultValue T) T {\n    if r.err != nil {\n        return defaultValue\n    }\n    return r.value\n}\n\nfunc (r Result[T]) Map(fn func(T) T) Result[T] {\n    if r.err != nil {\n        return r\n    }\n    return Ok(fn(r.value))\n}\n\n// Usage\nfunc divide(a, b float64) Result[float64] {\n    if b == 0 {\n        return Err[float64](errors.New(\"division by zero\"))\n    }\n    return Ok(a / b)\n}\n\nresult := divide(10, 2)\nif result.IsOk() {\n    value, _ := result.Unwrap()\n    fmt.Println(value)\n}\n```\n\n### Error Recovery Pattern\n```go\n// Retry with exponential backoff\nfunc retryWithBackoff(fn func() error, maxRetries int) error {\n    var err error\n    backoff := 100 * time.Millisecond\n    \n    for i := 0; i < maxRetries; i++ {\n        err = fn()\n        if err == nil {\n            return nil\n        }\n        \n        // Check if error is retryable\n        if !isRetryable(err) {\n            return err\n        }\n        \n        if i < maxRetries-1 {\n            time.Sleep(backoff)\n            backoff *= 2\n            if backoff > 10*time.Second {\n                backoff = 10 * time.Second\n            }\n        }\n    }\n    \n    return fmt.Errorf(\"failed after %d retries: %w\", maxRetries, err)\n}\n\nfunc isRetryable(err error) bool {\n    // Check for temporary errors\n    var tempErr interface{ Temporary() bool }\n    if errors.As(err, &tempErr) && tempErr.Temporary() {\n        return true\n    }\n    \n    // Check for specific retryable errors\n    return errors.Is(err, ErrTimeout) || \n           errors.Is(err, ErrRateLimited) ||\n           errors.Is(err, ErrServiceUnavailable)\n}\n\n// Circuit breaker pattern\ntype CircuitBreaker struct {\n    mu           sync.RWMutex\n    failureCount int\n    lastFailTime time.Time\n    state        string // \"closed\", \"open\", \"half-open\"\n    threshold    int\n    timeout      time.Duration\n}\n\nfunc (cb *CircuitBreaker) Call(fn func() error) error {\n    cb.mu.RLock()\n    state := cb.state\n    cb.mu.RUnlock()\n    \n    if state == \"open\" {\n        cb.mu.RLock()\n        if time.Since(cb.lastFailTime) > cb.timeout {\n            cb.mu.RUnlock()\n            cb.mu.Lock()\n            cb.state = \"half-open\"\n            cb.mu.Unlock()\n        } else {\n            cb.mu.RUnlock()\n            return ErrCircuitBreakerOpen\n        }\n    }\n    \n    err := fn()\n    \n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n    \n    if err != nil {\n        cb.failureCount++\n        cb.lastFailTime = time.Now()\n        \n        if cb.failureCount >= cb.threshold {\n            cb.state = \"open\"\n        }\n        return err\n    }\n    \n    if cb.state == \"half-open\" {\n        cb.state = \"closed\"\n    }\n    cb.failureCount = 0\n    return nil\n}\n```\n\n## Panic and Recover\n\n### When to Panic\n```go\n// Panic for unrecoverable errors during initialization\nfunc MustConnect(dsn string) *sql.DB {\n    db, err := sql.Open(\"postgres\", dsn)\n    if err != nil {\n        panic(fmt.Sprintf(\"failed to connect to database: %v\", err))\n    }\n    return db\n}\n\n// Panic for programming errors\nfunc (s *Stack) Pop() interface{} {\n    if len(s.items) == 0 {\n        panic(\"pop from empty stack\") // Programming error\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item\n}\n\n// Panic for impossible conditions\nfunc processValue(v interface{}) {\n    switch v := v.(type) {\n    case int:\n        // handle int\n    case string:\n        // handle string\n    default:\n        panic(fmt.Sprintf(\"unexpected type %T\", v))\n    }\n}\n\n// DON'T panic for normal errors\nfunc badExample(input string) {\n    if input == \"\" {\n        panic(\"input is empty\") // Bad! Use error return instead\n    }\n}\n\nfunc goodExample(input string) error {\n    if input == \"\" {\n        return errors.New(\"input is empty\")\n    }\n    return nil\n}\n```\n\n### Recover Pattern\n```go\n// Basic recover\nfunc safeCall(fn func()) (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    \n    fn()\n    return nil\n}\n\n// Recover with stack trace\nimport \"runtime/debug\"\n\nfunc recoverWithStack() {\n    if r := recover(); r != nil {\n        log.Printf(\"Panic: %v\\nStack: %s\", r, debug.Stack())\n    }\n}\n\n// HTTP middleware with recover\nfunc RecoverMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"Panic in handler: %v\\nStack: %s\", err, debug.Stack())\n                http.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n            }\n        }()\n        \n        next.ServeHTTP(w, r)\n    })\n}\n\n// Goroutine with recover\nfunc SafeGo(fn func()) {\n    go func() {\n        defer func() {\n            if r := recover(); r != nil {\n                log.Printf(\"Panic in goroutine: %v\\nStack: %s\", r, debug.Stack())\n            }\n        }()\n        \n        fn()\n    }()\n}\n\n// Convert panic to error\nfunc callExternalLibrary() (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"external library panicked: %v\", r)\n        }\n    }()\n    \n    // Call potentially panicking external code\n    externalLibrary.DangerousOperation()\n    \n    return nil\n}\n```\n\n## Error Handling Strategies\n\n### Fail Fast\n```go\n// Fail fast on critical errors\nfunc Initialize() error {\n    // Check prerequisites first\n    if err := checkDependencies(); err != nil {\n        return fmt.Errorf(\"dependency check failed: %w\", err)\n    }\n    \n    if err := validateConfig(); err != nil {\n        return fmt.Errorf(\"config validation failed: %w\", err)\n    }\n    \n    // Only proceed if everything is valid\n    return startServices()\n}\n\n// Validate early\nfunc ProcessRequest(req Request) error {\n    // Validate input immediately\n    if err := req.Validate(); err != nil {\n        return fmt.Errorf(\"invalid request: %w\", err)\n    }\n    \n    // Check permissions early\n    if err := checkPermissions(req.UserID); err != nil {\n        return fmt.Errorf(\"permission denied: %w\", err)\n    }\n    \n    // Process only after validation\n    return process(req)\n}\n```\n\n### Graceful Degradation\n```go\n// Fallback on error\nfunc GetUserPreferences(userID string) (*Preferences, error) {\n    // Try to get from cache\n    prefs, err := cache.Get(userID)\n    if err == nil {\n        return prefs, nil\n    }\n    \n    // Fallback to database\n    prefs, err = db.GetPreferences(userID)\n    if err == nil {\n        // Update cache for next time\n        go cache.Set(userID, prefs)\n        return prefs, nil\n    }\n    \n    // Return defaults if all fails\n    log.Printf(\"Failed to get preferences for %s: %v\", userID, err)\n    return DefaultPreferences(), nil\n}\n\n// Partial success\nfunc ProcessBatch(items []Item) error {\n    var successCount int\n    var errors []error\n    \n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            errors = append(errors, fmt.Errorf(\"item %v: %w\", item.ID, err))\n            continue\n        }\n        successCount++\n    }\n    \n    if len(errors) > 0 {\n        log.Printf(\"Processed %d/%d items successfully\", successCount, len(items))\n        return &PartialError{\n            Successful: successCount,\n            Failed:     len(errors),\n            Errors:     errors,\n        }\n    }\n    \n    return nil\n}\n```\n\n### Error Aggregation\n```go\n// Collect all errors\ntype ErrorCollector struct {\n    mu     sync.Mutex\n    errors []error\n}\n\nfunc (c *ErrorCollector) Add(err error) {\n    if err == nil {\n        return\n    }\n    \n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.errors = append(c.errors, err)\n}\n\nfunc (c *ErrorCollector) Error() error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    switch len(c.errors) {\n    case 0:\n        return nil\n    case 1:\n        return c.errors[0]\n    default:\n        return &MultiError{Errors: c.errors}\n    }\n}\n\n// Usage with goroutines\nfunc ProcessConcurrently(items []Item) error {\n    var wg sync.WaitGroup\n    collector := &ErrorCollector{}\n    \n    for _, item := range items {\n        wg.Add(1)\n        go func(i Item) {\n            defer wg.Done()\n            if err := processItem(i); err != nil {\n                collector.Add(fmt.Errorf(\"item %v: %w\", i.ID, err))\n            }\n        }(item)\n    }\n    \n    wg.Wait()\n    return collector.Error()\n}\n```\n\n## Testing Errors\n\n### Testing Error Cases\n```go\nfunc TestDivide(t *testing.T) {\n    tests := []struct {\n        name    string\n        a, b    float64\n        want    float64\n        wantErr bool\n        errMsg  string\n    }{\n        {\n            name: \"normal division\",\n            a:    10,\n            b:    2,\n            want: 5,\n        },\n        {\n            name:    \"divide by zero\",\n            a:       10,\n            b:       0,\n            wantErr: true,\n            errMsg:  \"division by zero\",\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := Divide(tt.a, tt.b)\n            \n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Divide() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            \n            if tt.wantErr {\n                if !strings.Contains(err.Error(), tt.errMsg) {\n                    t.Errorf(\"Divide() error = %v, want error containing %v\", \n                        err, tt.errMsg)\n                }\n                return\n            }\n            \n            if got != tt.want {\n                t.Errorf(\"Divide() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n\n// Testing sentinel errors\nfunc TestGetUser_NotFound(t *testing.T) {\n    repo := NewMockRepository()\n    repo.ReturnError = sql.ErrNoRows\n    \n    service := NewService(repo)\n    _, err := service.GetUser(\"123\")\n    \n    if !errors.Is(err, ErrNotFound) {\n        t.Errorf(\"expected ErrNotFound, got %v\", err)\n    }\n}\n\n// Testing error types\nfunc TestValidationError(t *testing.T) {\n    err := ValidateUser(User{})\n    \n    var validationErr ValidationError\n    if !errors.As(err, &validationErr) {\n        t.Fatalf(\"expected ValidationError, got %T\", err)\n    }\n    \n    if validationErr.Field != \"email\" {\n        t.Errorf(\"expected field 'email', got %s\", validationErr.Field)\n    }\n}\n\n// Testing error wrapping\nfunc TestErrorWrapping(t *testing.T) {\n    rootErr := errors.New(\"root cause\")\n    wrappedErr := fmt.Errorf(\"wrapped: %w\", rootErr)\n    \n    if !errors.Is(wrappedErr, rootErr) {\n        t.Error(\"expected wrapped error to contain root cause\")\n    }\n}\n```\n\n### Mocking Errors\n```go\n// Error injection for testing\ntype ErrorInjector struct {\n    errors map[string]error\n    calls  map[string]int\n}\n\nfunc (e *ErrorInjector) ShouldFail(operation string) error {\n    e.calls[operation]++\n    \n    if err, ok := e.errors[operation]; ok {\n        // Return error on specific call count\n        if callErr, ok := err.(*CallCountError); ok {\n            if e.calls[operation] == callErr.OnCall {\n                return callErr.Err\n            }\n            return nil\n        }\n        return err\n    }\n    \n    return nil\n}\n\ntype CallCountError struct {\n    OnCall int\n    Err    error\n}\n\n// Usage in tests\nfunc TestRetry(t *testing.T) {\n    injector := &ErrorInjector{\n        errors: map[string]error{\n            \"connect\": &CallCountError{\n                OnCall: 1, // Fail on first call\n                Err:    errors.New(\"connection failed\"),\n            },\n        },\n        calls: make(map[string]int),\n    }\n    \n    service := NewService(injector)\n    err := service.ConnectWithRetry()\n    \n    if err != nil {\n        t.Errorf(\"expected success after retry, got %v\", err)\n    }\n    \n    if injector.calls[\"connect\"] != 2 {\n        t.Errorf(\"expected 2 connection attempts, got %d\", \n            injector.calls[\"connect\"])\n    }\n}\n```\n\n## Best Practices\n\n### Error Design Guidelines\n```go\n// 1. Return error as last value\nfunc Good() (Result, error)\nfunc Bad() (error, Result)  // Don't do this\n\n// 2. Check errors immediately\nresult, err := doSomething()\nif err != nil {\n    return err\n}\n\n// 3. Add context when wrapping\nif err != nil {\n    return fmt.Errorf(\"failed to process user %s: %w\", userID, err)\n}\n\n// 4. Use sentinel errors for known conditions\nvar ErrNotFound = errors.New(\"not found\")\n\n// 5. Create specific error types for rich information\ntype ValidationError struct {\n    Field string\n    Value interface{}\n}\n\n// 6. Don't ignore errors\n_ = os.Remove(tempFile)  // Bad\nif err := os.Remove(tempFile); err != nil {\n    log.Printf(\"failed to remove temp file: %v\", err)\n}\n\n// 7. Handle errors once\n// Don't log AND return - let caller decide\n\n// 8. Use errors.Is and errors.As for checking\nif errors.Is(err, ErrNotFound) { }\nvar validErr ValidationError\nif errors.As(err, &validErr) { }\n\n// 9. Keep error messages lowercase\nerrors.New(\"not found\")  // Good\nerrors.New(\"Not Found\")  // Bad\n\n// 10. Include relevant context\nfmt.Errorf(\"user %s: %w\", userID, err)  // Good\nfmt.Errorf(\"error: %w\", err)  // Too generic\n```\n\n### Common Pitfalls\n```go\n// Shadowing err variable\nerr := doFirst()\nif err != nil {\n    err := doSecond()  // Shadows outer err!\n    if err != nil {\n        return err\n    }\n}\n\n// Checking wrong error\nresult, err := doSomething()\nif err != nil {\n    anotherResult, err := doAnother()  // Reuses err\n    if err != nil {  // Might be checking wrong error\n        return err\n    }\n}\n\n// Nil interface gotcha\nfunc returnsError() error {\n    var err *MyError  // nil pointer\n    return err        // Returns non-nil error interface!\n}\n\n// Fix:\nfunc returnsError() error {\n    var err *MyError\n    if someCondition {\n        err = &MyError{}\n    }\n    if err != nil {\n        return err\n    }\n    return nil  // Explicitly return nil\n}\n```\n\n## Best Practices Summary\n\n1. **Always check errors** - Never ignore returned errors\n2. **Add context when wrapping** - Help debugging with good messages\n3. **Use sentinel errors wisely** - For known, actionable conditions\n4. **Create custom error types** - When you need rich error information\n5. **Fail fast** - Return early on errors\n6. **Don't panic** - Reserve for truly exceptional cases\n7. **Test error paths** - Ensure error handling works correctly\n8. **Use errors.Is/As** - For robust error checking\n9. **Keep errors actionable** - Help users understand what went wrong\n10. **Document error behavior** - Specify what errors functions can return","structuredPatch":[]}}
{"parentUuid":"430037d0-ee62-46be-a363-d41e1b0e5fb2","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01ERS1KMwUoikTjjmjmR7QBH","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Let me create the remaining documentation files:\n\n## 8. Go Security"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9970,"cache_read_input_tokens":98595,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS5KPBke4PnW2LuWSeaRF","type":"assistant","uuid":"73976a65-db0f-45d7-89d3-23b33411bce0","timestamp":"2025-08-13T07:30:56.381Z"}
{"parentUuid":"73976a65-db0f-45d7-89d3-23b33411bce0","isSidechain":true,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"assistant","uuid":"9506bb16-7ff8-4cd2-9782-2a7f770cc642","timestamp":"2025-08-13T07:46:29.421Z","message":{"id":"ca4dba69-d499-4d24-bb02-4571d02aa796","model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0},"service_tier":null},"content":[{"type":"text","text":"API Error: Request timed out."}]},"isApiErrorMessage":true}
{"parentUuid":"ef9d2eff-d788-456c-b5a3-771b7e3c5c6f","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DPScpyZGMu1k3WNpVicMg2","type":"tool_result","content":[{"type":"text","text":"API Error: Request timed out."}]}]},"uuid":"1c31d264-83af-42f9-a7e9-0a7068e89535","timestamp":"2025-08-13T07:46:29.434Z","toolUseResult":{"content":[{"type":"text","text":"API Error: Request timed out."}],"totalDurationMs":2420841,"totalTokens":0,"totalToolUseCount":8,"usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0},"service_tier":null}}}
{"parentUuid":"1c31d264-83af-42f9-a7e9-0a7068e89535","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01C8r2xteZgqSuW9d8hoPd9Y","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Let me take a different approach and work on this directly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":26379,"cache_read_input_tokens":11551,"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CS5LaHT7gquwbWj7fUxdz","type":"assistant","uuid":"e8914e0f-2643-4953-9b1a-fc1593d547fe","timestamp":"2025-08-13T07:46:33.498Z"}
{"parentUuid":"e8914e0f-2643-4953-9b1a-fc1593d547fe","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01C8r2xteZgqSuW9d8hoPd9Y","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01QXstfAi5LXJ2CaMAw3nVcK","name":"Read","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":26379,"cache_read_input_tokens":11551,"output_tokens":86,"service_tier":"standard"}},"requestId":"req_011CS5LaHT7gquwbWj7fUxdz","type":"assistant","uuid":"e7dd9be2-559a-4a36-baab-f028dd59bc85","timestamp":"2025-08-13T07:46:34.184Z"}
{"parentUuid":"e7dd9be2-559a-4a36-baab-f028dd59bc85","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist. Did you mean practices-patterns.md?</tool_use_error>","is_error":true,"tool_use_id":"toolu_01QXstfAi5LXJ2CaMAw3nVcK"}]},"uuid":"e0f673eb-04ac-496c-8243-fb29d02a6e79","timestamp":"2025-08-13T07:46:34.206Z","toolUseResult":"Error: File does not exist. Did you mean practices-patterns.md?"}
{"parentUuid":"e0f673eb-04ac-496c-8243-fb29d02a6e79","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_016Jg8BJBooK89y5wSJDQv1Q","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01CG2gYqs8RGdjEMQz3qYX11","name":"Glob","input":{"pattern":"**/*practices*","path":"/home/aural/Code/bigmeanie/back/.docs/code"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":131,"cache_read_input_tokens":37930,"output_tokens":88,"service_tier":"standard"}},"requestId":"req_011CS5LadgnPu4RoF5ph2bUe","type":"assistant","uuid":"2c3e5449-02fa-441a-b894-f2dda65443eb","timestamp":"2025-08-13T07:46:38.062Z"}
{"parentUuid":"2c3e5449-02fa-441a-b894-f2dda65443eb","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CG2gYqs8RGdjEMQz3qYX11","type":"tool_result","content":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md"}]},"uuid":"7ec84ff1-63bd-4613-bb7f-99538b41051c","timestamp":"2025-08-13T07:46:38.090Z","toolUseResult":{"filenames":["/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md"],"durationMs":7,"numFiles":1,"truncated":false}}
{"parentUuid":"7ec84ff1-63bd-4613-bb7f-99538b41051c","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01XXFWn79bG8rSGsrh4mydms","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01A8K6f5KvCbmovDNmhZpw4k","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Examine existing /back/.docs/code/practices-patterns file","status":"in_progress"},{"id":"2","content":"Create comprehensive Go language fundamentals documentation","status":"pending"},{"id":"3","content":"Document all Go design patterns and idioms","status":"pending"},{"id":"4","content":"Create advanced Go concurrency documentation","status":"pending"},{"id":"5","content":"Document Go testing and benchmarking practices","status":"pending"},{"id":"6","content":"Create Go performance optimization guide","status":"pending"},{"id":"7","content":"Document Go security best practices","status":"pending"},{"id":"8","content":"Create Go tooling and ecosystem documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":123,"cache_read_input_tokens":38061,"output_tokens":258,"service_tier":"standard"}},"requestId":"req_011CS5LauMMmPvWvzyANjJsA","type":"assistant","uuid":"b7942133-44d0-49b7-ae1c-4f3443f513ed","timestamp":"2025-08-13T07:46:45.614Z"}
{"parentUuid":"b7942133-44d0-49b7-ae1c-4f3443f513ed","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A8K6f5KvCbmovDNmhZpw4k","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"da92ce11-a5c5-4e16-82e3-106d5aa81692","timestamp":"2025-08-13T07:46:45.639Z","toolUseResult":{"oldTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"pending","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"pending","id":"2"},{"content":"Document all Go design patterns and idioms","status":"pending","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}],"newTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"in_progress","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"pending","id":"2"},{"content":"Document all Go design patterns and idioms","status":"pending","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}]}}
{"parentUuid":"da92ce11-a5c5-4e16-82e3-106d5aa81692","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_017Jm6P3e6aJoPBW2FgRaZRr","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01LwwByFaYKE4J9xaLa2VRjG","name":"Read","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":509,"cache_read_input_tokens":38184,"output_tokens":75,"service_tier":"standard"}},"requestId":"req_011CS5LbUnGnp5NoAsM44MrV","type":"assistant","uuid":"99f9ef15-7c2c-497b-b209-d389f2915dfd","timestamp":"2025-08-13T07:46:49.090Z"}
{"parentUuid":"99f9ef15-7c2c-497b-b209-d389f2915dfd","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LwwByFaYKE4J9xaLa2VRjG","type":"tool_result","content":"     1→# Go Best Practices\n     2→\n     3→## Overview\n     4→\n     5→Go-specific best practices and patterns following Go idioms and community standards.\n     6→\n     7→### Core Go Principles\n     8→- **Simplicity over abstraction** - Start simple, add complexity only when needed\n     9→- **Channels for communication** - Don't communicate by sharing memory, share memory by communicating\n    10→- **Errors as values** - Return errors, don't panic\n    11→- **Small interfaces** - The bigger the interface, the weaker the abstraction\n    12→- **Composition over inheritance** - Embed types, don't create hierarchies\n    13→- **Context for cancellation** - Pass context.Context for cancellation and timeouts\n    14→\n    15→## Interface Design\n    16→\n    17→### Small, Focused Interfaces\n    18→\n    19→Follow the Go proverb: \"The bigger the interface, the weaker the abstraction.\"\n    20→\n    21→```go\n    22→// ✅ GOOD: Small interfaces are easier to implement and test\n    23→type PriceProvider interface {\n    24→    GetPrice(symbol string) (decimal.Decimal, error)\n    25→}\n    26→\n    27→type OrderPlacer interface {\n    28→    PlaceOrder(order *Order) (*OrderResult, error)\n    29→}\n    30→\n    31→// ❌ BAD: Large interface with many responsibilities\n    32→type TradingService interface {\n    33→    GetPrice(symbol string) (decimal.Decimal, error)\n    34→    PlaceOrder(order *Order) (*OrderResult, error)\n    35→    CancelOrder(id string) error\n    36→    GetOrderStatus(id string) (*OrderStatus, error)\n    37→    GetBalance(currency string) (decimal.Decimal, error)\n    38→    // ... 20 more methods\n    39→}\n    40→```\n    41→\n    42→## Naming Conventions\n    43→\n    44→### Clear Names Without Unnecessary Abbreviations\n    45→\n    46→```go\n    47→// ❌ BAD: Unclear abbreviations\n    48→cfg, mgr, svc, calc, resp, req\n    49→\n    50→// ✅ GOOD: Clear, full names\n    51→config, manager, service, calculate, response, request\n    52→\n    53→// Exception: Well-known abbreviations are acceptable\n    54→ctx context.Context  // Standard Go abbreviation\n    55→db *sql.DB          // Widely understood\n    56→err error           // Go convention\n    57→```\n    58→\n    59→### Function and Method Names\n    60→\n    61→```go\n    62→// Function names should be self-explanatory\n    63→func CalculatePositionSize(balance, riskPercentage decimal.Decimal) decimal.Decimal\n    64→\n    65→// Avoid redundant package names in functions\n    66→// ❌ BAD\n    67→package order\n    68→func OrderValidator() // order.OrderValidator is redundant\n    69→\n    70→// ✅ GOOD\n    71→package order\n    72→func Validator() // order.Validator is clear\n    73→```\n    74→\n    75→### Receiver Names\n    76→\n    77→Use single-letter receivers for methods:\n    78→\n    79→```go\n    80→// ✅ GOOD: Single letter that represents the type\n    81→func (s *Strategy) Analyze(data MarketData) Signal\n    82→func (c *Config) Validate() error\n    83→func (o *Order) Execute() error\n    84→\n    85→// ❌ BAD: Long receiver names\n    86→func (strategy *Strategy) Analyze(data MarketData) Signal\n    87→func (config *Config) Validate() error\n    88→```\n    89→\n    90→## Error Handling\n    91→\n    92→### Always Check Errors\n    93→\n    94→Never ignore errors, even in deferred functions:\n    95→\n    96→```go\n    97→// ❌ BAD: Ignoring error\n    98→defer file.Close()\n    99→\n   100→// ✅ GOOD: Check error even in defer\n   101→defer func() {\n   102→    if err := file.Close(); err != nil {\n   103→        log.Printf(\"failed to close file: %v\", err)\n   104→    }\n   105→}()\n   106→```\n   107→\n   108→## Concurrency Patterns\n   109→\n   110→### Don't Communicate by Sharing Memory\n   111→\n   112→Follow Go's concurrency philosophy:\n   113→\n   114→```go\n   115→// ❌ BAD: Shared memory with mutex\n   116→type Counter struct {\n   117→    mu    sync.Mutex\n   118→    value int\n   119→}\n   120→\n   121→func (c *Counter) Inc() {\n   122→    c.mu.Lock()\n   123→    c.value++\n   124→    c.mu.Unlock()\n   125→}\n   126→\n   127→// ✅ GOOD: Communicate via channels\n   128→type Counter struct {\n   129→    inc chan int\n   130→    get chan int\n   131→}\n   132→\n   133→func (c *Counter) run() {\n   134→    value := 0\n   135→    for {\n   136→        select {\n   137→        case <-c.inc:\n   138→            value++\n   139→        case c.get <- value:\n   140→        }\n   141→    }\n   142→}\n   143→```\n   144→\n   145→### Context for Cancellation\n   146→\n   147→Always use context for cancellation and timeouts:\n   148→\n   149→```go\n   150→// ✅ GOOD: Respecting context\n   151→func FetchData(ctx context.Context, symbol string) (*Data, error) {\n   152→    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n   153→    if err != nil {\n   154→        return nil, err\n   155→    }\n   156→\n   157→    resp, err := client.Do(req)\n   158→    // ... handle response\n   159→}\n   160→```\n   161→\n   162→## Resource Management\n   163→\n   164→### Defer Cleanup\n   165→\n   166→Always defer cleanup immediately after acquiring resources:\n   167→\n   168→```go\n   169→// ✅ GOOD: Immediate defer\n   170→file, err := os.Open(\"data.txt\")\n   171→if err != nil {\n   172→    return err\n   173→}\n   174→defer file.Close() // Immediately after successful open\n   175→\n   176→// Process file...\n   177→```\n   178→\n   179→### Check Close Errors\n   180→\n   181→Some Close operations can fail and should be checked:\n   182→\n   183→```go\n   184→// ✅ GOOD: Check close error for writers\n   185→func WriteData(filename string, data []byte) error {\n   186→    file, err := os.Create(filename)\n   187→    if err != nil {\n   188→        return err\n   189→    }\n   190→    defer func() {\n   191→        if cerr := file.Close(); cerr != nil && err == nil {\n   192→            err = cerr // Capture close error if no other error\n   193→        }\n   194→    }()\n   195→\n   196→    _, err = file.Write(data)\n   197→    return err\n   198→}\n   199→```\n   200→\n   201→## Testing\n   202→\n   203→### Table-Driven Tests\n   204→\n   205→```go\n   206→func TestCalculatePositionSize(t *testing.T) {\n   207→    tests := []struct {\n   208→        name     string\n   209→        balance  decimal.Decimal\n   210→        risk     decimal.Decimal\n   211→        stopLoss decimal.Decimal\n   212→        want     decimal.Decimal\n   213→        wantErr  bool\n   214→    }{\n   215→        {\n   216→            name:     \"valid inputs\",\n   217→            balance:  decimal.NewFromInt(10000),\n   218→            risk:     decimal.NewFromFloat(0.02),\n   219→            stopLoss: decimal.NewFromInt(100),\n   220→            want:     decimal.NewFromInt(200),\n   221→            wantErr:  false,\n   222→        },\n   223→        {\n   224→            name:     \"negative balance\",\n   225→            balance:  decimal.NewFromInt(-1000),\n   226→            risk:     decimal.NewFromFloat(0.02),\n   227→            stopLoss: decimal.NewFromInt(100),\n   228→            want:     decimal.Zero,\n   229→            wantErr:  true,\n   230→        },\n   231→    }\n   232→\n   233→    for _, tt := range tests {\n   234→        t.Run(tt.name, func(t *testing.T) {\n   235→            got, err := CalculatePositionSize(tt.balance, tt.risk, tt.stopLoss)\n   236→            if (err != nil) != tt.wantErr {\n   237→                t.Errorf(\"error = %v, wantErr %v\", err, tt.wantErr)\n   238→                return\n   239→            }\n   240→            if !got.Equal(tt.want) {\n   241→                t.Errorf(\"got = %v, want %v\", got, tt.want)\n   242→            }\n   243→        })\n   244→    }\n   245→}\n   246→```\n   247→\n   248→### Test Naming\n   249→\n   250→```go\n   251→// Test function names should describe what is being tested\n   252→func TestCalculatePositionSize_WithValidInputs(t *testing.T)\n   253→func TestCalculatePositionSize_WithNegativeBalance(t *testing.T)\n   254→func TestCalculatePositionSize_WithZeroStopLoss(t *testing.T)\n   255→```\n   256→\n   257→## Package Design\n   258→\n   259→### Package Names\n   260→\n   261→- Use singular, lowercase names: `order` not `orders`\n   262→- Avoid generic names like `util`, `common`, `helpers`\n   263→- Package name should describe its purpose\n   264→\n   265→### Package Organization\n   266→\n   267→```\n   268→internal/\n   269→├── trading/          # Domain logic\n   270→│   ├── order.go     # Core types\n   271→│   ├── engine.go    # Business logic\n   272→│   └── order_test.go # Tests next to code\n   273→├── api/             # External integrations\n   274→└── models/          # Data models\n   275→```\n   276→\n   277→## Comments and Documentation\n   278→\n   279→### Package Comments\n   280→\n   281→Every package should have a package comment:\n   282→\n   283→```go\n   284→// Package trading implements the core trading engine.\n   285→// It provides order execution, position management, and risk controls.\n   286→package trading\n   287→```\n   288→\n   289→### Exported Functions\n   290→\n   291→Document all exported functions:\n   292→\n   293→```go\n   294→// CalculatePositionSize determines the appropriate position size based on\n   295→// account balance, risk percentage, and stop loss distance.\n   296→// It returns an error if any input is invalid (negative or zero).\n   297→func CalculatePositionSize(balance, riskPct, stopLoss decimal.Decimal) (decimal.Decimal, error) {\n   298→    // Implementation\n   299→}\n   300→```\n   301→\n   302→## Performance\n   303→\n   304→### Preallocate Slices\n   305→\n   306→When size is known, preallocate:\n   307→\n   308→```go\n   309→// ❌ BAD: Growing slice\n   310→var results []Result\n   311→for _, item := range items {\n   312→    results = append(results, process(item))\n   313→}\n   314→\n   315→// ✅ GOOD: Preallocated\n   316→results := make([]Result, 0, len(items))\n   317→for _, item := range items {\n   318→    results = append(results, process(item))\n   319→}\n   320→```\n   321→\n   322→### String Building\n   323→\n   324→Use strings.Builder for concatenation:\n   325→\n   326→```go\n   327→// ❌ BAD: String concatenation in loop\n   328→var result string\n   329→for _, s := range strings {\n   330→    result += s\n   331→}\n   332→\n   333→// ✅ GOOD: strings.Builder\n   334→var builder strings.Builder\n   335→for _, s := range strings {\n   336→    builder.WriteString(s)\n   337→}\n   338→result := builder.String()\n   339→```\n   340→\n   341→## Common Pitfalls\n   342→\n   343→### Range Variable Capture\n   344→\n   345→```go\n   346→// ❌ BAD: Captures loop variable\n   347→for _, item := range items {\n   348→    go func() {\n   349→        process(item) // Bug: all goroutines get last item\n   350→    }()\n   351→}\n   352→\n   353→// ✅ GOOD: Copy variable\n   354→for _, item := range items {\n   355→    itemCopy := item\n   356→    go func() {\n   357→        process(itemCopy)\n   358→    }()\n   359→}\n   360→```\n   361→\n   362→### Nil Interface Values\n   363→\n   364→```go\n   365→// ❌ BAD: Can cause nil pointer panic\n   366→var err *MyError\n   367→if condition {\n   368→    err = &MyError{\"something went wrong\"}\n   369→}\n   370→return err // Returns non-nil interface with nil value\n   371→\n   372→// ✅ GOOD: Return explicit nil\n   373→if condition {\n   374→    return &MyError{\"something went wrong\"}\n   375→}\n   376→return nil\n   377→```\n   378→\n   379→### Logger and Error Framework\n   380→```go\n   381→// Initialize logger at application start\n   382→func main() {\n   383→    if err := logger.InitZap(os.Getenv(\"LOG_LEVEL\"), os.Getenv(\"BIGMEANIE_DEV\") == \"true\"); err != nil {\n   384→        panic(fmt.Sprintf(\"failed to initialize logger: %v\", err))\n   385→    }\n   386→    defer logger.Sync() // Flush any buffered logs on exit\n   387→\n   388→    // Component-specific loggers\n   389→    log := logger.Component(\"main\")\n   390→    log.Info(\"Starting BigMeanie trading system\")\n   391→}\n   392→\n   393→// Structured error handling\n   394→func LoadCandles(symbol string, timeframe string) ([]Candle, error) {\n   395→    log := logger.Data()\n   396→\n   397→    candles, err := db.Query(\"SELECT * FROM candles WHERE symbol = ? AND timeframe = ?\", symbol, timeframe)\n   398→    if err != nil {\n   399→        return nil, errors.Wrap(\"LoadCandles\", errors.ErrTypeData, err).\n   400→            WithSymbol(symbol).\n   401→            WithContext(\"timeframe\", timeframe)\n   402→    }\n   403→\n   404→    log.LogDataOperation(\"candles_loaded\", len(candles),\n   405→        \"symbol\", symbol,\n   406→        \"timeframe\", timeframe)\n   407→\n   408→    return candles, nil\n   409→}\n   410→```\n   411→\n   412→### Worker Pool Pattern\n   413→```go\n   414→// Go way: channels ARE the queue\n   415→func RunWorkerPool(ctx context.Context, numWorkers int) {\n   416→    jobs := make(chan Job, 100)\n   417→    results := make(chan Result, 100)\n   418→\n   419→    // Start workers\n   420→    var wg sync.WaitGroup\n   421→    for i := 0; i < numWorkers; i++ {\n   422→        wg.Add(1)\n   423→        go func(id int) {\n   424→            defer wg.Done()\n   425→            runWorker(ctx, id, jobs, results)\n   426→        }(i)\n   427→    }\n   428→\n   429→    // Feed jobs\n   430→    go func() {\n   431→        for _, job := range getAllJobs() {\n   432→            select {\n   433→            case jobs <- job:\n   434→            case <-ctx.Done():\n   435→                return\n   436→            }\n   437→        }\n   438→        close(jobs)\n   439→    }()\n   440→\n   441→    wg.Wait()\n   442→    close(results)\n   443→}\n   444→```\n   445→\n   446→### Options Pattern\n   447→```go\n   448→// Functional options for clean APIs\n   449→type WorkerOption func(*Worker)\n   450→\n   451→func WithRetries(max int) WorkerOption {\n   452→    return func(w *Worker) {\n   453→        w.maxRetries = max\n   454→    }\n   455→}\n   456→\n   457→func WithTimeout(d time.Duration) WorkerOption {\n   458→    return func(w *Worker) {\n   459→        w.timeout = d\n   460→    }\n   461→}\n   462→\n   463→func NewWorker(id string, opts ...WorkerOption) *Worker {\n   464→    // Defaults\n   465→    w := &Worker{\n   466→        id:         id,\n   467→        maxRetries: 3,\n   468→        timeout:    5 * time.Minute,\n   469→    }\n   470→\n   471→    // Apply options\n   472→    for _, opt := range opts {\n   473→        opt(w)\n   474→    }\n   475→\n   476→    return w\n   477→}\n   478→\n   479→// Clean usage\n   480→worker := NewWorker(\"worker-1\",\n   481→    WithRetries(5),\n   482→    WithTimeout(10*time.Minute))\n   483→```\n   484→\n   485→### Table-Driven Tests\n   486→```go\n   487→func TestParameterGeneration(t *testing.T) {\n   488→    tests := []struct {\n   489→        name     string\n   490→        strategy string\n   491→        markets  []string\n   492→        want     int\n   493→        wantErr  bool\n   494→    }{\n   495→        {\n   496→            name:     \"simple strategy\",\n   497→            strategy: \"surfer\",\n   498→            markets:  []string{\"BTC-USD\"},\n   499→            want:     10,\n   500→        },\n   501→        {\n   502→            name:     \"multiple markets\",\n   503→            strategy: \"surfer\",\n   504→            markets:  []string{\"BTC-USD\", \"ETH-USD\"},\n   505→            want:     20,\n   506→        },\n   507→        {\n   508→            name:     \"invalid strategy\",\n   509→            strategy: \"unknown\",\n   510→            wantErr:  true,\n   511→        },\n   512→    }\n   513→\n   514→    for _, tt := range tests {\n   515→        t.Run(tt.name, func(t *testing.T) {\n   516→            got, err := GenerateParameters(tt.strategy, tt.markets)\n   517→            if (err != nil) != tt.wantErr {\n   518→                t.Errorf(\"GenerateParameters() error = %v, wantErr %v\", err, tt.wantErr)\n   519→                return\n   520→            }\n   521→            if len(got) != tt.want {\n   522→                t.Errorf(\"GenerateParameters() returned %d combinations, want %d\", len(got), tt.want)\n   523→            }\n   524→        })\n   525→    }\n   526→}\n   527→```\n   528→\n   529→### Error Handling\n   530→```go\n   531→// Wrap errors with context\n   532→func processJob(job Job) (Result, error) {\n   533→    if err := validateJob(job); err != nil {\n   534→        return Result{}, fmt.Errorf(\"validation failed: %w\", err)\n   535→    }\n   536→\n   537→    data, err := fetchData(job.Symbol, job.Timeframe)\n   538→    if err != nil {\n   539→        return Result{}, fmt.Errorf(\"fetch data for %s: %w\", job.Symbol, err)\n   540→    }\n   541→\n   542→    result, err := runBacktest(data, job.Parameters)\n   543→    if err != nil {\n   544→        return Result{}, fmt.Errorf(\"backtest failed: %w\", err)\n   545→    }\n   546→\n   547→    return result, nil\n   548→}\n   549→\n   550→// Check errors immediately\n   551→if err := processJob(job); err != nil {\n   552→    log.LogError(\"Job failed\", err, \"job_id\", job.ID)\n   553→    return\n   554→}\n   555→```\n   556→\n   557→### Resource Management with Defer\n   558→```go\n   559→func (w *Worker) Execute(ctx context.Context, job Job) error {\n   560→    // Acquire resources\n   561→    conn := dbPool.Get()\n   562→    defer dbPool.Put(conn)  // Always return to pool\n   563→\n   564→    // Create checkpoint\n   565→    checkpoint := newCheckpoint(w.id)\n   566→    defer func() {\n   567→        if err := checkpoint.Save(); err != nil {\n   568→            log.LogError(\"Failed to save checkpoint\", err)\n   569→        }\n   570→    }()\n   571→\n   572→    // Do actual work\n   573→    return w.process(ctx, job)\n   574→}\n   575→```\n   576→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"54dd5727-db10-4563-9d82-fb8f817691ce","timestamp":"2025-08-13T07:46:49.132Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/code/practices-patterns.md","content":"# Go Best Practices\n\n## Overview\n\nGo-specific best practices and patterns following Go idioms and community standards.\n\n### Core Go Principles\n- **Simplicity over abstraction** - Start simple, add complexity only when needed\n- **Channels for communication** - Don't communicate by sharing memory, share memory by communicating\n- **Errors as values** - Return errors, don't panic\n- **Small interfaces** - The bigger the interface, the weaker the abstraction\n- **Composition over inheritance** - Embed types, don't create hierarchies\n- **Context for cancellation** - Pass context.Context for cancellation and timeouts\n\n## Interface Design\n\n### Small, Focused Interfaces\n\nFollow the Go proverb: \"The bigger the interface, the weaker the abstraction.\"\n\n```go\n// ✅ GOOD: Small interfaces are easier to implement and test\ntype PriceProvider interface {\n    GetPrice(symbol string) (decimal.Decimal, error)\n}\n\ntype OrderPlacer interface {\n    PlaceOrder(order *Order) (*OrderResult, error)\n}\n\n// ❌ BAD: Large interface with many responsibilities\ntype TradingService interface {\n    GetPrice(symbol string) (decimal.Decimal, error)\n    PlaceOrder(order *Order) (*OrderResult, error)\n    CancelOrder(id string) error\n    GetOrderStatus(id string) (*OrderStatus, error)\n    GetBalance(currency string) (decimal.Decimal, error)\n    // ... 20 more methods\n}\n```\n\n## Naming Conventions\n\n### Clear Names Without Unnecessary Abbreviations\n\n```go\n// ❌ BAD: Unclear abbreviations\ncfg, mgr, svc, calc, resp, req\n\n// ✅ GOOD: Clear, full names\nconfig, manager, service, calculate, response, request\n\n// Exception: Well-known abbreviations are acceptable\nctx context.Context  // Standard Go abbreviation\ndb *sql.DB          // Widely understood\nerr error           // Go convention\n```\n\n### Function and Method Names\n\n```go\n// Function names should be self-explanatory\nfunc CalculatePositionSize(balance, riskPercentage decimal.Decimal) decimal.Decimal\n\n// Avoid redundant package names in functions\n// ❌ BAD\npackage order\nfunc OrderValidator() // order.OrderValidator is redundant\n\n// ✅ GOOD\npackage order\nfunc Validator() // order.Validator is clear\n```\n\n### Receiver Names\n\nUse single-letter receivers for methods:\n\n```go\n// ✅ GOOD: Single letter that represents the type\nfunc (s *Strategy) Analyze(data MarketData) Signal\nfunc (c *Config) Validate() error\nfunc (o *Order) Execute() error\n\n// ❌ BAD: Long receiver names\nfunc (strategy *Strategy) Analyze(data MarketData) Signal\nfunc (config *Config) Validate() error\n```\n\n## Error Handling\n\n### Always Check Errors\n\nNever ignore errors, even in deferred functions:\n\n```go\n// ❌ BAD: Ignoring error\ndefer file.Close()\n\n// ✅ GOOD: Check error even in defer\ndefer func() {\n    if err := file.Close(); err != nil {\n        log.Printf(\"failed to close file: %v\", err)\n    }\n}()\n```\n\n## Concurrency Patterns\n\n### Don't Communicate by Sharing Memory\n\nFollow Go's concurrency philosophy:\n\n```go\n// ❌ BAD: Shared memory with mutex\ntype Counter struct {\n    mu    sync.Mutex\n    value int\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    c.value++\n    c.mu.Unlock()\n}\n\n// ✅ GOOD: Communicate via channels\ntype Counter struct {\n    inc chan int\n    get chan int\n}\n\nfunc (c *Counter) run() {\n    value := 0\n    for {\n        select {\n        case <-c.inc:\n            value++\n        case c.get <- value:\n        }\n    }\n}\n```\n\n### Context for Cancellation\n\nAlways use context for cancellation and timeouts:\n\n```go\n// ✅ GOOD: Respecting context\nfunc FetchData(ctx context.Context, symbol string) (*Data, error) {\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n\n    resp, err := client.Do(req)\n    // ... handle response\n}\n```\n\n## Resource Management\n\n### Defer Cleanup\n\nAlways defer cleanup immediately after acquiring resources:\n\n```go\n// ✅ GOOD: Immediate defer\nfile, err := os.Open(\"data.txt\")\nif err != nil {\n    return err\n}\ndefer file.Close() // Immediately after successful open\n\n// Process file...\n```\n\n### Check Close Errors\n\nSome Close operations can fail and should be checked:\n\n```go\n// ✅ GOOD: Check close error for writers\nfunc WriteData(filename string, data []byte) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if cerr := file.Close(); cerr != nil && err == nil {\n            err = cerr // Capture close error if no other error\n        }\n    }()\n\n    _, err = file.Write(data)\n    return err\n}\n```\n\n## Testing\n\n### Table-Driven Tests\n\n```go\nfunc TestCalculatePositionSize(t *testing.T) {\n    tests := []struct {\n        name     string\n        balance  decimal.Decimal\n        risk     decimal.Decimal\n        stopLoss decimal.Decimal\n        want     decimal.Decimal\n        wantErr  bool\n    }{\n        {\n            name:     \"valid inputs\",\n            balance:  decimal.NewFromInt(10000),\n            risk:     decimal.NewFromFloat(0.02),\n            stopLoss: decimal.NewFromInt(100),\n            want:     decimal.NewFromInt(200),\n            wantErr:  false,\n        },\n        {\n            name:     \"negative balance\",\n            balance:  decimal.NewFromInt(-1000),\n            risk:     decimal.NewFromFloat(0.02),\n            stopLoss: decimal.NewFromInt(100),\n            want:     decimal.Zero,\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := CalculatePositionSize(tt.balance, tt.risk, tt.stopLoss)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if !got.Equal(tt.want) {\n                t.Errorf(\"got = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\n### Test Naming\n\n```go\n// Test function names should describe what is being tested\nfunc TestCalculatePositionSize_WithValidInputs(t *testing.T)\nfunc TestCalculatePositionSize_WithNegativeBalance(t *testing.T)\nfunc TestCalculatePositionSize_WithZeroStopLoss(t *testing.T)\n```\n\n## Package Design\n\n### Package Names\n\n- Use singular, lowercase names: `order` not `orders`\n- Avoid generic names like `util`, `common`, `helpers`\n- Package name should describe its purpose\n\n### Package Organization\n\n```\ninternal/\n├── trading/          # Domain logic\n│   ├── order.go     # Core types\n│   ├── engine.go    # Business logic\n│   └── order_test.go # Tests next to code\n├── api/             # External integrations\n└── models/          # Data models\n```\n\n## Comments and Documentation\n\n### Package Comments\n\nEvery package should have a package comment:\n\n```go\n// Package trading implements the core trading engine.\n// It provides order execution, position management, and risk controls.\npackage trading\n```\n\n### Exported Functions\n\nDocument all exported functions:\n\n```go\n// CalculatePositionSize determines the appropriate position size based on\n// account balance, risk percentage, and stop loss distance.\n// It returns an error if any input is invalid (negative or zero).\nfunc CalculatePositionSize(balance, riskPct, stopLoss decimal.Decimal) (decimal.Decimal, error) {\n    // Implementation\n}\n```\n\n## Performance\n\n### Preallocate Slices\n\nWhen size is known, preallocate:\n\n```go\n// ❌ BAD: Growing slice\nvar results []Result\nfor _, item := range items {\n    results = append(results, process(item))\n}\n\n// ✅ GOOD: Preallocated\nresults := make([]Result, 0, len(items))\nfor _, item := range items {\n    results = append(results, process(item))\n}\n```\n\n### String Building\n\nUse strings.Builder for concatenation:\n\n```go\n// ❌ BAD: String concatenation in loop\nvar result string\nfor _, s := range strings {\n    result += s\n}\n\n// ✅ GOOD: strings.Builder\nvar builder strings.Builder\nfor _, s := range strings {\n    builder.WriteString(s)\n}\nresult := builder.String()\n```\n\n## Common Pitfalls\n\n### Range Variable Capture\n\n```go\n// ❌ BAD: Captures loop variable\nfor _, item := range items {\n    go func() {\n        process(item) // Bug: all goroutines get last item\n    }()\n}\n\n// ✅ GOOD: Copy variable\nfor _, item := range items {\n    itemCopy := item\n    go func() {\n        process(itemCopy)\n    }()\n}\n```\n\n### Nil Interface Values\n\n```go\n// ❌ BAD: Can cause nil pointer panic\nvar err *MyError\nif condition {\n    err = &MyError{\"something went wrong\"}\n}\nreturn err // Returns non-nil interface with nil value\n\n// ✅ GOOD: Return explicit nil\nif condition {\n    return &MyError{\"something went wrong\"}\n}\nreturn nil\n```\n\n### Logger and Error Framework\n```go\n// Initialize logger at application start\nfunc main() {\n    if err := logger.InitZap(os.Getenv(\"LOG_LEVEL\"), os.Getenv(\"BIGMEANIE_DEV\") == \"true\"); err != nil {\n        panic(fmt.Sprintf(\"failed to initialize logger: %v\", err))\n    }\n    defer logger.Sync() // Flush any buffered logs on exit\n\n    // Component-specific loggers\n    log := logger.Component(\"main\")\n    log.Info(\"Starting BigMeanie trading system\")\n}\n\n// Structured error handling\nfunc LoadCandles(symbol string, timeframe string) ([]Candle, error) {\n    log := logger.Data()\n\n    candles, err := db.Query(\"SELECT * FROM candles WHERE symbol = ? AND timeframe = ?\", symbol, timeframe)\n    if err != nil {\n        return nil, errors.Wrap(\"LoadCandles\", errors.ErrTypeData, err).\n            WithSymbol(symbol).\n            WithContext(\"timeframe\", timeframe)\n    }\n\n    log.LogDataOperation(\"candles_loaded\", len(candles),\n        \"symbol\", symbol,\n        \"timeframe\", timeframe)\n\n    return candles, nil\n}\n```\n\n### Worker Pool Pattern\n```go\n// Go way: channels ARE the queue\nfunc RunWorkerPool(ctx context.Context, numWorkers int) {\n    jobs := make(chan Job, 100)\n    results := make(chan Result, 100)\n\n    // Start workers\n    var wg sync.WaitGroup\n    for i := 0; i < numWorkers; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            runWorker(ctx, id, jobs, results)\n        }(i)\n    }\n\n    // Feed jobs\n    go func() {\n        for _, job := range getAllJobs() {\n            select {\n            case jobs <- job:\n            case <-ctx.Done():\n                return\n            }\n        }\n        close(jobs)\n    }()\n\n    wg.Wait()\n    close(results)\n}\n```\n\n### Options Pattern\n```go\n// Functional options for clean APIs\ntype WorkerOption func(*Worker)\n\nfunc WithRetries(max int) WorkerOption {\n    return func(w *Worker) {\n        w.maxRetries = max\n    }\n}\n\nfunc WithTimeout(d time.Duration) WorkerOption {\n    return func(w *Worker) {\n        w.timeout = d\n    }\n}\n\nfunc NewWorker(id string, opts ...WorkerOption) *Worker {\n    // Defaults\n    w := &Worker{\n        id:         id,\n        maxRetries: 3,\n        timeout:    5 * time.Minute,\n    }\n\n    // Apply options\n    for _, opt := range opts {\n        opt(w)\n    }\n\n    return w\n}\n\n// Clean usage\nworker := NewWorker(\"worker-1\",\n    WithRetries(5),\n    WithTimeout(10*time.Minute))\n```\n\n### Table-Driven Tests\n```go\nfunc TestParameterGeneration(t *testing.T) {\n    tests := []struct {\n        name     string\n        strategy string\n        markets  []string\n        want     int\n        wantErr  bool\n    }{\n        {\n            name:     \"simple strategy\",\n            strategy: \"surfer\",\n            markets:  []string{\"BTC-USD\"},\n            want:     10,\n        },\n        {\n            name:     \"multiple markets\",\n            strategy: \"surfer\",\n            markets:  []string{\"BTC-USD\", \"ETH-USD\"},\n            want:     20,\n        },\n        {\n            name:     \"invalid strategy\",\n            strategy: \"unknown\",\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := GenerateParameters(tt.strategy, tt.markets)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"GenerateParameters() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if len(got) != tt.want {\n                t.Errorf(\"GenerateParameters() returned %d combinations, want %d\", len(got), tt.want)\n            }\n        })\n    }\n}\n```\n\n### Error Handling\n```go\n// Wrap errors with context\nfunc processJob(job Job) (Result, error) {\n    if err := validateJob(job); err != nil {\n        return Result{}, fmt.Errorf(\"validation failed: %w\", err)\n    }\n\n    data, err := fetchData(job.Symbol, job.Timeframe)\n    if err != nil {\n        return Result{}, fmt.Errorf(\"fetch data for %s: %w\", job.Symbol, err)\n    }\n\n    result, err := runBacktest(data, job.Parameters)\n    if err != nil {\n        return Result{}, fmt.Errorf(\"backtest failed: %w\", err)\n    }\n\n    return result, nil\n}\n\n// Check errors immediately\nif err := processJob(job); err != nil {\n    log.LogError(\"Job failed\", err, \"job_id\", job.ID)\n    return\n}\n```\n\n### Resource Management with Defer\n```go\nfunc (w *Worker) Execute(ctx context.Context, job Job) error {\n    // Acquire resources\n    conn := dbPool.Get()\n    defer dbPool.Put(conn)  // Always return to pool\n\n    // Create checkpoint\n    checkpoint := newCheckpoint(w.id)\n    defer func() {\n        if err := checkpoint.Save(); err != nil {\n            log.LogError(\"Failed to save checkpoint\", err)\n        }\n    }()\n\n    // Do actual work\n    return w.process(ctx, job)\n}\n```\n","numLines":576,"startLine":1,"totalLines":576}}}
{"parentUuid":"54dd5727-db10-4563-9d82-fb8f817691ce","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01ENV8soKdGfmjczMk27Lg6B","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now I'll work on creating comprehensive Go documentation. Let me start by marking the first task complete and moving to create the fundamentals documentation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5908,"cache_read_input_tokens":38693,"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CS5LbiY1imi4ov2pF7iCF","type":"assistant","uuid":"215a6fd5-c4ce-4e45-b64c-99901431aaad","timestamp":"2025-08-13T07:46:53.403Z"}
{"parentUuid":"215a6fd5-c4ce-4e45-b64c-99901431aaad","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01ENV8soKdGfmjczMk27Lg6B","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01RkkSBda3xareWT782qKXLK","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed"},{"id":"2","content":"Create comprehensive Go language fundamentals documentation","status":"in_progress"},{"id":"3","content":"Document all Go design patterns and idioms","status":"pending"},{"id":"4","content":"Create advanced Go concurrency documentation","status":"pending"},{"id":"5","content":"Document Go testing and benchmarking practices","status":"pending"},{"id":"6","content":"Create Go performance optimization guide","status":"pending"},{"id":"7","content":"Document Go security best practices","status":"pending"},{"id":"8","content":"Create Go tooling and ecosystem documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5908,"cache_read_input_tokens":38693,"output_tokens":287,"service_tier":"standard"}},"requestId":"req_011CS5LbiY1imi4ov2pF7iCF","type":"assistant","uuid":"9d4bf0f4-fa05-4d03-8626-99e69d792322","timestamp":"2025-08-13T07:46:58.896Z"}
{"parentUuid":"9d4bf0f4-fa05-4d03-8626-99e69d792322","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RkkSBda3xareWT782qKXLK","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"bc00da99-437d-4128-bc05-de50e0208774","timestamp":"2025-08-13T07:46:58.919Z","toolUseResult":{"oldTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"in_progress","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"pending","id":"2"},{"content":"Document all Go design patterns and idioms","status":"pending","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}],"newTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"in_progress","id":"2"},{"content":"Document all Go design patterns and idioms","status":"pending","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}]}}
{"parentUuid":"bc00da99-437d-4128-bc05-de50e0208774","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01WJK85Gj4VS2u8eK3dnEcAQ","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01Axw5cVGUwddoeW4oupS6tJ","name":"WebSearch","input":{"query":"Go programming language 2024 2025 best practices fundamentals types interfaces goroutines channels"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":538,"cache_read_input_tokens":44601,"output_tokens":71,"service_tier":"standard"}},"requestId":"req_011CS5LcTPxtUxsKWoNZ9phm","type":"assistant","uuid":"6e57994d-610a-470a-954b-b1b765b709b1","timestamp":"2025-08-13T07:47:02.613Z"}
{"parentUuid":"6e57994d-610a-470a-954b-b1b765b709b1","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Axw5cVGUwddoeW4oupS6tJ","type":"tool_result","content":"Web search results for query: \"Go programming language 2024 2025 best practices fundamentals types interfaces goroutines channels\"\n\nI'll search for information about Go programming language best practices and fundamentals, including types, interfaces, goroutines, and channels for 2024-2025.\n\nLinks: [{\"title\":\"Effective Go - The Go Programming Language\",\"url\":\"https://go.dev/doc/effective_go\"},{\"title\":\"Go Programming Language (Introduction) - GeeksforGeeks\",\"url\":\"https://www.geeksforgeeks.org/go-language/go-programming-language-introduction/\"},{\"title\":\"Why a Golang Certification is Essential for Developers in 2024\",\"url\":\"https://www.bytesizego.com/blog/golang-certification-2024\"},{\"title\":\"Is Golang Still Growing? Go Language Popularity Trends in 2024 | The Research Blog\",\"url\":\"https://blog.jetbrains.com/research/2025/04/is-golang-still-growing-go-language-popularity-trends-in-2024/\"},{\"title\":\"The Go Programming Language: | Guide books | ACM Digital Library\",\"url\":\"https://dl.acm.org/doi/10.5555/2851099\"},{\"title\":\"Rust vs Go in 2025 — Bitfield Consulting\",\"url\":\"https://bitfieldconsulting.com/posts/rust-vs-go\"},{\"title\":\"The Future of Golang in 2025 [Top Trends and Predictions] - GeeksforGeeks\",\"url\":\"https://www.geeksforgeeks.org/blogs/future-of-golang/\"},{\"title\":\"What Is Go Programming Language and What Is It Used For? | Coursera\",\"url\":\"https://www.coursera.org/articles/go-programming-language\"},{\"title\":\"Go Tutorial - GeeksforGeeks\",\"url\":\"https://www.geeksforgeeks.org/go-language/go/\"},{\"title\":\"What Is the Go Programming Language (Golang)? | Definition from TechTarget\",\"url\":\"https://www.techtarget.com/searchitoperations/definition/Go-programming-language\"}]\n\nBased on the search results, here's a comprehensive overview of Go programming language best practices and fundamentals for 2024-2025:\n\n## Go Programming Language Overview\n\nGo, also known as Golang, is an open-source programming language created by Google in 2007. It was designed to be efficient, easy to learn and to provide support for modern hardware architectures.(no content)Two major versions – Go 1.22 and Go 1.23 – were released in 2024, and Go 1.24 – in February 2025. In November 2024, Go celebrated its fifteenth anniversary.\n\n## Current State and Trends (2024-2025)\n\nIn 2024, there was a change in the leadership of the Go team, but this is no cause for concern. The ideas and goals outlined by the new leaders reflect a deep understanding of the language and its culture, ensuring continuity in the Go development ecosystem.(no content)According to the Developer Ecosystem Data Playground, the mean estimate is that 4.1 million Go professionals used Go within the last 12 months, and 1.8 million used it as one of their primary programming languages. According to the SlashData report for Q1 2024, at the beginning of 2024, there were around 4.7 million Go developers worldwide.\n\n## Core Fundamentals and Types\n\nSyntax and Data Types: Understanding Go's fundamental structure and built-in data types. Control Structures: Mastering conditional statements and loops to manage program flow effectively.(no content)Early chapters cover the structural elements of Go programs: syntax, control flow, data types, and the organization of a program into packages, files, and functions. The examples illustrate many packages from the standard library and show how to create new ones of your own.\n\n## Interfaces\n\nThe chapters on methods and interfaces introduce Gos unconventional approach to object-oriented programming, in which methods can be declared on any type and interfaces are implicitly satisfied. They explain the key principles of encapsulation, composition, and substitutability using realistic examples.\n\n## Goroutines and Concurrency Best Practices\n\n### Goroutines\nThey're called goroutines because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.(no content)Golang has been designed in such a way that instead of using threading it uses Goroutine, which is similar to threading but consumes very less memory. Like threading consumes 1MB whereas Goroutine consumes 2KB of memory, hence at the same time, we can have millions of goroutine triggered.(no content)Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently.\n\n### Channels\nLike maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel.(no content)Unbuffered channels combine communication—the exchange of a value—with synchronization—guaranteeing that two calculations (goroutines) are in a known state.(no content)Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer is full, this means waiting until some receiver has retrieved a value.\n\n## Key Best Practices for 2024-2025\n\n### Concurrency Philosophy\nGo encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan: Do not communicate by sharing memory; instead, share memory by communicating.\n\n### Performance and Scalability\nMost languages have some form of support for concurrent programming (doing multiple things at once), but Go's support is second to none. Instead of using operating system threads, which are relatively clumsy and slow, Go provides a lightweight solution: goroutines. You can run millions of concurrent goroutines in a single program without creating serious performance problems, which makes Go the perfect choice for high-scale concurrent applications such as webservers and microservices.\n\n### Modern Applications\nThe Go team declared their interest in a new problem domain: AI model serving, an emerging area that offers exciting opportunities for Go's adoption. While it remains to be seen whether Go will manage to capture this market segment, the ecosystem is already evolving to address these opportunities. Meanwhile, Go has managed to cement its position in the mainstream cloud market, which continues to grow – particularly with the increasing need to manage cloud-native infrastructureinenterprise environments.\n\n## Key Features and Benefits\n\nGolang has outstanding concurrency support through its goroutines and channels which are lightweight concurrency primitives. This makes the development of highly scalable applications that can accommodate multiple users or requests at once.(no content)Concurrency support: Go's built-in concurrency primitives, such as goroutines and channels, enable efficient and scalable concurrent programming. Fast compilation and execution: Go's compiler produces fast and optimized code, resulting in faster compilation times and efficient execution. Garbage collection: Go features an automatic garbage collector that manages memory, reducing the burden on developers by removing unused memory.\n\nThe search results show that Go continues to be a growing and relevant language in 2024-2025, with strong fundamentals around concurrency, interfaces, and type systems that make it particularly suitable for cloud-native and distributed systems development."}]},"uuid":"07fd7426-2452-4b2e-84cd-b0a563d80a68","timestamp":"2025-08-13T07:47:52.120Z","toolUseResult":{"query":"Go programming language 2024 2025 best practices fundamentals types interfaces goroutines channels","results":["I'll search for information about Go programming language best practices and fundamentals, including types, interfaces, goroutines, and channels for 2024-2025.",{"tool_use_id":"srvtoolu_01AaiA6hjS1sryVmnKQg7DeX","content":[{"title":"Effective Go - The Go Programming Language","url":"https://go.dev/doc/effective_go"},{"title":"Go Programming Language (Introduction) - GeeksforGeeks","url":"https://www.geeksforgeeks.org/go-language/go-programming-language-introduction/"},{"title":"Why a Golang Certification is Essential for Developers in 2024","url":"https://www.bytesizego.com/blog/golang-certification-2024"},{"title":"Is Golang Still Growing? Go Language Popularity Trends in 2024 | The Research Blog","url":"https://blog.jetbrains.com/research/2025/04/is-golang-still-growing-go-language-popularity-trends-in-2024/"},{"title":"The Go Programming Language: | Guide books | ACM Digital Library","url":"https://dl.acm.org/doi/10.5555/2851099"},{"title":"Rust vs Go in 2025 — Bitfield Consulting","url":"https://bitfieldconsulting.com/posts/rust-vs-go"},{"title":"The Future of Golang in 2025 [Top Trends and Predictions] - GeeksforGeeks","url":"https://www.geeksforgeeks.org/blogs/future-of-golang/"},{"title":"What Is Go Programming Language and What Is It Used For? | Coursera","url":"https://www.coursera.org/articles/go-programming-language"},{"title":"Go Tutorial - GeeksforGeeks","url":"https://www.geeksforgeeks.org/go-language/go/"},{"title":"What Is the Go Programming Language (Golang)? | Definition from TechTarget","url":"https://www.techtarget.com/searchitoperations/definition/Go-programming-language"}]},"Based on the search results, here's a comprehensive overview of Go programming language best practices and fundamentals for 2024-2025:\n\n## Go Programming Language Overview\n\nGo, also known as Golang, is an open-source programming language created by Google in 2007. It was designed to be efficient, easy to learn and to provide support for modern hardware architectures.(no content)Two major versions – Go 1.22 and Go 1.23 – were released in 2024, and Go 1.24 – in February 2025. In November 2024, Go celebrated its fifteenth anniversary.\n\n## Current State and Trends (2024-2025)\n\nIn 2024, there was a change in the leadership of the Go team, but this is no cause for concern. The ideas and goals outlined by the new leaders reflect a deep understanding of the language and its culture, ensuring continuity in the Go development ecosystem.(no content)According to the Developer Ecosystem Data Playground, the mean estimate is that 4.1 million Go professionals used Go within the last 12 months, and 1.8 million used it as one of their primary programming languages. According to the SlashData report for Q1 2024, at the beginning of 2024, there were around 4.7 million Go developers worldwide.\n\n## Core Fundamentals and Types\n\nSyntax and Data Types: Understanding Go's fundamental structure and built-in data types. Control Structures: Mastering conditional statements and loops to manage program flow effectively.(no content)Early chapters cover the structural elements of Go programs: syntax, control flow, data types, and the organization of a program into packages, files, and functions. The examples illustrate many packages from the standard library and show how to create new ones of your own.\n\n## Interfaces\n\nThe chapters on methods and interfaces introduce Gos unconventional approach to object-oriented programming, in which methods can be declared on any type and interfaces are implicitly satisfied. They explain the key principles of encapsulation, composition, and substitutability using realistic examples.\n\n## Goroutines and Concurrency Best Practices\n\n### Goroutines\nThey're called goroutines because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.(no content)Golang has been designed in such a way that instead of using threading it uses Goroutine, which is similar to threading but consumes very less memory. Like threading consumes 1MB whereas Goroutine consumes 2KB of memory, hence at the same time, we can have millions of goroutine triggered.(no content)Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently.\n\n### Channels\nLike maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel.(no content)Unbuffered channels combine communication—the exchange of a value—with synchronization—guaranteeing that two calculations (goroutines) are in a known state.(no content)Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer is full, this means waiting until some receiver has retrieved a value.\n\n## Key Best Practices for 2024-2025\n\n### Concurrency Philosophy\nGo encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan: Do not communicate by sharing memory; instead, share memory by communicating.\n\n### Performance and Scalability\nMost languages have some form of support for concurrent programming (doing multiple things at once), but Go's support is second to none. Instead of using operating system threads, which are relatively clumsy and slow, Go provides a lightweight solution: goroutines. You can run millions of concurrent goroutines in a single program without creating serious performance problems, which makes Go the perfect choice for high-scale concurrent applications such as webservers and microservices.\n\n### Modern Applications\nThe Go team declared their interest in a new problem domain: AI model serving, an emerging area that offers exciting opportunities for Go's adoption. While it remains to be seen whether Go will manage to capture this market segment, the ecosystem is already evolving to address these opportunities. Meanwhile, Go has managed to cement its position in the mainstream cloud market, which continues to grow – particularly with the increasing need to manage cloud-native infrastructureinenterprise environments.\n\n## Key Features and Benefits\n\nGolang has outstanding concurrency support through its goroutines and channels which are lightweight concurrency primitives. This makes the development of highly scalable applications that can accommodate multiple users or requests at once.(no content)Concurrency support: Go's built-in concurrency primitives, such as goroutines and channels, enable efficient and scalable concurrent programming. Fast compilation and execution: Go's compiler produces fast and optimized code, resulting in faster compilation times and efficient execution. Garbage collection: Go features an automatic garbage collector that manages memory, reducing the burden on developers by removing unused memory.\n\nThe search results show that Go continues to be a growing and relevant language in 2024-2025, with strong fundamentals around concurrency, interfaces, and type systems that make it particularly suitable for cloud-native and distributed systems development."],"durationSeconds":49.48465686799958}}
{"parentUuid":"07fd7426-2452-4b2e-84cd-b0a563d80a68","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01AweJWR7FtwUpM8WBWmBXe1","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now let me create the comprehensive Go fundamentals documentation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1914,"cache_read_input_tokens":45139,"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CS5LgNdacmUVkxjSGMyTm","type":"assistant","uuid":"dfe21201-3523-4d12-9c58-3d5a673ddc99","timestamp":"2025-08-13T07:47:55.500Z"}
{"parentUuid":"dfe21201-3523-4d12-9c58-3d5a673ddc99","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01AweJWR7FtwUpM8WBWmBXe1","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01NHVtXDtbawrbarV1fiY1Am","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md","content":"# Go Language Fundamentals - Complete Reference\n\n## Table of Contents\n1. [Introduction](#introduction)\n2. [Basic Syntax](#basic-syntax)\n3. [Variables and Constants](#variables-and-constants)\n4. [Data Types](#data-types)\n5. [Control Flow](#control-flow)\n6. [Functions](#functions)\n7. [Methods](#methods)\n8. [Structs](#structs)\n9. [Interfaces](#interfaces)\n10. [Pointers](#pointers)\n11. [Arrays and Slices](#arrays-and-slices)\n12. [Maps](#maps)\n13. [Error Handling](#error-handling)\n14. [Packages and Modules](#packages-and-modules)\n15. [Type Assertions and Type Switches](#type-assertions-and-type-switches)\n16. [Embedding and Composition](#embedding-and-composition)\n17. [Generics](#generics)\n\n## Introduction\n\nGo is a statically typed, compiled language designed for simplicity, efficiency, and reliable software. Created at Google in 2007 by Robert Griesemer, Rob Pike, and Ken Thompson, Go combines the performance of compiled languages with the ease of programming of dynamic languages.\n\n### Core Philosophy\n- **Simplicity**: Less is exponentially more\n- **Readability**: Code is read more often than written\n- **Efficiency**: Fast compilation, fast execution\n- **Concurrency**: Built-in primitives for concurrent programming\n- **Pragmatism**: Solve real problems with practical solutions\n\n## Basic Syntax\n\n### Program Structure\n\nEvery Go program starts with a package declaration and imports:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello, Go!\")\n}\n```\n\n### Comments\n\n```go\n// Single-line comment\n\n/*\n   Multi-line comment\n   Can span multiple lines\n*/\n\n// Package documentation comment (must precede package declaration)\n// Package math provides basic mathematical functions.\npackage math\n\n// Function documentation (must precede function declaration)\n// Add returns the sum of two integers.\nfunc Add(a, b int) int {\n    return a + b\n}\n```\n\n### Naming Conventions\n\n```go\n// Exported (public) - starts with uppercase\ntype Strategy struct{}\nfunc CalculateProfit() {}\nconst MaxRetries = 3\nvar DefaultTimeout = 5 * time.Second\n\n// Unexported (private) - starts with lowercase\ntype position struct{}\nfunc calculateLoss() {}\nconst maxAttempts = 5\nvar defaultBuffer = 1024\n\n// Package names - lowercase, single word\npackage trading  // Good\npackage tradingEngine  // Bad - use trading or engine\n\n// Interface names - typically end with -er\ntype Reader interface{}\ntype Writer interface{}\ntype Closer interface{}\ntype ReadWriteCloser interface{}  // Composition\n\n// Acronyms - keep consistent case\nvar httpClient HTTP  // Bad\nvar HTTPClient HTTP  // Good\nvar xmlParser XML    // Bad\nvar XMLParser XML    // Good\n```\n\n## Variables and Constants\n\n### Variable Declaration\n\n```go\n// var declaration with type\nvar name string\nvar age int\nvar balance float64\n\n// var declaration with initialization\nvar name string = \"John\"\nvar age int = 30\nvar balance = 1000.50  // Type inferred\n\n// Short variable declaration (only inside functions)\nname := \"John\"\nage := 30\nbalance := 1000.50\n\n// Multiple variable declaration\nvar (\n    firstName string = \"John\"\n    lastName  string = \"Doe\"\n    age       int    = 30\n)\n\n// Multiple assignment\nx, y := 10, 20\na, b = b, a  // Swap values\n\n// Blank identifier for unused values\n_, err := someFunction()  // Ignore first return value\n```\n\n### Constants\n\n```go\n// Single constant\nconst Pi = 3.14159\nconst MaxRetries = 3\nconst Message = \"Hello\"\n\n// Typed constants\nconst MaxInt int = 1000\nconst Timeout time.Duration = 5 * time.Second\n\n// Multiple constants\nconst (\n    StatusOK       = 200\n    StatusNotFound = 404\n    StatusError    = 500\n)\n\n// iota - constant generator\nconst (\n    Sunday = iota  // 0\n    Monday         // 1\n    Tuesday        // 2\n    Wednesday      // 3\n    Thursday       // 4\n    Friday         // 5\n    Saturday       // 6\n)\n\n// iota with expressions\nconst (\n    _  = iota             // 0 (ignored)\n    KB = 1 << (10 * iota) // 1024\n    MB                    // 1048576\n    GB                    // 1073741824\n    TB                    // 1099511627776\n)\n\n// Bit flags with iota\nconst (\n    ReadPermission = 1 << iota  // 1\n    WritePermission              // 2\n    ExecutePermission            // 4\n)\n```\n\n## Data Types\n\n### Basic Types\n\n```go\n// Boolean\nvar isActive bool = true\nvar isComplete bool  // Zero value: false\n\n// Integers\nvar i8 int8 = 127                    // -128 to 127\nvar i16 int16 = 32767                // -32768 to 32767\nvar i32 int32 = 2147483647           // -2147483648 to 2147483647\nvar i64 int64 = 9223372036854775807  // -9223372036854775808 to 9223372036854775807\nvar i int = 42                       // Platform dependent (32 or 64 bit)\n\n// Unsigned integers\nvar ui8 uint8 = 255                  // 0 to 255 (byte is alias)\nvar ui16 uint16 = 65535              // 0 to 65535\nvar ui32 uint32 = 4294967295         // 0 to 4294967295\nvar ui64 uint64 = 18446744073709551615  // 0 to 18446744073709551615\nvar ui uint = 42                     // Platform dependent\n\n// Floating point\nvar f32 float32 = 3.14               // IEEE-754 32-bit\nvar f64 float64 = 3.141592653589793  // IEEE-754 64-bit\n\n// Complex numbers\nvar c64 complex64 = 1 + 2i           // float32 real and imaginary\nvar c128 complex128 = 1 + 2i         // float64 real and imaginary\n\n// Strings\nvar str string = \"Hello, Go!\"        // UTF-8 encoded\nvar multiline = `This is\na multiline\nstring`                               // Raw string literal\n\n// Rune (Unicode code point)\nvar r rune = 'A'                     // int32 alias\nvar emoji rune = '😀'\n\n// Byte\nvar b byte = 65                      // uint8 alias\n```\n\n### Type Conversions\n\n```go\n// Explicit type conversion required\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(i)\n\n// String conversions\nimport \"strconv\"\n\n// Int to string\ns := strconv.Itoa(42)\ns := strconv.FormatInt(42, 10)  // base 10\n\n// String to int\ni, err := strconv.Atoi(\"42\")\ni64, err := strconv.ParseInt(\"42\", 10, 64)\n\n// Float to string\ns := strconv.FormatFloat(3.14, 'f', 2, 64)  // 2 decimal places\n\n// String to float\nf, err := strconv.ParseFloat(\"3.14\", 64)\n\n// Type assertions (for interfaces)\nvar x interface{} = \"hello\"\ns := x.(string)  // Panics if x is not string\ns, ok := x.(string)  // Safe assertion with ok check\n```\n\n### Zero Values\n\n```go\n// All types have zero values\nvar b bool        // false\nvar i int         // 0\nvar f float64     // 0.0\nvar s string      // \"\"\nvar p *int        // nil\nvar a []int       // nil\nvar m map[string]int  // nil\nvar c chan int    // nil\nvar fn func()     // nil\nvar iface error   // nil\n```\n\n## Control Flow\n\n### If Statements\n\n```go\n// Basic if\nif x > 0 {\n    fmt.Println(\"Positive\")\n}\n\n// If-else\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else {\n    fmt.Println(\"Non-positive\")\n}\n\n// If-else if-else\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else if x < 0 {\n    fmt.Println(\"Negative\")\n} else {\n    fmt.Println(\"Zero\")\n}\n\n// If with initialization\nif err := doSomething(); err != nil {\n    return err  // err is scoped to if block\n}\n\n// Common patterns\n// Check error immediately\nif err != nil {\n    return fmt.Errorf(\"failed to process: %w\", err)\n}\n\n// Check boolean\nif !isValid {\n    return errors.New(\"invalid input\")\n}\n\n// Check nil\nif data == nil {\n    return errors.New(\"data is nil\")\n}\n```\n\n### Switch Statements\n\n```go\n// Basic switch\nswitch day {\ncase \"Monday\":\n    fmt.Println(\"Start of work week\")\ncase \"Friday\":\n    fmt.Println(\"TGIF!\")\ncase \"Saturday\", \"Sunday\":\n    fmt.Println(\"Weekend!\")\ndefault:\n    fmt.Println(\"Midweek\")\n}\n\n// Switch with no expression (like if-else chain)\nswitch {\ncase x < 0:\n    fmt.Println(\"Negative\")\ncase x == 0:\n    fmt.Println(\"Zero\")\ncase x > 0:\n    fmt.Println(\"Positive\")\n}\n\n// Switch with initialization\nswitch os := runtime.GOOS; os {\ncase \"darwin\":\n    fmt.Println(\"macOS\")\ncase \"linux\":\n    fmt.Println(\"Linux\")\ndefault:\n    fmt.Printf(\"Unknown OS: %s\\n\", os)\n}\n\n// Type switch\nfunc describe(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"Boolean: %t\\n\", v)\n    case nil:\n        fmt.Println(\"nil value\")\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\n// Fallthrough (rarely used)\nswitch num {\ncase 1:\n    fmt.Println(\"One\")\n    fallthrough  // Continue to next case\ncase 2:\n    fmt.Println(\"One or Two\")\n}\n```\n\n### Loops\n\n```go\n// For loop - traditional\nfor i := 0; i < 10; i++ {\n    fmt.Println(i)\n}\n\n// For loop - while style\ncount := 0\nfor count < 10 {\n    fmt.Println(count)\n    count++\n}\n\n// Infinite loop\nfor {\n    // Break or return to exit\n    if condition {\n        break\n    }\n}\n\n// Range over slice\nnumbers := []int{1, 2, 3, 4, 5}\nfor index, value := range numbers {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n\n// Range over slice - values only\nfor _, value := range numbers {\n    fmt.Println(value)\n}\n\n// Range over slice - indices only\nfor index := range numbers {\n    fmt.Println(index)\n}\n\n// Range over map\nages := map[string]int{\"Alice\": 30, \"Bob\": 25}\nfor name, age := range ages {\n    fmt.Printf(\"%s is %d years old\\n\", name, age)\n}\n\n// Range over string (gives runes)\nfor index, runeValue := range \"Hello, 世界\" {\n    fmt.Printf(\"%d: %c\\n\", index, runeValue)\n}\n\n// Range over channel\nch := make(chan int)\ngo func() {\n    for i := 0; i < 5; i++ {\n        ch <- i\n    }\n    close(ch)\n}()\nfor value := range ch {\n    fmt.Println(value)\n}\n\n// Continue and break with labels\nouter:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        if i == 1 && j == 1 {\n            break outer  // Break outer loop\n        }\n        fmt.Printf(\"(%d, %d) \", i, j)\n    }\n}\n```\n\n### Defer, Panic, and Recover\n\n```go\n// Defer - executes when function returns\nfunc readFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()  // Executed when function returns\n    \n    // Read file...\n    return nil\n}\n\n// Multiple defers - LIFO order\nfunc example() {\n    defer fmt.Println(\"Third\")\n    defer fmt.Println(\"Second\")\n    defer fmt.Println(\"First\")\n    // Prints: First, Second, Third\n}\n\n// Defer with arguments - evaluated immediately\nfunc deferArgs() {\n    i := 0\n    defer fmt.Println(i)  // Prints 0, not 1\n    i++\n}\n\n// Defer with closure - captures variables\nfunc deferClosure() {\n    i := 0\n    defer func() {\n        fmt.Println(i)  // Prints 1\n    }()\n    i++\n}\n\n// Panic - runtime error\nfunc divide(a, b int) int {\n    if b == 0 {\n        panic(\"division by zero\")\n    }\n    return a / b\n}\n\n// Recover - catch panic\nfunc safeFunction() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Recovered from panic: %v\\n\", r)\n        }\n    }()\n    \n    // Code that might panic\n    panic(\"something went wrong\")\n}\n\n// Practical error recovery pattern\nfunc robustFunction() (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    \n    // Potentially panicking code\n    return nil\n}\n```\n\n## Functions\n\n### Function Declaration\n\n```go\n// Basic function\nfunc greet() {\n    fmt.Println(\"Hello!\")\n}\n\n// Function with parameters\nfunc add(a int, b int) int {\n    return a + b\n}\n\n// Shorthand for same type parameters\nfunc add(a, b int) int {\n    return a + b\n}\n\n// Multiple return values\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// Named return values\nfunc getCoordinates() (x, y int) {\n    x = 10\n    y = 20\n    return  // Naked return\n}\n\n// Named returns with explicit values\nfunc calculate(a, b int) (sum, product int) {\n    sum = a + b\n    product = a * b\n    return sum, product  // Can be explicit\n}\n\n// Variadic functions\nfunc sum(numbers ...int) int {\n    total := 0\n    for _, n := range numbers {\n        total += n\n    }\n    return total\n}\n\n// Calling variadic functions\nresult := sum(1, 2, 3, 4, 5)\nnums := []int{1, 2, 3}\nresult := sum(nums...)  // Spread slice\n```\n\n### Function Types and Values\n\n```go\n// Function as type\ntype Operation func(int, int) int\n\nfunc add(a, b int) int { return a + b }\nfunc multiply(a, b int) int { return a * b }\n\nvar op Operation = add\nresult := op(5, 3)  // 8\n\n// Function as parameter\nfunc apply(op Operation, a, b int) int {\n    return op(a, b)\n}\n\nresult := apply(add, 5, 3)\nresult = apply(multiply, 5, 3)\n\n// Function returning function\nfunc makeAdder(x int) func(int) int {\n    return func(y int) int {\n        return x + y\n    }\n}\n\nadd5 := makeAdder(5)\nresult := add5(3)  // 8\n\n// Anonymous functions\nfunc() {\n    fmt.Println(\"Anonymous function\")\n}()  // Immediately invoked\n\n// Assign to variable\ngreet := func(name string) {\n    fmt.Printf(\"Hello, %s!\\n\", name)\n}\ngreet(\"World\")\n```\n\n### Closures\n\n```go\n// Closure captures variables\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nc := counter()\nfmt.Println(c())  // 1\nfmt.Println(c())  // 2\nfmt.Println(c())  // 3\n\n// Closure in loop (common pitfall)\n// Wrong way\nfuncs := []func(){}\nfor i := 0; i < 3; i++ {\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // All print 3\n    })\n}\n\n// Correct way\nfor i := 0; i < 3; i++ {\n    i := i  // Shadow variable\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // Prints 0, 1, 2\n    })\n}\n\n// Alternative correct way\nfor i := 0; i < 3; i++ {\n    func(n int) {\n        funcs = append(funcs, func() {\n            fmt.Println(n)\n        })\n    }(i)\n}\n```\n\n## Methods\n\n### Method Declaration\n\n```go\n// Method on struct\ntype Rectangle struct {\n    Width, Height float64\n}\n\n// Value receiver\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\n// Pointer receiver\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n\n// Using methods\nrect := Rectangle{Width: 10, Height: 5}\narea := rect.Area()        // 50\nrect.Scale(2)              // Width=20, Height=10\n\n// Method on non-struct types\ntype MyInt int\n\nfunc (m MyInt) IsEven() bool {\n    return m%2 == 0\n}\n\nvar num MyInt = 42\nif num.IsEven() {\n    fmt.Println(\"Even number\")\n}\n\n// Method on pointer vs value\ntype Counter struct {\n    value int\n}\n\n// Value receiver - cannot modify\nfunc (c Counter) GetValue() int {\n    return c.value\n}\n\n// Pointer receiver - can modify\nfunc (c *Counter) Increment() {\n    c.value++\n}\n\n// Pointer receiver - can handle nil\nfunc (c *Counter) SafeIncrement() {\n    if c == nil {\n        return\n    }\n    c.value++\n}\n```\n\n### Method Sets\n\n```go\n// Method set rules:\n// - Type T has method set of all methods with receiver T\n// - Type *T has method set of all methods with receiver T or *T\n\ntype Shape struct {\n    Name string\n}\n\nfunc (s Shape) GetName() string {\n    return s.Name\n}\n\nfunc (s *Shape) SetName(name string) {\n    s.Name = name\n}\n\n// Value type can call value receiver methods\nshape := Shape{Name: \"Circle\"}\nname := shape.GetName()  // OK\n\n// Value type automatically gets address for pointer receiver\nshape.SetName(\"Square\")  // OK (Go converts to (&shape).SetName())\n\n// Pointer type can call both\nshapePtr := &Shape{Name: \"Triangle\"}\nname = shapePtr.GetName()  // OK\nshapePtr.SetName(\"Pentagon\")  // OK\n```\n\n## Structs\n\n### Struct Declaration and Usage\n\n```go\n// Basic struct\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n}\n\n// Creating structs\np1 := Person{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Age:       30,\n}\n\n// Positional initialization (not recommended)\np2 := Person{\"Jane\", \"Doe\", 25}\n\n// Zero value struct\nvar p3 Person  // All fields have zero values\n\n// Accessing fields\nfmt.Println(p1.FirstName)\np1.Age = 31\n\n// Struct pointer\nptr := &Person{FirstName: \"Bob\"}\nptr.Age = 40  // Automatic dereferencing\n\n// Anonymous struct\npoint := struct {\n    X, Y int\n}{X: 10, Y: 20}\n\n// Struct tags\ntype User struct {\n    ID        int    `json:\"id\" db:\"user_id\"`\n    Email     string `json:\"email\" validate:\"required,email\"`\n    Password  string `json:\"-\"`  // Omit from JSON\n    CreatedAt time.Time `json:\"created_at,omitempty\"`\n}\n\n// Accessing tags via reflection\nimport \"reflect\"\n\nt := reflect.TypeOf(User{})\nfield, _ := t.FieldByName(\"Email\")\nfmt.Println(field.Tag.Get(\"json\"))     // \"email\"\nfmt.Println(field.Tag.Get(\"validate\")) // \"required,email\"\n```\n\n### Struct Embedding\n\n```go\n// Embedding for composition\ntype Address struct {\n    Street  string\n    City    string\n    Country string\n}\n\ntype Employee struct {\n    Person  // Embedded struct\n    Address // Another embedded struct\n    Salary  float64\n}\n\nemp := Employee{\n    Person: Person{\n        FirstName: \"Alice\",\n        LastName:  \"Smith\",\n        Age:       28,\n    },\n    Address: Address{\n        City:    \"New York\",\n        Country: \"USA\",\n    },\n    Salary: 75000,\n}\n\n// Promoted fields\nfmt.Println(emp.FirstName)  // Promoted from Person\nfmt.Println(emp.City)       // Promoted from Address\n\n// Explicit access\nfmt.Println(emp.Person.FirstName)\n\n// Method promotion\ntype Writer struct{}\n\nfunc (w Writer) Write(data []byte) (int, error) {\n    return len(data), nil\n}\n\ntype Logger struct {\n    Writer  // Embedded\n    prefix string\n}\n\nlog := Logger{prefix: \"[INFO]\"}\nlog.Write([]byte(\"message\"))  // Promoted method\n```\n\n### Struct Comparison\n\n```go\n// Structs are comparable if all fields are comparable\ntype Point struct {\n    X, Y int\n}\n\np1 := Point{1, 2}\np2 := Point{1, 2}\np3 := Point{2, 3}\n\nfmt.Println(p1 == p2)  // true\nfmt.Println(p1 == p3)  // false\n\n// Non-comparable structs (contain slices, maps, functions)\ntype Data struct {\n    Values []int  // Slices are not comparable\n}\n\n// This won't compile:\n// d1 := Data{Values: []int{1, 2}}\n// d2 := Data{Values: []int{1, 2}}\n// fmt.Println(d1 == d2)  // Compile error\n```\n\n## Interfaces\n\n### Interface Declaration and Implementation\n\n```go\n// Interface declaration\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\n// Interface with multiple methods\ntype ReadWriter interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n}\n\n// Empty interface (any type)\ntype Any interface{}  // Pre Go 1.18\ntype Any = any        // Go 1.18+\n\n// Implicit implementation\ntype FileWriter struct {\n    filename string\n}\n\nfunc (f FileWriter) Write(data []byte) (int, error) {\n    // Implementation\n    return len(data), nil\n}\n\n// FileWriter implements Writer implicitly\nvar w Writer = FileWriter{filename: \"test.txt\"}\n```\n\n### Interface Composition\n\n```go\n// Composing interfaces\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Composed interface\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Alternative inline composition\ntype ReadWriter interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n}\n```\n\n### Interface Values and nil\n\n```go\n// Interface values have two components: type and value\nvar w Writer\nfmt.Printf(\"Type: %T, Value: %v\\n\", w, w)  // Type: <nil>, Value: <nil>\n\n// nil interface vs interface with nil value\ntype MyWriter struct{}\n\nfunc (m *MyWriter) Write(data []byte) (int, error) {\n    if m == nil {\n        return 0, errors.New(\"nil writer\")\n    }\n    return len(data), nil\n}\n\nvar mw *MyWriter = nil\nvar w Writer = mw\n// w is not nil (has type *MyWriter), but its value is nil\n\nif w == nil {\n    fmt.Println(\"w is nil\")  // Won't print\n}\n\n// Check for nil value\nif mw == nil {\n    fmt.Println(\"mw is nil\")  // Will print\n}\n```\n\n### Type Assertions and Type Switches\n\n```go\n// Type assertion\nvar i interface{} = \"hello\"\n\n// Direct assertion (panics if wrong type)\ns := i.(string)\nfmt.Println(s)\n\n// Safe assertion with comma-ok\ns, ok := i.(string)\nif ok {\n    fmt.Println(\"String:\", s)\n}\n\n// Check interface implementation\nvar w io.Writer = &bytes.Buffer{}\nif buf, ok := w.(*bytes.Buffer); ok {\n    fmt.Println(\"It's a buffer:\", buf)\n}\n\n// Type switch\nfunc describe(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case io.Reader:\n        fmt.Println(\"It's a reader\")\n    case nil:\n        fmt.Println(\"It's nil\")\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n```\n\n### Common Interface Patterns\n\n```go\n// Stringer interface\ntype Stringer interface {\n    String() string\n}\n\ntype Point struct {\n    X, Y int\n}\n\nfunc (p Point) String() string {\n    return fmt.Sprintf(\"(%d, %d)\", p.X, p.Y)\n}\n\n// Error interface\ntype error interface {\n    Error() string\n}\n\ntype ValidationError struct {\n    Field string\n    Value string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for field %s: %s\", e.Field, e.Value)\n}\n\n// Sort interface\ntype Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\n// Custom sort implementation\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n\n// Usage\npeople := []Person{{Name: \"Alice\", Age: 30}, {Name: \"Bob\", Age: 25}}\nsort.Sort(ByAge(people))\n```\n\n## Pointers\n\n### Pointer Basics\n\n```go\n// Declare pointer\nvar p *int\n\n// Get address of variable\nx := 42\np = &x\n\n// Dereference pointer\nfmt.Println(*p)  // 42\n*p = 100\nfmt.Println(x)   // 100\n\n// Pointer zero value is nil\nvar ptr *string\nif ptr == nil {\n    fmt.Println(\"ptr is nil\")\n}\n\n// New function allocates memory\nptr = new(string)\n*ptr = \"Hello\"\n\n// Pointer to struct\ntype Person struct {\n    Name string\n    Age  int\n}\n\nperson := &Person{Name: \"Alice\", Age: 30}\nperson.Age = 31  // Automatic dereferencing\n\n// Pointer arithmetic is NOT allowed in Go\n// p++  // This won't compile\n```\n\n### Pointers vs Values\n\n```go\n// Pass by value\nfunc modifyValue(x int) {\n    x = 100  // Doesn't affect original\n}\n\n// Pass by pointer\nfunc modifyPointer(x *int) {\n    *x = 100  // Modifies original\n}\n\nvalue := 42\nmodifyValue(value)\nfmt.Println(value)  // Still 42\n\nmodifyPointer(&value)\nfmt.Println(value)  // Now 100\n\n// Slices, maps, channels are reference types\nfunc modifySlice(s []int) {\n    s[0] = 100  // Modifies original\n}\n\nslice := []int{1, 2, 3}\nmodifySlice(slice)\nfmt.Println(slice)  // [100, 2, 3]\n\n// But reassigning doesn't affect original\nfunc reassignSlice(s []int) {\n    s = []int{4, 5, 6}  // Doesn't affect original\n}\n\n// To modify slice itself, use pointer\nfunc replaceSlice(s *[]int) {\n    *s = []int{4, 5, 6}\n}\n```\n\n## Arrays and Slices\n\n### Arrays\n\n```go\n// Array declaration\nvar arr [5]int              // [0 0 0 0 0]\narr[0] = 10\narr[4] = 50\n\n// Array initialization\narr := [5]int{1, 2, 3, 4, 5}\narr := [...]int{1, 2, 3}    // Compiler counts elements\narr := [5]int{0: 10, 4: 50} // Index:value pairs\n\n// Arrays are values (copied on assignment)\narr1 := [3]int{1, 2, 3}\narr2 := arr1\narr2[0] = 100\nfmt.Println(arr1)  // [1 2 3] - unchanged\nfmt.Println(arr2)  // [100 2 3]\n\n// Array size is part of type\nvar a [5]int\nvar b [10]int\n// a = b  // Won't compile - different types\n\n// Multidimensional arrays\nvar matrix [3][3]int\nmatrix[1][1] = 5\n\n// Array iteration\nfor i := 0; i < len(arr); i++ {\n    fmt.Println(arr[i])\n}\n\nfor index, value := range arr {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n```\n\n### Slices\n\n```go\n// Slice declaration\nvar slice []int            // nil slice\nslice = []int{}           // Empty slice\nslice = []int{1, 2, 3}    // Initialized slice\n\n// Make function\nslice = make([]int, 5)    // Length 5, capacity 5\nslice = make([]int, 5, 10) // Length 5, capacity 10\n\n// Slice from array\narr := [5]int{1, 2, 3, 4, 5}\nslice = arr[1:4]  // [2 3 4]\nslice = arr[:3]   // [1 2 3]\nslice = arr[2:]   // [3 4 5]\nslice = arr[:]    // [1 2 3 4 5]\n\n// Slice properties\nfmt.Println(len(slice))  // Length\nfmt.Println(cap(slice))  // Capacity\n\n// Append\nslice = []int{1, 2, 3}\nslice = append(slice, 4)\nslice = append(slice, 5, 6, 7)\nslice = append(slice, []int{8, 9}...)\n\n// Copy\nsrc := []int{1, 2, 3}\ndst := make([]int, len(src))\nn := copy(dst, src)  // Returns number copied\n\n// Slice tricks\n// Remove element at index i\nslice = append(slice[:i], slice[i+1:]...)\n\n// Insert element at index i\nslice = append(slice[:i], append([]int{x}, slice[i:]...)...)\n\n// Pop from end\nx := slice[len(slice)-1]\nslice = slice[:len(slice)-1]\n\n// Push to front\nslice = append([]int{x}, slice...)\n\n// Filter in place\nn := 0\nfor _, x := range slice {\n    if keepElement(x) {\n        slice[n] = x\n        n++\n    }\n}\nslice = slice[:n]\n```\n\n### Slice Internals\n\n```go\n// Slice header (conceptual)\ntype SliceHeader struct {\n    Data uintptr  // Pointer to underlying array\n    Len  int      // Current length\n    Cap  int      // Capacity\n}\n\n// Slices share underlying array\noriginal := []int{1, 2, 3, 4, 5}\nslice1 := original[1:4]  // [2 3 4]\nslice2 := original[2:5]  // [3 4 5]\n\nslice1[1] = 100  // Modifies shared array\nfmt.Println(slice2)  // [100 4 5]\n\n// Full slice expression controls capacity\nslice := original[1:3:4]  // [low:high:max]\n// len = high - low = 2\n// cap = max - low = 3\n\n// nil vs empty slice\nvar nilSlice []int        // nil\nemptySlice := []int{}     // Not nil, but empty\nmadeSlice := make([]int, 0) // Not nil, but empty\n\nfmt.Println(nilSlice == nil)    // true\nfmt.Println(emptySlice == nil)  // false\nfmt.Println(len(nilSlice))      // 0\nfmt.Println(len(emptySlice))    // 0\n\n// Both work with append\nnilSlice = append(nilSlice, 1)\nemptySlice = append(emptySlice, 1)\n```\n\n## Maps\n\n### Map Basics\n\n```go\n// Map declaration\nvar m map[string]int      // nil map\nm = make(map[string]int)  // Initialize\n\n// Map literal\nm = map[string]int{\n    \"Alice\": 30,\n    \"Bob\":   25,\n}\n\n// Operations\nm[\"Charlie\"] = 35         // Insert/Update\nage := m[\"Alice\"]         // Retrieve\ndelete(m, \"Bob\")          // Delete\n\n// Check if key exists\nage, exists := m[\"David\"]\nif exists {\n    fmt.Printf(\"David is %d years old\\n\", age)\n}\n\n// Zero value for missing key\nfmt.Println(m[\"Unknown\"])  // 0 (zero value for int)\n\n// Iteration (order is random)\nfor key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Keys only\nfor key := range m {\n    fmt.Println(key)\n}\n\n// Values only\nfor _, value := range m {\n    fmt.Println(value)\n}\n```\n\n### Map Patterns\n\n```go\n// Map as set\nset := make(map[string]bool)\nset[\"apple\"] = true\nset[\"banana\"] = true\n\nif set[\"apple\"] {\n    fmt.Println(\"apple is in the set\")\n}\n\n// Alternative set using empty struct (memory efficient)\ntype void struct{}\nvar member void\n\nset := make(map[string]void)\nset[\"apple\"] = member\nset[\"banana\"] = member\n\nif _, exists := set[\"apple\"]; exists {\n    fmt.Println(\"apple is in the set\")\n}\n\n// Counting with maps\ncounts := make(map[string]int)\nwords := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"}\n\nfor _, word := range words {\n    counts[word]++  // Works even if key doesn't exist\n}\n\n// Grouping with maps\ntype Person struct {\n    Name string\n    Age  int\n}\n\npeople := []Person{\n    {\"Alice\", 30},\n    {\"Bob\", 25},\n    {\"Charlie\", 30},\n    {\"David\", 25},\n}\n\nageGroups := make(map[int][]Person)\nfor _, person := range people {\n    ageGroups[person.Age] = append(ageGroups[person.Age], person)\n}\n\n// Map of maps\nnested := make(map[string]map[string]int)\nnested[\"scores\"] = make(map[string]int)\nnested[\"scores\"][\"Alice\"] = 95\nnested[\"scores\"][\"Bob\"] = 87\n\n// Safe nested access\nif scores, ok := nested[\"scores\"]; ok {\n    if score, ok := scores[\"Alice\"]; ok {\n        fmt.Printf(\"Alice's score: %d\\n\", score)\n    }\n}\n```\n\n### Maps and Concurrency\n\n```go\n// Maps are not safe for concurrent access\n// Use sync.Map or mutex\n\nimport \"sync\"\n\n// With mutex\ntype SafeMap struct {\n    mu sync.RWMutex\n    m  map[string]int\n}\n\nfunc (sm *SafeMap) Set(key string, value int) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    sm.m[key] = value\n}\n\nfunc (sm *SafeMap) Get(key string) (int, bool) {\n    sm.mu.RLock()\n    defer sm.mu.RUnlock()\n    value, exists := sm.m[key]\n    return value, exists\n}\n\n// Using sync.Map (for specific use cases)\nvar m sync.Map\n\n// Store\nm.Store(\"key\", \"value\")\n\n// Load\nvalue, ok := m.Load(\"key\")\n\n// LoadOrStore\nactual, loaded := m.LoadOrStore(\"key\", \"new-value\")\n\n// Delete\nm.Delete(\"key\")\n\n// Range\nm.Range(func(key, value interface{}) bool {\n    fmt.Printf(\"%v: %v\\n\", key, value)\n    return true  // Continue iteration\n})\n```\n\n## Error Handling\n\n### Error Interface\n\n```go\n// Error interface\ntype error interface {\n    Error() string\n}\n\n// Creating errors\nimport \"errors\"\n\nerr := errors.New(\"something went wrong\")\nerr := fmt.Errorf(\"failed to process %s: %v\", filename, originalErr)\n\n// Custom error types\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Msg   string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error: field=%s value=%v msg=%s\", \n        e.Field, e.Value, e.Msg)\n}\n\n// Sentinel errors\nvar (\n    ErrNotFound   = errors.New(\"not found\")\n    ErrPermission = errors.New(\"permission denied\")\n    ErrTimeout    = errors.New(\"operation timed out\")\n)\n\n// Error wrapping (Go 1.13+)\noriginalErr := errors.New(\"original error\")\nwrappedErr := fmt.Errorf(\"wrapped: %w\", originalErr)\n\n// Unwrap errors\nif errors.Is(wrappedErr, originalErr) {\n    fmt.Println(\"Error is originalErr\")\n}\n\nvar validationErr ValidationError\nif errors.As(wrappedErr, &validationErr) {\n    fmt.Printf(\"Validation error: %s\\n\", validationErr.Field)\n}\n```\n\n### Error Handling Patterns\n\n```go\n// Immediate error checking\nresult, err := doSomething()\nif err != nil {\n    return fmt.Errorf(\"doSomething failed: %w\", err)\n}\n\n// Multiple error sources\nfunc processFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return fmt.Errorf(\"open file: %w\", err)\n    }\n    defer file.Close()\n    \n    data, err := io.ReadAll(file)\n    if err != nil {\n        return fmt.Errorf(\"read file: %w\", err)\n    }\n    \n    if err := processData(data); err != nil {\n        return fmt.Errorf(\"process data: %w\", err)\n    }\n    \n    return nil\n}\n\n// Error accumulation\nvar errs []error\n\nfor _, item := range items {\n    if err := process(item); err != nil {\n        errs = append(errs, err)\n    }\n}\n\nif len(errs) > 0 {\n    return fmt.Errorf(\"processing failed with %d errors\", len(errs))\n}\n\n// Retry pattern\nfunc retryOperation(maxAttempts int) error {\n    var lastErr error\n    \n    for i := 0; i < maxAttempts; i++ {\n        if err := attemptOperation(); err != nil {\n            lastErr = err\n            time.Sleep(time.Second * time.Duration(i+1))\n            continue\n        }\n        return nil  // Success\n    }\n    \n    return fmt.Errorf(\"failed after %d attempts: %w\", maxAttempts, lastErr)\n}\n\n// Cleanup on error\nfunc createResources() (err error) {\n    resource1, err := createResource1()\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if err != nil {\n            resource1.Cleanup()\n        }\n    }()\n    \n    resource2, err := createResource2()\n    if err != nil {\n        return err  // resource1 cleaned up by defer\n    }\n    \n    return nil\n}\n```\n\n## Packages and Modules\n\n### Package Organization\n\n```go\n// Package declaration (first non-comment line)\npackage mypackage\n\n// Package documentation\n// Package mypackage provides utilities for data processing.\n// It includes functions for parsing, validation, and transformation.\npackage mypackage\n\n// Import statements\nimport (\n    \"fmt\"           // Standard library\n    \"time\"\n    \n    \"github.com/pkg/errors\"  // External packages\n    \n    \"myproject/internal/utils\"  // Internal packages\n)\n\n// Import aliasing\nimport (\n    \"context\"\n    stdlog \"log\"  // Alias to avoid conflicts\n    . \"math\"      // Dot import (use sparingly)\n    _ \"image/png\" // Import for side effects only\n)\n\n// Package initialization\nfunc init() {\n    // Runs when package is imported\n    // Can have multiple init functions\n    fmt.Println(\"Package initialized\")\n}\n\n// Exported (public) - uppercase\nfunc PublicFunction() {}\ntype PublicType struct{}\nconst PublicConst = 42\nvar PublicVar = \"hello\"\n\n// Unexported (private) - lowercase\nfunc privateFunction() {}\ntype privateType struct{}\nconst privateConst = 42\nvar privateVar = \"hello\"\n```\n\n### Module Management\n\n```bash\n# Initialize module\ngo mod init github.com/username/projectname\n\n# Add dependencies\ngo get github.com/pkg/errors\ngo get github.com/stretchr/testify@v1.8.0\n\n# Update dependencies\ngo get -u ./...              # Update all\ngo get -u github.com/pkg/errors  # Update specific\n\n# Clean up\ngo mod tidy  # Remove unused dependencies\n\n# Vendor dependencies\ngo mod vendor  # Copy dependencies to vendor/\n\n# Module directives in go.mod\nmodule github.com/username/project\n\ngo 1.21\n\nrequire (\n    github.com/pkg/errors v0.9.1\n    github.com/stretchr/testify v1.8.0\n)\n\nreplace github.com/old/package => github.com/new/package v1.0.0\n\nexclude github.com/bad/package v1.0.0\n```\n\n### Internal Packages\n\n```go\n// Internal packages can only be imported by nearby code\nmyproject/\n├── cmd/\n│   └── app/\n│       └── main.go  // Can import internal/\n├── internal/\n│   ├── database/    // Only accessible within myproject\n│   └── utils/\n├── pkg/             // Public packages\n│   └── api/\n└── go.mod\n\n// This import works in myproject\nimport \"myproject/internal/database\"\n\n// This import fails outside myproject\nimport \"github.com/other/project/internal/database\"  // Error\n```\n\n## Type Assertions and Type Switches\n\n### Type Assertions\n\n```go\n// Basic type assertion\nvar i interface{} = \"hello\"\ns := i.(string)  // Panics if not string\nfmt.Println(s)\n\n// Safe type assertion\ns, ok := i.(string)\nif !ok {\n    fmt.Println(\"Not a string\")\n}\n\n// Common patterns\nfunc processValue(v interface{}) {\n    // Try multiple types\n    switch value := v.(type) {\n    case string:\n        fmt.Printf(\"String: %s\\n\", value)\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", value)\n    case []byte:\n        fmt.Printf(\"Bytes: %s\\n\", string(value))\n    default:\n        fmt.Printf(\"Unknown: %T\\n\", value)\n    }\n}\n\n// Check for interface implementation\ntype Stringer interface {\n    String() string\n}\n\nfunc toString(v interface{}) string {\n    if s, ok := v.(Stringer); ok {\n        return s.String()\n    }\n    return fmt.Sprintf(\"%v\", v)\n}\n\n// Nil interface gotcha\nvar p *Person  // nil pointer\nvar i interface{} = p\n\nif i == nil {\n    fmt.Println(\"i is nil\")  // Won't print!\n}\n\nif p == nil {\n    fmt.Println(\"p is nil\")  // Will print\n}\n```\n\n## Embedding and Composition\n\n### Struct Embedding\n\n```go\n// Base types\ntype Person struct {\n    Name string\n    Age  int\n}\n\ntype Address struct {\n    Street string\n    City   string\n}\n\n// Embedding\ntype Employee struct {\n    Person      // Anonymous field\n    Address     // Another anonymous field\n    Department string\n    Salary     float64\n}\n\nemp := Employee{\n    Person:     Person{Name: \"Alice\", Age: 30},\n    Address:    Address{City: \"New York\"},\n    Department: \"Engineering\",\n}\n\n// Field promotion\nfmt.Println(emp.Name)  // Accessed directly\nfmt.Println(emp.City)\n\n// Method promotion\nfunc (p Person) Introduce() {\n    fmt.Printf(\"Hi, I'm %s\\n\", p.Name)\n}\n\nemp.Introduce()  // Method promoted from Person\n\n// Shadowing\ntype Manager struct {\n    Employee\n    Name string  // Shadows Person.Name\n}\n\nmgr := Manager{\n    Employee: emp,\n    Name:     \"Manager Name\",  // This shadows Employee.Person.Name\n}\n\nfmt.Println(mgr.Name)              // \"Manager Name\"\nfmt.Println(mgr.Employee.Name)     // \"Alice\"\nfmt.Println(mgr.Employee.Person.Name)  // \"Alice\"\n```\n\n### Interface Embedding\n\n```go\n// Base interfaces\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Embedded interfaces\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Alternative syntax\ntype ReadWriteCloser interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n    Close() error\n}\n\n// Implementation\ntype File struct {\n    // fields\n}\n\nfunc (f *File) Read(p []byte) (int, error) {\n    // implementation\n}\n\nfunc (f *File) Write(p []byte) (int, error) {\n    // implementation\n}\n\nfunc (f *File) Close() error {\n    // implementation\n}\n\n// File now implements ReadWriteCloser\nvar rwc ReadWriteCloser = &File{}\n```\n\n## Generics\n\n### Generic Functions\n\n```go\n// Generic function with type parameter\nfunc Max[T comparable](a, b T) T {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n// Usage\nmaxInt := Max(10, 20)           // Type inferred\nmaxFloat := Max[float64](3.14, 2.71)  // Explicit type\n\n// Multiple type parameters\nfunc Swap[T, U any](a T, b U) (U, T) {\n    return b, a\n}\n\n// Type constraints\ntype Number interface {\n    int | int32 | int64 | float32 | float64\n}\n\nfunc Sum[T Number](numbers []T) T {\n    var sum T\n    for _, n := range numbers {\n        sum += n\n    }\n    return sum\n}\n\n// Using standard constraints\nimport \"golang.org/x/exp/constraints\"\n\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n### Generic Types\n\n```go\n// Generic struct\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    var zero T\n    if len(s.items) == 0 {\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\n// Usage\nintStack := Stack[int]{}\nintStack.Push(42)\nvalue, ok := intStack.Pop()\n\n// Generic interface\ntype Container[T any] interface {\n    Add(T)\n    Get(int) T\n    Size() int\n}\n\n// Type inference with generics\ntype Pair[T, U any] struct {\n    First  T\n    Second U\n}\n\n// Constructor function\nfunc NewPair[T, U any](first T, second U) Pair[T, U] {\n    return Pair[T, U]{First: first, Second: second}\n}\n\n// Type inference in use\np := NewPair(1, \"hello\")  // Pair[int, string] inferred\n```\n\n### Type Constraints\n\n```go\n// Custom constraints\ntype Signed interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64\n}\n\ntype Unsigned interface {\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64\n}\n\ntype Integer interface {\n    Signed | Unsigned\n}\n\n// Tilde (~) allows underlying types\ntype MyInt int\n\nfunc Double[T ~int](x T) T {\n    return x * 2\n}\n\nvar mi MyInt = 5\nresult := Double(mi)  // Works because MyInt's underlying type is int\n\n// Constraint with methods\ntype Stringer interface {\n    String() string\n}\n\nfunc PrintAll[T Stringer](items []T) {\n    for _, item := range items {\n        fmt.Println(item.String())\n    }\n}\n\n// Complex constraints\ntype Number interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |\n    ~float32 | ~float64\n}\n\ntype Addable[T any] interface {\n    Add(T) T\n}\n\ntype AddableNumber[T Number] interface {\n    Number\n    Addable[T]\n}\n```\n\n## Best Practices Summary\n\n### Code Organization\n- Keep packages small and focused\n- Use clear, descriptive names\n- Group related functionality\n- Minimize package dependencies\n- Use internal packages for private code\n\n### Error Handling\n- Always check errors\n- Wrap errors with context\n- Use sentinel errors for known conditions\n- Create custom error types when needed\n- Handle errors at the appropriate level\n\n### Concurrency\n- Don't communicate by sharing memory; share memory by communicating\n- Use channels for coordination\n- Keep goroutines simple\n- Always handle goroutine cleanup\n- Use context for cancellation\n\n### Performance\n- Measure before optimizing\n- Preallocate slices when size is known\n- Use string.Builder for string concatenation\n- Be aware of memory allocations\n- Profile your code\n\n### Testing\n- Write table-driven tests\n- Test edge cases\n- Use subtests for better organization\n- Mock external dependencies\n- Aim for high test coverage\n\n### Documentation\n- Document all exported items\n- Write clear package documentation\n- Include examples in documentation\n- Keep comments up to date\n- Use godoc format\n\nThis comprehensive guide covers the fundamental aspects of Go programming. Each topic includes practical examples and best practices to help write idiomatic, efficient Go code."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1914,"cache_read_input_tokens":45139,"output_tokens":13354,"service_tier":"standard"}},"requestId":"req_011CS5LgNdacmUVkxjSGMyTm","type":"assistant","uuid":"321ee0e2-91bf-4c81-a213-555c829d1ae1","timestamp":"2025-08-13T07:53:17.740Z"}
{"parentUuid":"321ee0e2-91bf-4c81-a213-555c829d1ae1","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NHVtXDtbawrbarV1fiY1Am","type":"tool_result","content":"The file /home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→# Go Language Fundamentals - Complete Reference\n     2→\n     3→## Table of Contents\n     4→1. [Introduction](#introduction)\n     5→2. [Basic Syntax](#basic-syntax)\n     6→3. [Variables and Constants](#variables-and-constants)\n     7→4. [Data Types](#data-types)\n     8→5. [Control Flow](#control-flow)\n     9→6. [Functions](#functions)\n    10→7. [Methods](#methods)\n    11→8. [Structs](#structs)\n    12→9. [Interfaces](#interfaces)\n    13→10. [Pointers](#pointers)\n    14→11. [Arrays and Slices](#arrays-and-slices)\n    15→12. [Maps](#maps)\n    16→13. [Error Handling](#error-handling)\n    17→14. [Packages and Modules](#packages-and-modules)\n    18→15. [Type Assertions and Type Switches](#type-assertions-and-type-switches)\n    19→16. [Embedding and Composition](#embedding-and-composition)\n    20→17. [Generics](#generics)\n    21→\n    22→## Introduction\n    23→\n    24→Go is a statically typed, compiled language designed for simplicity, efficiency, and reliable software. Created at Google in 2007 by Robert Griesemer, Rob Pike, and Ken Thompson, Go combines the performance of compiled languages with the ease of programming of dynamic languages.\n    25→\n    26→### Core Philosophy\n    27→- **Simplicity**: Less is exponentially more\n    28→- **Readability**: Code is read more often than written\n    29→- **Efficiency**: Fast compilation, fast execution\n    30→- **Concurrency**: Built-in primitives for concurrent programming\n    31→- **Pragmatism**: Solve real problems with practical solutions\n    32→\n    33→## Basic Syntax\n    34→\n    35→### Program Structure\n    36→\n    37→Every Go program starts with a package declaration and imports:\n    38→\n    39→```go\n    40→package main\n    41→\n    42→import (\n    43→    \"fmt\"\n    44→    \"strings\"\n    45→    \"time\"\n    46→)\n    47→\n    48→func main() {\n    49→    fmt.Println(\"Hello, Go!\")\n    50→}\n    51→```\n    52→\n    53→### Comments\n    54→\n    55→```go\n    56→// Single-line comment\n    57→\n    58→/*\n    59→   Multi-line comment\n    60→   Can span multiple lines\n    61→*/\n    62→\n    63→// Package documentation comment (must precede package declaration)\n    64→// Package math provides basic mathematical functions.\n    65→package math\n    66→\n    67→// Function documentation (must precede function declaration)\n    68→// Add returns the sum of two integers.\n    69→func Add(a, b int) int {\n    70→    return a + b\n    71→}\n    72→```\n    73→\n    74→### Naming Conventions\n    75→\n    76→```go\n    77→// Exported (public) - starts with uppercase\n    78→type Strategy struct{}\n    79→func CalculateProfit() {}\n    80→const MaxRetries = 3\n    81→var DefaultTimeout = 5 * time.Second\n    82→\n    83→// Unexported (private) - starts with lowercase\n    84→type position struct{}\n    85→func calculateLoss() {}\n    86→const maxAttempts = 5\n    87→var defaultBuffer = 1024\n    88→\n    89→// Package names - lowercase, single word\n    90→package trading  // Good\n    91→package tradingEngine  // Bad - use trading or engine\n    92→\n    93→// Interface names - typically end with -er\n    94→type Reader interface{}\n    95→type Writer interface{}\n    96→type Closer interface{}\n    97→type ReadWriteCloser interface{}  // Composition\n    98→\n    99→// Acronyms - keep consistent case\n   100→var httpClient HTTP  // Bad\n   101→var HTTPClient HTTP  // Good\n   102→var xmlParser XML    // Bad\n   103→var XMLParser XML    // Good\n   104→```\n   105→\n   106→## Variables and Constants\n   107→\n   108→### Variable Declaration\n   109→\n   110→```go\n   111→// var declaration with type\n   112→var name string\n   113→var age int\n   114→var balance float64\n   115→\n   116→// var declaration with initialization\n   117→var name string = \"John\"\n   118→var age int = 30\n   119→var balance = 1000.50  // Type inferred\n   120→\n   121→// Short variable declaration (only inside functions)\n   122→name := \"John\"\n   123→age := 30\n   124→balance := 1000.50\n   125→\n   126→// Multiple variable declaration\n   127→var (\n   128→    firstName string = \"John\"\n   129→    lastName  string = \"Doe\"\n   130→    age       int    = 30\n   131→)\n   132→\n   133→// Multiple assignment\n   134→x, y := 10, 20\n   135→a, b = b, a  // Swap values\n   136→\n   137→// Blank identifier for unused values\n   138→_, err := someFunction()  // Ignore first return value\n   139→```\n   140→\n   141→### Constants\n   142→\n   143→```go\n   144→// Single constant\n   145→const Pi = 3.14159\n   146→const MaxRetries = 3\n   147→const Message = \"Hello\"\n   148→\n   149→// Typed constants\n   150→const MaxInt int = 1000\n   151→const Timeout time.Duration = 5 * time.Second\n   152→\n   153→// Multiple constants\n   154→const (\n   155→    StatusOK       = 200\n   156→    StatusNotFound = 404\n   157→    StatusError    = 500\n   158→)\n   159→\n   160→// iota - constant generator\n   161→const (\n   162→    Sunday = iota  // 0\n   163→    Monday         // 1\n   164→    Tuesday        // 2\n   165→    Wednesday      // 3\n   166→    Thursday       // 4\n   167→    Friday         // 5\n   168→    Saturday       // 6\n   169→)\n   170→\n   171→// iota with expressions\n   172→const (\n   173→    _  = iota             // 0 (ignored)\n   174→    KB = 1 << (10 * iota) // 1024\n   175→    MB                    // 1048576\n   176→    GB                    // 1073741824\n   177→    TB                    // 1099511627776\n   178→)\n   179→\n   180→// Bit flags with iota\n   181→const (\n   182→    ReadPermission = 1 << iota  // 1\n   183→    WritePermission              // 2\n   184→    ExecutePermission            // 4\n   185→)\n   186→```\n   187→\n   188→## Data Types\n   189→\n   190→### Basic Types\n   191→\n   192→```go\n   193→// Boolean\n   194→var isActive bool = true\n   195→var isComplete bool  // Zero value: false\n   196→\n   197→// Integers\n   198→var i8 int8 = 127                    // -128 to 127\n   199→var i16 int16 = 32767                // -32768 to 32767\n   200→var i32 int32 = 2147483647           // -2147483648 to 2147483647\n   201→var i64 int64 = 9223372036854775807  // -9223372036854775808 to 9223372036854775807\n   202→var i int = 42                       // Platform dependent (32 or 64 bit)\n   203→\n   204→// Unsigned integers\n   205→var ui8 uint8 = 255                  // 0 to 255 (byte is alias)\n   206→var ui16 uint16 = 65535              // 0 to 65535\n   207→var ui32 uint32 = 4294967295         // 0 to 4294967295\n   208→var ui64 uint64 = 18446744073709551615  // 0 to 18446744073709551615\n   209→var ui uint = 42                     // Platform dependent\n   210→\n   211→// Floating point\n   212→var f32 float32 = 3.14               // IEEE-754 32-bit\n   213→var f64 float64 = 3.141592653589793  // IEEE-754 64-bit\n   214→\n   215→// Complex numbers\n   216→var c64 complex64 = 1 + 2i           // float32 real and imaginary\n   217→var c128 complex128 = 1 + 2i         // float64 real and imaginary\n   218→\n   219→// Strings\n   220→var str string = \"Hello, Go!\"        // UTF-8 encoded\n   221→var multiline = `This is\n   222→a multiline\n   223→string`                               // Raw string literal\n   224→\n   225→// Rune (Unicode code point)\n   226→var r rune = 'A'                     // int32 alias\n   227→var emoji rune = '😀'\n   228→\n   229→// Byte\n   230→var b byte = 65                      // uint8 alias\n   231→```\n   232→\n   233→### Type Conversions\n   234→\n   235→```go\n   236→// Explicit type conversion required\n   237→var i int = 42\n   238→var f float64 = float64(i)\n   239→var u uint = uint(i)\n   240→\n   241→// String conversions\n   242→import \"strconv\"\n   243→\n   244→// Int to string\n   245→s := strconv.Itoa(42)\n   246→s := strconv.FormatInt(42, 10)  // base 10\n   247→\n   248→// String to int\n   249→i, err := strconv.Atoi(\"42\")\n   250→i64, err := strconv.ParseInt(\"42\", 10, 64)\n   251→\n   252→// Float to string\n   253→s := strconv.FormatFloat(3.14, 'f', 2, 64)  // 2 decimal places\n   254→\n   255→// String to float\n   256→f, err := strconv.ParseFloat(\"3.14\", 64)\n   257→\n   258→// Type assertions (for interfaces)\n   259→var x interface{} = \"hello\"\n   260→s := x.(string)  // Panics if x is not string\n   261→s, ok := x.(string)  // Safe assertion with ok check\n   262→```\n   263→\n   264→### Zero Values\n   265→\n   266→```go\n   267→// All types have zero values\n   268→var b bool        // false\n   269→var i int         // 0\n   270→var f float64     // 0.0\n   271→var s string      // \"\"\n   272→var p *int        // nil\n   273→var a []int       // nil\n   274→var m map[string]int  // nil\n   275→var c chan int    // nil\n   276→var fn func()     // nil\n   277→var iface error   // nil\n   278→```\n   279→\n   280→## Control Flow\n   281→\n   282→### If Statements\n   283→\n   284→```go\n   285→// Basic if\n   286→if x > 0 {\n   287→    fmt.Println(\"Positive\")\n   288→}\n   289→\n   290→// If-else\n   291→if x > 0 {\n   292→    fmt.Println(\"Positive\")\n   293→} else {\n   294→    fmt.Println(\"Non-positive\")\n   295→}\n   296→\n   297→// If-else if-else\n   298→if x > 0 {\n   299→    fmt.Println(\"Positive\")\n   300→} else if x < 0 {\n   301→    fmt.Println(\"Negative\")\n   302→} else {\n   303→    fmt.Println(\"Zero\")\n   304→}\n   305→\n   306→// If with initialization\n   307→if err := doSomething(); err != nil {\n   308→    return err  // err is scoped to if block\n   309→}\n   310→\n   311→// Common patterns\n   312→// Check error immediately\n   313→if err != nil {\n   314→    return fmt.Errorf(\"failed to process: %w\", err)\n   315→}\n   316→\n   317→// Check boolean\n   318→if !isValid {\n   319→    return errors.New(\"invalid input\")\n   320→}\n   321→\n   322→// Check nil\n   323→if data == nil {\n   324→    return errors.New(\"data is nil\")\n   325→}\n   326→```\n   327→\n   328→### Switch Statements\n   329→\n   330→```go\n   331→// Basic switch\n   332→switch day {\n   333→case \"Monday\":\n   334→    fmt.Println(\"Start of work week\")\n   335→case \"Friday\":\n   336→    fmt.Println(\"TGIF!\")\n   337→case \"Saturday\", \"Sunday\":\n   338→    fmt.Println(\"Weekend!\")\n   339→default:\n   340→    fmt.Println(\"Midweek\")\n   341→}\n   342→\n   343→// Switch with no expression (like if-else chain)\n   344→switch {\n   345→case x < 0:\n   346→    fmt.Println(\"Negative\")\n   347→case x == 0:\n   348→    fmt.Println(\"Zero\")\n   349→case x > 0:\n   350→    fmt.Println(\"Positive\")\n   351→}\n   352→\n   353→// Switch with initialization\n   354→switch os := runtime.GOOS; os {\n   355→case \"darwin\":\n   356→    fmt.Println(\"macOS\")\n   357→case \"linux\":\n   358→    fmt.Println(\"Linux\")\n   359→default:\n   360→    fmt.Printf(\"Unknown OS: %s\\n\", os)\n   361→}\n   362→\n   363→// Type switch\n   364→func describe(i interface{}) {\n   365→    switch v := i.(type) {\n   366→    case int:\n   367→        fmt.Printf(\"Integer: %d\\n\", v)\n   368→    case string:\n   369→        fmt.Printf(\"String: %s\\n\", v)\n   370→    case bool:\n   371→        fmt.Printf(\"Boolean: %t\\n\", v)\n   372→    case nil:\n   373→        fmt.Println(\"nil value\")\n   374→    default:\n   375→        fmt.Printf(\"Unknown type: %T\\n\", v)\n   376→    }\n   377→}\n   378→\n   379→// Fallthrough (rarely used)\n   380→switch num {\n   381→case 1:\n   382→    fmt.Println(\"One\")\n   383→    fallthrough  // Continue to next case\n   384→case 2:\n   385→    fmt.Println(\"One or Two\")\n   386→}\n   387→```\n   388→\n   389→### Loops\n   390→\n   391→```go\n   392→// For loop - traditional\n   393→for i := 0; i < 10; i++ {\n   394→    fmt.Println(i)\n   395→}\n   396→\n   397→// For loop - while style\n   398→count := 0\n   399→for count < 10 {\n   400→    fmt.Println(count)\n   401→    count++\n   402→}\n   403→\n   404→// Infinite loop\n   405→for {\n   406→    // Break or return to exit\n   407→    if condition {\n   408→        break\n   409→    }\n   410→}\n   411→\n   412→// Range over slice\n   413→numbers := []int{1, 2, 3, 4, 5}\n   414→for index, value := range numbers {\n   415→    fmt.Printf(\"%d: %d\\n\", index, value)\n   416→}\n   417→\n   418→// Range over slice - values only\n   419→for _, value := range numbers {\n   420→    fmt.Println(value)\n   421→}\n   422→\n   423→// Range over slice - indices only\n   424→for index := range numbers {\n   425→    fmt.Println(index)\n   426→}\n   427→\n   428→// Range over map\n   429→ages := map[string]int{\"Alice\": 30, \"Bob\": 25}\n   430→for name, age := range ages {\n   431→    fmt.Printf(\"%s is %d years old\\n\", name, age)\n   432→}\n   433→\n   434→// Range over string (gives runes)\n   435→for index, runeValue := range \"Hello, 世界\" {\n   436→    fmt.Printf(\"%d: %c\\n\", index, runeValue)\n   437→}\n   438→\n   439→// Range over channel\n   440→ch := make(chan int)\n   441→go func() {\n   442→    for i := 0; i < 5; i++ {\n   443→        ch <- i\n   444→    }\n   445→    close(ch)\n   446→}()\n   447→for value := range ch {\n   448→    fmt.Println(value)\n   449→}\n   450→\n   451→// Continue and break with labels\n   452→outer:\n   453→for i := 0; i < 3; i++ {\n   454→    for j := 0; j < 3; j++ {\n   455→        if i == 1 && j == 1 {\n   456→            break outer  // Break outer loop\n   457→        }\n   458→        fmt.Printf(\"(%d, %d) \", i, j)\n   459→    }\n   460→}\n   461→```\n   462→\n   463→### Defer, Panic, and Recover\n   464→\n   465→```go\n   466→// Defer - executes when function returns\n   467→func readFile(filename string) error {\n   468→    file, err := os.Open(filename)\n   469→    if err != nil {\n   470→        return err\n   471→    }\n   472→    defer file.Close()  // Executed when function returns\n   473→    \n   474→    // Read file...\n   475→    return nil\n   476→}\n   477→\n   478→// Multiple defers - LIFO order\n   479→func example() {\n   480→    defer fmt.Println(\"Third\")\n   481→    defer fmt.Println(\"Second\")\n   482→    defer fmt.Println(\"First\")\n   483→    // Prints: First, Second, Third\n   484→}\n   485→\n   486→// Defer with arguments - evaluated immediately\n   487→func deferArgs() {\n   488→    i := 0\n   489→    defer fmt.Println(i)  // Prints 0, not 1\n   490→    i++\n   491→}\n   492→\n   493→// Defer with closure - captures variables\n   494→func deferClosure() {\n   495→    i := 0\n   496→    defer func() {\n   497→        fmt.Println(i)  // Prints 1\n   498→    }()\n   499→    i++\n   500→}\n   501→\n   502→// Panic - runtime error\n   503→func divide(a, b int) int {\n   504→    if b == 0 {\n   505→        panic(\"division by zero\")\n   506→    }\n   507→    return a / b\n   508→}\n   509→\n   510→// Recover - catch panic\n   511→func safeFunction() {\n   512→    defer func() {\n   513→        if r := recover(); r != nil {\n   514→            fmt.Printf(\"Recovered from panic: %v\\n\", r)\n   515→        }\n   516→    }()\n   517→    \n   518→    // Code that might panic\n   519→    panic(\"something went wrong\")\n   520→}\n   521→\n   522→// Practical error recovery pattern\n   523→func robustFunction() (err error) {\n   524→    defer func() {\n   525→        if r := recover(); r != nil {\n   526→            err = fmt.Errorf(\"panic recovered: %v\", r)\n   527→        }\n   528→    }()\n   529→    \n   530→    // Potentially panicking code\n   531→    return nil\n   532→}\n   533→```\n   534→\n   535→## Functions\n   536→\n   537→### Function Declaration\n   538→\n   539→```go\n   540→// Basic function\n   541→func greet() {\n   542→    fmt.Println(\"Hello!\")\n   543→}\n   544→\n   545→// Function with parameters\n   546→func add(a int, b int) int {\n   547→    return a + b\n   548→}\n   549→\n   550→// Shorthand for same type parameters\n   551→func add(a, b int) int {\n   552→    return a + b\n   553→}\n   554→\n   555→// Multiple return values\n   556→func divide(a, b float64) (float64, error) {\n   557→    if b == 0 {\n   558→        return 0, errors.New(\"division by zero\")\n   559→    }\n   560→    return a / b, nil\n   561→}\n   562→\n   563→// Named return values\n   564→func getCoordinates() (x, y int) {\n   565→    x = 10\n   566→    y = 20\n   567→    return  // Naked return\n   568→}\n   569→\n   570→// Named returns with explicit values\n   571→func calculate(a, b int) (sum, product int) {\n   572→    sum = a + b\n   573→    product = a * b\n   574→    return sum, product  // Can be explicit\n   575→}\n   576→\n   577→// Variadic functions\n   578→func sum(numbers ...int) int {\n   579→    total := 0\n   580→    for _, n := range numbers {\n   581→        total += n\n   582→    }\n   583→    return total\n   584→}\n   585→\n   586→// Calling variadic functions\n   587→result := sum(1, 2, 3, 4, 5)\n   588→nums := []int{1, 2, 3}\n   589→result := sum(nums...)  // Spread slice\n   590→```\n   591→\n   592→### Function Types and Values\n   593→\n   594→```go\n   595→// Function as type\n   596→type Operation func(int, int) int\n   597→\n   598→func add(a, b int) int { return a + b }\n   599→func multiply(a, b int) int { return a * b }\n   600→\n   601→var op Operation = add\n   602→result := op(5, 3)  // 8\n   603→\n   604→// Function as parameter\n   605→func apply(op Operation, a, b int) int {\n   606→    return op(a, b)\n   607→}\n   608→\n   609→result := apply(add, 5, 3)\n   610→result = apply(multiply, 5, 3)\n   611→\n   612→// Function returning function\n   613→func makeAdder(x int) func(int) int {\n   614→    return func(y int) int {\n   615→        return x + y\n   616→    }\n   617→}\n   618→\n   619→add5 := makeAdder(5)\n   620→result := add5(3)  // 8\n   621→\n   622→// Anonymous functions\n   623→func() {\n   624→    fmt.Println(\"Anonymous function\")\n   625→}()  // Immediately invoked\n   626→\n   627→// Assign to variable\n   628→greet := func(name string) {\n   629→    fmt.Printf(\"Hello, %s!\\n\", name)\n   630→}\n   631→greet(\"World\")\n   632→```\n   633→\n   634→### Closures\n   635→\n   636→```go\n   637→// Closure captures variables\n   638→func counter() func() int {\n   639→    count := 0\n   640→    return func() int {\n   641→        count++\n   642→        return count\n   643→    }\n   644→}\n   645→\n   646→c := counter()\n   647→fmt.Println(c())  // 1\n   648→fmt.Println(c())  // 2\n   649→fmt.Println(c())  // 3\n   650→\n   651→// Closure in loop (common pitfall)\n   652→// Wrong way\n   653→funcs := []func(){}\n   654→for i := 0; i < 3; i++ {\n   655→    funcs = append(funcs, func() {\n   656→        fmt.Println(i)  // All print 3\n   657→    })\n   658→}\n   659→\n   660→// Correct way\n   661→for i := 0; i < 3; i++ {\n   662→    i := i  // Shadow variable\n   663→    funcs = append(funcs, func() {\n   664→        fmt.Println(i)  // Prints 0, 1, 2\n   665→    })\n   666→}\n   667→\n   668→// Alternative correct way\n   669→for i := 0; i < 3; i++ {\n   670→    func(n int) {\n   671→        funcs = append(funcs, func() {\n   672→            fmt.Println(n)\n   673→        })\n   674→    }(i)\n   675→}\n   676→```\n   677→\n   678→## Methods\n   679→\n   680→### Method Declaration\n   681→\n   682→```go\n   683→// Method on struct\n   684→type Rectangle struct {\n   685→    Width, Height float64\n   686→}\n   687→\n   688→// Value receiver\n   689→func (r Rectangle) Area() float64 {\n   690→    return r.Width * r.Height\n   691→}\n   692→\n   693→// Pointer receiver\n   694→func (r *Rectangle) Scale(factor float64) {\n   695→    r.Width *= factor\n   696→    r.Height *= factor\n   697→}\n   698→\n   699→// Using methods\n   700→rect := Rectangle{Width: 10, Height: 5}\n   701→area := rect.Area()        // 50\n   702→rect.Scale(2)              // Width=20, Height=10\n   703→\n   704→// Method on non-struct types\n   705→type MyInt int\n   706→\n   707→func (m MyInt) IsEven() bool {\n   708→    return m%2 == 0\n   709→}\n   710→\n   711→var num MyInt = 42\n   712→if num.IsEven() {\n   713→    fmt.Println(\"Even number\")\n   714→}\n   715→\n   716→// Method on pointer vs value\n   717→type Counter struct {\n   718→    value int\n   719→}\n   720→\n   721→// Value receiver - cannot modify\n   722→func (c Counter) GetValue() int {\n   723→    return c.value\n   724→}\n   725→\n   726→// Pointer receiver - can modify\n   727→func (c *Counter) Increment() {\n   728→    c.value++\n   729→}\n   730→\n   731→// Pointer receiver - can handle nil\n   732→func (c *Counter) SafeIncrement() {\n   733→    if c == nil {\n   734→        return\n   735→    }\n   736→    c.value++\n   737→}\n   738→```\n   739→\n   740→### Method Sets\n   741→\n   742→```go\n   743→// Method set rules:\n   744→// - Type T has method set of all methods with receiver T\n   745→// - Type *T has method set of all methods with receiver T or *T\n   746→\n   747→type Shape struct {\n   748→    Name string\n   749→}\n   750→\n   751→func (s Shape) GetName() string {\n   752→    return s.Name\n   753→}\n   754→\n   755→func (s *Shape) SetName(name string) {\n   756→    s.Name = name\n   757→}\n   758→\n   759→// Value type can call value receiver methods\n   760→shape := Shape{Name: \"Circle\"}\n   761→name := shape.GetName()  // OK\n   762→\n   763→// Value type automatically gets address for pointer receiver\n   764→shape.SetName(\"Square\")  // OK (Go converts to (&shape).SetName())\n   765→\n   766→// Pointer type can call both\n   767→shapePtr := &Shape{Name: \"Triangle\"}\n   768→name = shapePtr.GetName()  // OK\n   769→shapePtr.SetName(\"Pentagon\")  // OK\n   770→```\n   771→\n   772→## Structs\n   773→\n   774→### Struct Declaration and Usage\n   775→\n   776→```go\n   777→// Basic struct\n   778→type Person struct {\n   779→    FirstName string\n   780→    LastName  string\n   781→    Age       int\n   782→}\n   783→\n   784→// Creating structs\n   785→p1 := Person{\n   786→    FirstName: \"John\",\n   787→    LastName:  \"Doe\",\n   788→    Age:       30,\n   789→}\n   790→\n   791→// Positional initialization (not recommended)\n   792→p2 := Person{\"Jane\", \"Doe\", 25}\n   793→\n   794→// Zero value struct\n   795→var p3 Person  // All fields have zero values\n   796→\n   797→// Accessing fields\n   798→fmt.Println(p1.FirstName)\n   799→p1.Age = 31\n   800→\n   801→// Struct pointer\n   802→ptr := &Person{FirstName: \"Bob\"}\n   803→ptr.Age = 40  // Automatic dereferencing\n   804→\n   805→// Anonymous struct\n   806→point := struct {\n   807→    X, Y int\n   808→}{X: 10, Y: 20}\n   809→\n   810→// Struct tags\n   811→type User struct {\n   812→    ID        int    `json:\"id\" db:\"user_id\"`\n   813→    Email     string `json:\"email\" validate:\"required,email\"`\n   814→    Password  string `json:\"-\"`  // Omit from JSON\n   815→    CreatedAt time.Time `json:\"created_at,omitempty\"`\n   816→}\n   817→\n   818→// Accessing tags via reflection\n   819→import \"reflect\"\n   820→\n   821→t := reflect.TypeOf(User{})\n   822→field, _ := t.FieldByName(\"Email\")\n   823→fmt.Println(field.Tag.Get(\"json\"))     // \"email\"\n   824→fmt.Println(field.Tag.Get(\"validate\")) // \"required,email\"\n   825→```\n   826→\n   827→### Struct Embedding\n   828→\n   829→```go\n   830→// Embedding for composition\n   831→type Address struct {\n   832→    Street  string\n   833→    City    string\n   834→    Country string\n   835→}\n   836→\n   837→type Employee struct {\n   838→    Person  // Embedded struct\n   839→    Address // Another embedded struct\n   840→    Salary  float64\n   841→}\n   842→\n   843→emp := Employee{\n   844→    Person: Person{\n   845→        FirstName: \"Alice\",\n   846→        LastName:  \"Smith\",\n   847→        Age:       28,\n   848→    },\n   849→    Address: Address{\n   850→        City:    \"New York\",\n   851→        Country: \"USA\",\n   852→    },\n   853→    Salary: 75000,\n   854→}\n   855→\n   856→// Promoted fields\n   857→fmt.Println(emp.FirstName)  // Promoted from Person\n   858→fmt.Println(emp.City)       // Promoted from Address\n   859→\n   860→// Explicit access\n   861→fmt.Println(emp.Person.FirstName)\n   862→\n   863→// Method promotion\n   864→type Writer struct{}\n   865→\n   866→func (w Writer) Write(data []byte) (int, error) {\n   867→    return len(data), nil\n   868→}\n   869→\n   870→type Logger struct {\n   871→    Writer  // Embedded\n   872→    prefix string\n   873→}\n   874→\n   875→log := Logger{prefix: \"[INFO]\"}\n   876→log.Write([]byte(\"message\"))  // Promoted method\n   877→```\n   878→\n   879→### Struct Comparison\n   880→\n   881→```go\n   882→// Structs are comparable if all fields are comparable\n   883→type Point struct {\n   884→    X, Y int\n   885→}\n   886→\n   887→p1 := Point{1, 2}\n   888→p2 := Point{1, 2}\n   889→p3 := Point{2, 3}\n   890→\n   891→fmt.Println(p1 == p2)  // true\n   892→fmt.Println(p1 == p3)  // false\n   893→\n   894→// Non-comparable structs (contain slices, maps, functions)\n   895→type Data struct {\n   896→    Values []int  // Slices are not comparable\n   897→}\n   898→\n   899→// This won't compile:\n   900→// d1 := Data{Values: []int{1, 2}}\n   901→// d2 := Data{Values: []int{1, 2}}\n   902→// fmt.Println(d1 == d2)  // Compile error\n   903→```\n   904→\n   905→## Interfaces\n   906→\n   907→### Interface Declaration and Implementation\n   908→\n   909→```go\n   910→// Interface declaration\n   911→type Writer interface {\n   912→    Write([]byte) (int, error)\n   913→}\n   914→\n   915→// Interface with multiple methods\n   916→type ReadWriter interface {\n   917→    Read([]byte) (int, error)\n   918→    Write([]byte) (int, error)\n   919→}\n   920→\n   921→// Empty interface (any type)\n   922→type Any interface{}  // Pre Go 1.18\n   923→type Any = any        // Go 1.18+\n   924→\n   925→// Implicit implementation\n   926→type FileWriter struct {\n   927→    filename string\n   928→}\n   929→\n   930→func (f FileWriter) Write(data []byte) (int, error) {\n   931→    // Implementation\n   932→    return len(data), nil\n   933→}\n   934→\n   935→// FileWriter implements Writer implicitly\n   936→var w Writer = FileWriter{filename: \"test.txt\"}\n   937→```\n   938→\n   939→### Interface Composition\n   940→\n   941→```go\n   942→// Composing interfaces\n   943→type Reader interface {\n   944→    Read([]byte) (int, error)\n   945→}\n   946→\n   947→type Writer interface {\n   948→    Write([]byte) (int, error)\n   949→}\n   950→\n   951→type Closer interface {\n   952→    Close() error\n   953→}\n   954→\n   955→// Composed interface\n   956→type ReadWriteCloser interface {\n   957→    Reader\n   958→    Writer\n   959→    Closer\n   960→}\n   961→\n   962→// Alternative inline composition\n   963→type ReadWriter interface {\n   964→    Read([]byte) (int, error)\n   965→    Write([]byte) (int, error)\n   966→}\n   967→```\n   968→\n   969→### Interface Values and nil\n   970→\n   971→```go\n   972→// Interface values have two components: type and value\n   973→var w Writer\n   974→fmt.Printf(\"Type: %T, Value: %v\\n\", w, w)  // Type: <nil>, Value: <nil>\n   975→\n   976→// nil interface vs interface with nil value\n   977→type MyWriter struct{}\n   978→\n   979→func (m *MyWriter) Write(data []byte) (int, error) {\n   980→    if m == nil {\n   981→        return 0, errors.New(\"nil writer\")\n   982→    }\n   983→    return len(data), nil\n   984→}\n   985→\n   986→var mw *MyWriter = nil\n   987→var w Writer = mw\n   988→// w is not nil (has type *MyWriter), but its value is nil\n   989→\n   990→if w == nil {\n   991→    fmt.Println(\"w is nil\")  // Won't print\n   992→}\n   993→\n   994→// Check for nil value\n   995→if mw == nil {\n   996→    fmt.Println(\"mw is nil\")  // Will print\n   997→}\n   998→```\n   999→\n  1000→### Type Assertions and Type Switches\n  1001→\n  1002→```go\n  1003→// Type assertion\n  1004→var i interface{} = \"hello\"\n  1005→\n  1006→// Direct assertion (panics if wrong type)\n  1007→s := i.(string)\n  1008→fmt.Println(s)\n  1009→\n  1010→// Safe assertion with comma-ok\n  1011→s, ok := i.(string)\n  1012→if ok {\n  1013→    fmt.Println(\"String:\", s)\n  1014→}\n  1015→\n  1016→// Check interface implementation\n  1017→var w io.Writer = &bytes.Buffer{}\n  1018→if buf, ok := w.(*bytes.Buffer); ok {\n  1019→    fmt.Println(\"It's a buffer:\", buf)\n  1020→}\n  1021→\n  1022→// Type switch\n  1023→func describe(i interface{}) {\n  1024→    switch v := i.(type) {\n  1025→    case int:\n  1026→        fmt.Printf(\"Integer: %d\\n\", v)\n  1027→    case string:\n  1028→        fmt.Printf(\"String: %s\\n\", v)\n  1029→    case io.Reader:\n  1030→        fmt.Println(\"It's a reader\")\n  1031→    case nil:\n  1032→        fmt.Println(\"It's nil\")\n  1033→    default:\n  1034→        fmt.Printf(\"Unknown type: %T\\n\", v)\n  1035→    }\n  1036→}\n  1037→```\n  1038→\n  1039→### Common Interface Patterns\n  1040→\n  1041→```go\n  1042→// Stringer interface\n  1043→type Stringer interface {\n  1044→    String() string\n  1045→}\n  1046→\n  1047→type Point struct {\n  1048→    X, Y int\n  1049→}\n  1050→\n  1051→func (p Point) String() string {\n  1052→    return fmt.Sprintf(\"(%d, %d)\", p.X, p.Y)\n  1053→}\n  1054→\n  1055→// Error interface\n  1056→type error interface {\n  1057→    Error() string\n  1058→}\n  1059→\n  1060→type ValidationError struct {\n  1061→    Field string\n  1062→    Value string\n  1063→}\n  1064→\n  1065→func (e ValidationError) Error() string {\n  1066→    return fmt.Sprintf(\"validation failed for field %s: %s\", e.Field, e.Value)\n  1067→}\n  1068→\n  1069→// Sort interface\n  1070→type Interface interface {\n  1071→    Len() int\n  1072→    Less(i, j int) bool\n  1073→    Swap(i, j int)\n  1074→}\n  1075→\n  1076→// Custom sort implementation\n  1077→type ByAge []Person\n  1078→\n  1079→func (a ByAge) Len() int           { return len(a) }\n  1080→func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\n  1081→func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n  1082→\n  1083→// Usage\n  1084→people := []Person{{Name: \"Alice\", Age: 30}, {Name: \"Bob\", Age: 25}}\n  1085→sort.Sort(ByAge(people))\n  1086→```\n  1087→\n  1088→## Pointers\n  1089→\n  1090→### Pointer Basics\n  1091→\n  1092→```go\n  1093→// Declare pointer\n  1094→var p *int\n  1095→\n  1096→// Get address of variable\n  1097→x := 42\n  1098→p = &x\n  1099→\n  1100→// Dereference pointer\n  1101→fmt.Println(*p)  // 42\n  1102→*p = 100\n  1103→fmt.Println(x)   // 100\n  1104→\n  1105→// Pointer zero value is nil\n  1106→var ptr *string\n  1107→if ptr == nil {\n  1108→    fmt.Println(\"ptr is nil\")\n  1109→}\n  1110→\n  1111→// New function allocates memory\n  1112→ptr = new(string)\n  1113→*ptr = \"Hello\"\n  1114→\n  1115→// Pointer to struct\n  1116→type Person struct {\n  1117→    Name string\n  1118→    Age  int\n  1119→}\n  1120→\n  1121→person := &Person{Name: \"Alice\", Age: 30}\n  1122→person.Age = 31  // Automatic dereferencing\n  1123→\n  1124→// Pointer arithmetic is NOT allowed in Go\n  1125→// p++  // This won't compile\n  1126→```\n  1127→\n  1128→### Pointers vs Values\n  1129→\n  1130→```go\n  1131→// Pass by value\n  1132→func modifyValue(x int) {\n  1133→    x = 100  // Doesn't affect original\n  1134→}\n  1135→\n  1136→// Pass by pointer\n  1137→func modifyPointer(x *int) {\n  1138→    *x = 100  // Modifies original\n  1139→}\n  1140→\n  1141→value := 42\n  1142→modifyValue(value)\n  1143→fmt.Println(value)  // Still 42\n  1144→\n  1145→modifyPointer(&value)\n  1146→fmt.Println(value)  // Now 100\n  1147→\n  1148→// Slices, maps, channels are reference types\n  1149→func modifySlice(s []int) {\n  1150→    s[0] = 100  // Modifies original\n  1151→}\n  1152→\n  1153→slice := []int{1, 2, 3}\n  1154→modifySlice(slice)\n  1155→fmt.Println(slice)  // [100, 2, 3]\n  1156→\n  1157→// But reassigning doesn't affect original\n  1158→func reassignSlice(s []int) {\n  1159→    s = []int{4, 5, 6}  // Doesn't affect original\n  1160→}\n  1161→\n  1162→// To modify slice itself, use pointer\n  1163→func replaceSlice(s *[]int) {\n  1164→    *s = []int{4, 5, 6}\n  1165→}\n  1166→```\n  1167→\n  1168→## Arrays and Slices\n  1169→\n  1170→### Arrays\n  1171→\n  1172→```go\n  1173→// Array declaration\n  1174→var arr [5]int              // [0 0 0 0 0]\n  1175→arr[0] = 10\n  1176→arr[4] = 50\n  1177→\n  1178→// Array initialization\n  1179→arr := [5]int{1, 2, 3, 4, 5}\n  1180→arr := [...]int{1, 2, 3}    // Compiler counts elements\n  1181→arr := [5]int{0: 10, 4: 50} // Index:value pairs\n  1182→\n  1183→// Arrays are values (copied on assignment)\n  1184→arr1 := [3]int{1, 2, 3}\n  1185→arr2 := arr1\n  1186→arr2[0] = 100\n  1187→fmt.Println(arr1)  // [1 2 3] - unchanged\n  1188→fmt.Println(arr2)  // [100 2 3]\n  1189→\n  1190→// Array size is part of type\n  1191→var a [5]int\n  1192→var b [10]int\n  1193→// a = b  // Won't compile - different types\n  1194→\n  1195→// Multidimensional arrays\n  1196→var matrix [3][3]int\n  1197→matrix[1][1] = 5\n  1198→\n  1199→// Array iteration\n  1200→for i := 0; i < len(arr); i++ {\n  1201→    fmt.Println(arr[i])\n  1202→}\n  1203→\n  1204→for index, value := range arr {\n  1205→    fmt.Printf(\"%d: %d\\n\", index, value)\n  1206→}\n  1207→```\n  1208→\n  1209→### Slices\n  1210→\n  1211→```go\n  1212→// Slice declaration\n  1213→var slice []int            // nil slice\n  1214→slice = []int{}           // Empty slice\n  1215→slice = []int{1, 2, 3}    // Initialized slice\n  1216→\n  1217→// Make function\n  1218→slice = make([]int, 5)    // Length 5, capacity 5\n  1219→slice = make([]int, 5, 10) // Length 5, capacity 10\n  1220→\n  1221→// Slice from array\n  1222→arr := [5]int{1, 2, 3, 4, 5}\n  1223→slice = arr[1:4]  // [2 3 4]\n  1224→slice = arr[:3]   // [1 2 3]\n  1225→slice = arr[2:]   // [3 4 5]\n  1226→slice = arr[:]    // [1 2 3 4 5]\n  1227→\n  1228→// Slice properties\n  1229→fmt.Println(len(slice))  // Length\n  1230→fmt.Println(cap(slice))  // Capacity\n  1231→\n  1232→// Append\n  1233→slice = []int{1, 2, 3}\n  1234→slice = append(slice, 4)\n  1235→slice = append(slice, 5, 6, 7)\n  1236→slice = append(slice, []int{8, 9}...)\n  1237→\n  1238→// Copy\n  1239→src := []int{1, 2, 3}\n  1240→dst := make([]int, len(src))\n  1241→n := copy(dst, src)  // Returns number copied\n  1242→\n  1243→// Slice tricks\n  1244→// Remove element at index i\n  1245→slice = append(slice[:i], slice[i+1:]...)\n  1246→\n  1247→// Insert element at index i\n  1248→slice = append(slice[:i], append([]int{x}, slice[i:]...)...)\n  1249→\n  1250→// Pop from end\n  1251→x := slice[len(slice)-1]\n  1252→slice = slice[:len(slice)-1]\n  1253→\n  1254→// Push to front\n  1255→slice = append([]int{x}, slice...)\n  1256→\n  1257→// Filter in place\n  1258→n := 0\n  1259→for _, x := range slice {\n  1260→    if keepElement(x) {\n  1261→        slice[n] = x\n  1262→        n++\n  1263→    }\n  1264→}\n  1265→slice = slice[:n]\n  1266→```\n  1267→\n  1268→### Slice Internals\n  1269→\n  1270→```go\n  1271→// Slice header (conceptual)\n  1272→type SliceHeader struct {\n  1273→    Data uintptr  // Pointer to underlying array\n  1274→    Len  int      // Current length\n  1275→    Cap  int      // Capacity\n  1276→}\n  1277→\n  1278→// Slices share underlying array\n  1279→original := []int{1, 2, 3, 4, 5}\n  1280→slice1 := original[1:4]  // [2 3 4]\n  1281→slice2 := original[2:5]  // [3 4 5]\n  1282→\n  1283→slice1[1] = 100  // Modifies shared array\n  1284→fmt.Println(slice2)  // [100 4 5]\n  1285→\n  1286→// Full slice expression controls capacity\n  1287→slice := original[1:3:4]  // [low:high:max]\n  1288→// len = high - low = 2\n  1289→// cap = max - low = 3\n  1290→\n  1291→// nil vs empty slice\n  1292→var nilSlice []int        // nil\n  1293→emptySlice := []int{}     // Not nil, but empty\n  1294→madeSlice := make([]int, 0) // Not nil, but empty\n  1295→\n  1296→fmt.Println(nilSlice == nil)    // true\n  1297→fmt.Println(emptySlice == nil)  // false\n  1298→fmt.Println(len(nilSlice))      // 0\n  1299→fmt.Println(len(emptySlice))    // 0\n  1300→\n  1301→// Both work with append\n  1302→nilSlice = append(nilSlice, 1)\n  1303→emptySlice = append(emptySlice, 1)\n  1304→```\n  1305→\n  1306→## Maps\n  1307→\n  1308→### Map Basics\n  1309→\n  1310→```go\n  1311→// Map declaration\n  1312→var m map[string]int      // nil map\n  1313→m = make(map[string]int)  // Initialize\n  1314→\n  1315→// Map literal\n  1316→m = map[string]int{\n  1317→    \"Alice\": 30,\n  1318→    \"Bob\":   25,\n  1319→}\n  1320→\n  1321→// Operations\n  1322→m[\"Charlie\"] = 35         // Insert/Update\n  1323→age := m[\"Alice\"]         // Retrieve\n  1324→delete(m, \"Bob\")          // Delete\n  1325→\n  1326→// Check if key exists\n  1327→age, exists := m[\"David\"]\n  1328→if exists {\n  1329→    fmt.Printf(\"David is %d years old\\n\", age)\n  1330→}\n  1331→\n  1332→// Zero value for missing key\n  1333→fmt.Println(m[\"Unknown\"])  // 0 (zero value for int)\n  1334→\n  1335→// Iteration (order is random)\n  1336→for key, value := range m {\n  1337→    fmt.Printf(\"%s: %d\\n\", key, value)\n  1338→}\n  1339→\n  1340→// Keys only\n  1341→for key := range m {\n  1342→    fmt.Println(key)\n  1343→}\n  1344→\n  1345→// Values only\n  1346→for _, value := range m {\n  1347→    fmt.Println(value)\n  1348→}\n  1349→```\n  1350→\n  1351→### Map Patterns\n  1352→\n  1353→```go\n  1354→// Map as set\n  1355→set := make(map[string]bool)\n  1356→set[\"apple\"] = true\n  1357→set[\"banana\"] = true\n  1358→\n  1359→if set[\"apple\"] {\n  1360→    fmt.Println(\"apple is in the set\")\n  1361→}\n  1362→\n  1363→// Alternative set using empty struct (memory efficient)\n  1364→type void struct{}\n  1365→var member void\n  1366→\n  1367→set := make(map[string]void)\n  1368→set[\"apple\"] = member\n  1369→set[\"banana\"] = member\n  1370→\n  1371→if _, exists := set[\"apple\"]; exists {\n  1372→    fmt.Println(\"apple is in the set\")\n  1373→}\n  1374→\n  1375→// Counting with maps\n  1376→counts := make(map[string]int)\n  1377→words := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"}\n  1378→\n  1379→for _, word := range words {\n  1380→    counts[word]++  // Works even if key doesn't exist\n  1381→}\n  1382→\n  1383→// Grouping with maps\n  1384→type Person struct {\n  1385→    Name string\n  1386→    Age  int\n  1387→}\n  1388→\n  1389→people := []Person{\n  1390→    {\"Alice\", 30},\n  1391→    {\"Bob\", 25},\n  1392→    {\"Charlie\", 30},\n  1393→    {\"David\", 25},\n  1394→}\n  1395→\n  1396→ageGroups := make(map[int][]Person)\n  1397→for _, person := range people {\n  1398→    ageGroups[person.Age] = append(ageGroups[person.Age], person)\n  1399→}\n  1400→\n  1401→// Map of maps\n  1402→nested := make(map[string]map[string]int)\n  1403→nested[\"scores\"] = make(map[string]int)\n  1404→nested[\"scores\"][\"Alice\"] = 95\n  1405→nested[\"scores\"][\"Bob\"] = 87\n  1406→\n  1407→// Safe nested access\n  1408→if scores, ok := nested[\"scores\"]; ok {\n  1409→    if score, ok := scores[\"Alice\"]; ok {\n  1410→        fmt.Printf(\"Alice's score: %d\\n\", score)\n  1411→    }\n  1412→}\n  1413→```\n  1414→\n  1415→### Maps and Concurrency\n  1416→\n  1417→```go\n  1418→// Maps are not safe for concurrent access\n  1419→// Use sync.Map or mutex\n  1420→\n  1421→import \"sync\"\n  1422→\n  1423→// With mutex\n  1424→type SafeMap struct {\n  1425→    mu sync.RWMutex\n  1426→    m  map[string]int\n  1427→}\n  1428→\n  1429→func (sm *SafeMap) Set(key string, value int) {\n  1430→    sm.mu.Lock()\n  1431→    defer sm.mu.Unlock()\n  1432→    sm.m[key] = value\n  1433→}\n  1434→\n  1435→func (sm *SafeMap) Get(key string) (int, bool) {\n  1436→    sm.mu.RLock()\n  1437→    defer sm.mu.RUnlock()\n  1438→    value, exists := sm.m[key]\n  1439→    return value, exists\n  1440→}\n  1441→\n  1442→// Using sync.Map (for specific use cases)\n  1443→var m sync.Map\n  1444→\n  1445→// Store\n  1446→m.Store(\"key\", \"value\")\n  1447→\n  1448→// Load\n  1449→value, ok := m.Load(\"key\")\n  1450→\n  1451→// LoadOrStore\n  1452→actual, loaded := m.LoadOrStore(\"key\", \"new-value\")\n  1453→\n  1454→// Delete\n  1455→m.Delete(\"key\")\n  1456→\n  1457→// Range\n  1458→m.Range(func(key, value interface{}) bool {\n  1459→    fmt.Printf(\"%v: %v\\n\", key, value)\n  1460→    return true  // Continue iteration\n  1461→})\n  1462→```\n  1463→\n  1464→## Error Handling\n  1465→\n  1466→### Error Interface\n  1467→\n  1468→```go\n  1469→// Error interface\n  1470→type error interface {\n  1471→    Error() string\n  1472→}\n  1473→\n  1474→// Creating errors\n  1475→import \"errors\"\n  1476→\n  1477→err := errors.New(\"something went wrong\")\n  1478→err := fmt.Errorf(\"failed to process %s: %v\", filename, originalErr)\n  1479→\n  1480→// Custom error types\n  1481→type ValidationError struct {\n  1482→    Field string\n  1483→    Value interface{}\n  1484→    Msg   string\n  1485→}\n  1486→\n  1487→func (e ValidationError) Error() string {\n  1488→    return fmt.Sprintf(\"validation error: field=%s value=%v msg=%s\", \n  1489→        e.Field, e.Value, e.Msg)\n  1490→}\n  1491→\n  1492→// Sentinel errors\n  1493→var (\n  1494→    ErrNotFound   = errors.New(\"not found\")\n  1495→    ErrPermission = errors.New(\"permission denied\")\n  1496→    ErrTimeout    = errors.New(\"operation timed out\")\n  1497→)\n  1498→\n  1499→// Error wrapping (Go 1.13+)\n  1500→originalErr := errors.New(\"original error\")\n  1501→wrappedErr := fmt.Errorf(\"wrapped: %w\", originalErr)\n  1502→\n  1503→// Unwrap errors\n  1504→if errors.Is(wrappedErr, originalErr) {\n  1505→    fmt.Println(\"Error is originalErr\")\n  1506→}\n  1507→\n  1508→var validationErr ValidationError\n  1509→if errors.As(wrappedErr, &validationErr) {\n  1510→    fmt.Printf(\"Validation error: %s\\n\", validationErr.Field)\n  1511→}\n  1512→```\n  1513→\n  1514→### Error Handling Patterns\n  1515→\n  1516→```go\n  1517→// Immediate error checking\n  1518→result, err := doSomething()\n  1519→if err != nil {\n  1520→    return fmt.Errorf(\"doSomething failed: %w\", err)\n  1521→}\n  1522→\n  1523→// Multiple error sources\n  1524→func processFile(filename string) error {\n  1525→    file, err := os.Open(filename)\n  1526→    if err != nil {\n  1527→        return fmt.Errorf(\"open file: %w\", err)\n  1528→    }\n  1529→    defer file.Close()\n  1530→    \n  1531→    data, err := io.ReadAll(file)\n  1532→    if err != nil {\n  1533→        return fmt.Errorf(\"read file: %w\", err)\n  1534→    }\n  1535→    \n  1536→    if err := processData(data); err != nil {\n  1537→        return fmt.Errorf(\"process data: %w\", err)\n  1538→    }\n  1539→    \n  1540→    return nil\n  1541→}\n  1542→\n  1543→// Error accumulation\n  1544→var errs []error\n  1545→\n  1546→for _, item := range items {\n  1547→    if err := process(item); err != nil {\n  1548→        errs = append(errs, err)\n  1549→    }\n  1550→}\n  1551→\n  1552→if len(errs) > 0 {\n  1553→    return fmt.Errorf(\"processing failed with %d errors\", len(errs))\n  1554→}\n  1555→\n  1556→// Retry pattern\n  1557→func retryOperation(maxAttempts int) error {\n  1558→    var lastErr error\n  1559→    \n  1560→    for i := 0; i < maxAttempts; i++ {\n  1561→        if err := attemptOperation(); err != nil {\n  1562→            lastErr = err\n  1563→            time.Sleep(time.Second * time.Duration(i+1))\n  1564→            continue\n  1565→        }\n  1566→        return nil  // Success\n  1567→    }\n  1568→    \n  1569→    return fmt.Errorf(\"failed after %d attempts: %w\", maxAttempts, lastErr)\n  1570→}\n  1571→\n  1572→// Cleanup on error\n  1573→func createResources() (err error) {\n  1574→    resource1, err := createResource1()\n  1575→    if err != nil {\n  1576→        return err\n  1577→    }\n  1578→    defer func() {\n  1579→        if err != nil {\n  1580→            resource1.Cleanup()\n  1581→        }\n  1582→    }()\n  1583→    \n  1584→    resource2, err := createResource2()\n  1585→    if err != nil {\n  1586→        return err  // resource1 cleaned up by defer\n  1587→    }\n  1588→    \n  1589→    return nil\n  1590→}\n  1591→```\n  1592→\n  1593→## Packages and Modules\n  1594→\n  1595→### Package Organization\n  1596→\n  1597→```go\n  1598→// Package declaration (first non-comment line)\n  1599→package mypackage\n  1600→\n  1601→// Package documentation\n  1602→// Package mypackage provides utilities for data processing.\n  1603→// It includes functions for parsing, validation, and transformation.\n  1604→package mypackage\n  1605→\n  1606→// Import statements\n  1607→import (\n  1608→    \"fmt\"           // Standard library\n  1609→    \"time\"\n  1610→    \n  1611→    \"github.com/pkg/errors\"  // External packages\n  1612→    \n  1613→    \"myproject/internal/utils\"  // Internal packages\n  1614→)\n  1615→\n  1616→// Import aliasing\n  1617→import (\n  1618→    \"context\"\n  1619→    stdlog \"log\"  // Alias to avoid conflicts\n  1620→    . \"math\"      // Dot import (use sparingly)\n  1621→    _ \"image/png\" // Import for side effects only\n  1622→)\n  1623→\n  1624→// Package initialization\n  1625→func init() {\n  1626→    // Runs when package is imported\n  1627→    // Can have multiple init functions\n  1628→    fmt.Println(\"Package initialized\")\n  1629→}\n  1630→\n  1631→// Exported (public) - uppercase\n  1632→func PublicFunction() {}\n  1633→type PublicType struct{}\n  1634→const PublicConst = 42\n  1635→var PublicVar = \"hello\"\n  1636→\n  1637→// Unexported (private) - lowercase\n  1638→func privateFunction() {}\n  1639→type privateType struct{}\n  1640→const privateConst = 42\n  1641→var privateVar = \"hello\"\n  1642→```\n  1643→\n  1644→### Module Management\n  1645→\n  1646→```bash\n  1647→# Initialize module\n  1648→go mod init github.com/username/projectname\n  1649→\n  1650→# Add dependencies\n  1651→go get github.com/pkg/errors\n  1652→go get github.com/stretchr/testify@v1.8.0\n  1653→\n  1654→# Update dependencies\n  1655→go get -u ./...              # Update all\n  1656→go get -u github.com/pkg/errors  # Update specific\n  1657→\n  1658→# Clean up\n  1659→go mod tidy  # Remove unused dependencies\n  1660→\n  1661→# Vendor dependencies\n  1662→go mod vendor  # Copy dependencies to vendor/\n  1663→\n  1664→# Module directives in go.mod\n  1665→module github.com/username/project\n  1666→\n  1667→go 1.21\n  1668→\n  1669→require (\n  1670→    github.com/pkg/errors v0.9.1\n  1671→    github.com/stretchr/testify v1.8.0\n  1672→)\n  1673→\n  1674→replace github.com/old/package => github.com/new/package v1.0.0\n  1675→\n  1676→exclude github.com/bad/package v1.0.0\n  1677→```\n  1678→\n  1679→### Internal Packages\n  1680→\n  1681→```go\n  1682→// Internal packages can only be imported by nearby code\n  1683→myproject/\n  1684→├── cmd/\n  1685→│   └── app/\n  1686→│       └── main.go  // Can import internal/\n  1687→├── internal/\n  1688→│   ├── database/    // Only accessible within myproject\n  1689→│   └── utils/\n  1690→├── pkg/             // Public packages\n  1691→│   └── api/\n  1692→└── go.mod\n  1693→\n  1694→// This import works in myproject\n  1695→import \"myproject/internal/database\"\n  1696→\n  1697→// This import fails outside myproject\n  1698→import \"github.com/other/project/internal/database\"  // Error\n  1699→```\n  1700→\n  1701→## Type Assertions and Type Switches\n  1702→\n  1703→### Type Assertions\n  1704→\n  1705→```go\n  1706→// Basic type assertion\n  1707→var i interface{} = \"hello\"\n  1708→s := i.(string)  // Panics if not string\n  1709→fmt.Println(s)\n  1710→\n  1711→// Safe type assertion\n  1712→s, ok := i.(string)\n  1713→if !ok {\n  1714→    fmt.Println(\"Not a string\")\n  1715→}\n  1716→\n  1717→// Common patterns\n  1718→func processValue(v interface{}) {\n  1719→    // Try multiple types\n  1720→    switch value := v.(type) {\n  1721→    case string:\n  1722→        fmt.Printf(\"String: %s\\n\", value)\n  1723→    case int:\n  1724→        fmt.Printf(\"Integer: %d\\n\", value)\n  1725→    case []byte:\n  1726→        fmt.Printf(\"Bytes: %s\\n\", string(value))\n  1727→    default:\n  1728→        fmt.Printf(\"Unknown: %T\\n\", value)\n  1729→    }\n  1730→}\n  1731→\n  1732→// Check for interface implementation\n  1733→type Stringer interface {\n  1734→    String() string\n  1735→}\n  1736→\n  1737→func toString(v interface{}) string {\n  1738→    if s, ok := v.(Stringer); ok {\n  1739→        return s.String()\n  1740→    }\n  1741→    return fmt.Sprintf(\"%v\", v)\n  1742→}\n  1743→\n  1744→// Nil interface gotcha\n  1745→var p *Person  // nil pointer\n  1746→var i interface{} = p\n  1747→\n  1748→if i == nil {\n  1749→    fmt.Println(\"i is nil\")  // Won't print!\n  1750→}\n  1751→\n  1752→if p == nil {\n  1753→    fmt.Println(\"p is nil\")  // Will print\n  1754→}\n  1755→```\n  1756→\n  1757→## Embedding and Composition\n  1758→\n  1759→### Struct Embedding\n  1760→\n  1761→```go\n  1762→// Base types\n  1763→type Person struct {\n  1764→    Name string\n  1765→    Age  int\n  1766→}\n  1767→\n  1768→type Address struct {\n  1769→    Street string\n  1770→    City   string\n  1771→}\n  1772→\n  1773→// Embedding\n  1774→type Employee struct {\n  1775→    Person      // Anonymous field\n  1776→    Address     // Another anonymous field\n  1777→    Department string\n  1778→    Salary     float64\n  1779→}\n  1780→\n  1781→emp := Employee{\n  1782→    Person:     Person{Name: \"Alice\", Age: 30},\n  1783→    Address:    Address{City: \"New York\"},\n  1784→    Department: \"Engineering\",\n  1785→}\n  1786→\n  1787→// Field promotion\n  1788→fmt.Println(emp.Name)  // Accessed directly\n  1789→fmt.Println(emp.City)\n  1790→\n  1791→// Method promotion\n  1792→func (p Person) Introduce() {\n  1793→    fmt.Printf(\"Hi, I'm %s\\n\", p.Name)\n  1794→}\n  1795→\n  1796→emp.Introduce()  // Method promoted from Person\n  1797→\n  1798→// Shadowing\n  1799→type Manager struct {\n  1800→    Employee\n  1801→    Name string  // Shadows Person.Name\n  1802→}\n  1803→\n  1804→mgr := Manager{\n  1805→    Employee: emp,\n  1806→    Name:     \"Manager Name\",  // This shadows Employee.Person.Name\n  1807→}\n  1808→\n  1809→fmt.Println(mgr.Name)              // \"Manager Name\"\n  1810→fmt.Println(mgr.Employee.Name)     // \"Alice\"\n  1811→fmt.Println(mgr.Employee.Person.Name)  // \"Alice\"\n  1812→```\n  1813→\n  1814→### Interface Embedding\n  1815→\n  1816→```go\n  1817→// Base interfaces\n  1818→type Reader interface {\n  1819→    Read([]byte) (int, error)\n  1820→}\n  1821→\n  1822→type Writer interface {\n  1823→    Write([]byte) (int, error)\n  1824→}\n  1825→\n  1826→type Closer interface {\n  1827→    Close() error\n  1828→}\n  1829→\n  1830→// Embedded interfaces\n  1831→type ReadWriter interface {\n  1832→    Reader\n  1833→    Writer\n  1834→}\n  1835→\n  1836→type ReadWriteCloser interface {\n  1837→    Reader\n  1838→    Writer\n  1839→    Closer\n  1840→}\n  1841→\n  1842→// Alternative syntax\n  1843→type ReadWriteCloser interface {\n  1844→    Read([]byte) (int, error)\n  1845→    Write([]byte) (int, error)\n  1846→    Close() error\n  1847→}\n  1848→\n  1849→// Implementation\n  1850→type File struct {\n  1851→    // fields\n  1852→}\n  1853→\n  1854→func (f *File) Read(p []byte) (int, error) {\n  1855→    // implementation\n  1856→}\n  1857→\n  1858→func (f *File) Write(p []byte) (int, error) {\n  1859→    // implementation\n  1860→}\n  1861→\n  1862→func (f *File) Close() error {\n  1863→    // implementation\n  1864→}\n  1865→\n  1866→// File now implements ReadWriteCloser\n  1867→var rwc ReadWriteCloser = &File{}\n  1868→```\n  1869→\n  1870→## Generics\n  1871→\n  1872→### Generic Functions\n  1873→\n  1874→```go\n  1875→// Generic function with type parameter\n  1876→func Max[T comparable](a, b T) T {\n  1877→    if a > b {\n  1878→        return a\n  1879→    }\n  1880→    return b\n  1881→}\n  1882→\n  1883→// Usage\n  1884→maxInt := Max(10, 20)           // Type inferred\n  1885→maxFloat := Max[float64](3.14, 2.71)  // Explicit type\n  1886→\n  1887→// Multiple type parameters\n  1888→func Swap[T, U any](a T, b U) (U, T) {\n  1889→    return b, a\n  1890→}\n  1891→\n  1892→// Type constraints\n  1893→type Number interface {\n  1894→    int | int32 | int64 | float32 | float64\n  1895→}\n  1896→\n  1897→func Sum[T Number](numbers []T) T {\n  1898→    var sum T\n  1899→    for _, n := range numbers {\n  1900→        sum += n\n  1901→    }\n  1902→    return sum\n  1903→}\n  1904→\n  1905→// Using standard constraints\n  1906→import \"golang.org/x/exp/constraints\"\n  1907→\n  1908→func Min[T constraints.Ordered](a, b T) T {\n  1909→    if a < b {\n  1910→        return a\n  1911→    }\n  1912→    return b\n  1913→}\n  1914→```\n  1915→\n  1916→### Generic Types\n  1917→\n  1918→```go\n  1919→// Generic struct\n  1920→type Stack[T any] struct {\n  1921→    items []T\n  1922→}\n  1923→\n  1924→func (s *Stack[T]) Push(item T) {\n  1925→    s.items = append(s.items, item)\n  1926→}\n  1927→\n  1928→func (s *Stack[T]) Pop() (T, bool) {\n  1929→    var zero T\n  1930→    if len(s.items) == 0 {\n  1931→        return zero, false\n  1932→    }\n  1933→    item := s.items[len(s.items)-1]\n  1934→    s.items = s.items[:len(s.items)-1]\n  1935→    return item, true\n  1936→}\n  1937→\n  1938→// Usage\n  1939→intStack := Stack[int]{}\n  1940→intStack.Push(42)\n  1941→value, ok := intStack.Pop()\n  1942→\n  1943→// Generic interface\n  1944→type Container[T any] interface {\n  1945→    Add(T)\n  1946→    Get(int) T\n  1947→    Size() int\n  1948→}\n  1949→\n  1950→// Type inference with generics\n  1951→type Pair[T, U any] struct {\n  1952→    First  T\n  1953→    Second U\n  1954→}\n  1955→\n  1956→// Constructor function\n  1957→func NewPair[T, U any](first T, second U) Pair[T, U] {\n  1958→    return Pair[T, U]{First: first, Second: second}\n  1959→}\n  1960→\n  1961→// Type inference in use\n  1962→p := NewPair(1, \"hello\")  // Pair[int, string] inferred\n  1963→```\n  1964→\n  1965→### Type Constraints\n  1966→\n  1967→```go\n  1968→// Custom constraints\n  1969→type Signed interface {\n  1970→    ~int | ~int8 | ~int16 | ~int32 | ~int64\n  1971→}\n  1972→\n  1973→type Unsigned interface {\n  1974→    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64\n  1975→}\n  1976→\n  1977→type Integer interface {\n  1978→    Signed | Unsigned\n  1979→}\n  1980→\n  1981→// Tilde (~) allows underlying types\n  1982→type MyInt int\n  1983→\n  1984→func Double[T ~int](x T) T {\n  1985→    return x * 2\n  1986→}\n  1987→\n  1988→var mi MyInt = 5\n  1989→result := Double(mi)  // Works because MyInt's underlying type is int\n  1990→\n  1991→// Constraint with methods\n  1992→type Stringer interface {\n  1993→    String() string\n  1994→}\n  1995→\n  1996→func PrintAll[T Stringer](items []T) {\n  1997→    for _, item := range items {\n  1998→        fmt.Println(item.String())\n  1999→    }\n  2000→}\n  2001→\n  2002→// Complex constraints\n  2003→type Number interface {\n  2004→    ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n  2005→    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |\n  2006→    ~float32 | ~float64\n  2007→}\n  2008→\n  2009→type Addable[T any] interface {\n  2010→    Add(T) T\n  2011→}\n  2012→\n  2013→type AddableNumber[T Number] interface {\n  2014→    Number\n  2015→    Addable[T]\n  2016→}\n  2017→```\n  2018→\n  2019→## Best Practices Summary\n  2020→\n  2021→### Code Organization\n  2022→- Keep packages small and focused\n  2023→- Use clear, descriptive names\n  2024→- Group related functionality\n  2025→- Minimize package dependencies\n  2026→- Use internal packages for private code\n  2027→\n  2028→### Error Handling\n  2029→- Always check errors\n  2030→- Wrap errors with context\n  2031→- Use sentinel errors for known conditions\n  2032→- Create custom error types when needed\n  2033→- Handle errors at the appropriate level\n  2034→\n  2035→### Concurrency\n  2036→- Don't communicate by sharing memory; share memory by communicating\n  2037→- Use channels for coordination\n  2038→- Keep goroutines simple\n  2039→- Always handle goroutine cleanup\n  2040→- Use context for cancellation\n  2041→\n  2042→### Performance\n  2043→- Measure before optimizing\n  2044→- Preallocate slices when size is known\n  2045→- Use string.Builder for string concatenation\n  2046→- Be aware of memory allocations\n  2047→- Profile your code\n  2048→\n  2049→### Testing\n  2050→- Write table-driven tests\n  2051→- Test edge cases\n  2052→- Use subtests for better organization\n  2053→- Mock external dependencies\n  2054→- Aim for high test coverage\n  2055→\n  2056→### Documentation\n  2057→- Document all exported items\n  2058→- Write clear package documentation\n  2059→- Include examples in documentation\n  2060→- Keep comments up to date\n  2061→- Use godoc format\n  2062→\n  2063→This comprehensive guide covers the fundamental aspects of Go programming. Each topic includes practical examples and best practices to help write idiomatic, efficient Go code."}]},"uuid":"585f78f1-2c40-413f-9eaa-bd1364fb728a","timestamp":"2025-08-13T07:53:18.026Z","toolUseResult":{"type":"update","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md","content":"# Go Language Fundamentals - Complete Reference\n\n## Table of Contents\n1. [Introduction](#introduction)\n2. [Basic Syntax](#basic-syntax)\n3. [Variables and Constants](#variables-and-constants)\n4. [Data Types](#data-types)\n5. [Control Flow](#control-flow)\n6. [Functions](#functions)\n7. [Methods](#methods)\n8. [Structs](#structs)\n9. [Interfaces](#interfaces)\n10. [Pointers](#pointers)\n11. [Arrays and Slices](#arrays-and-slices)\n12. [Maps](#maps)\n13. [Error Handling](#error-handling)\n14. [Packages and Modules](#packages-and-modules)\n15. [Type Assertions and Type Switches](#type-assertions-and-type-switches)\n16. [Embedding and Composition](#embedding-and-composition)\n17. [Generics](#generics)\n\n## Introduction\n\nGo is a statically typed, compiled language designed for simplicity, efficiency, and reliable software. Created at Google in 2007 by Robert Griesemer, Rob Pike, and Ken Thompson, Go combines the performance of compiled languages with the ease of programming of dynamic languages.\n\n### Core Philosophy\n- **Simplicity**: Less is exponentially more\n- **Readability**: Code is read more often than written\n- **Efficiency**: Fast compilation, fast execution\n- **Concurrency**: Built-in primitives for concurrent programming\n- **Pragmatism**: Solve real problems with practical solutions\n\n## Basic Syntax\n\n### Program Structure\n\nEvery Go program starts with a package declaration and imports:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello, Go!\")\n}\n```\n\n### Comments\n\n```go\n// Single-line comment\n\n/*\n   Multi-line comment\n   Can span multiple lines\n*/\n\n// Package documentation comment (must precede package declaration)\n// Package math provides basic mathematical functions.\npackage math\n\n// Function documentation (must precede function declaration)\n// Add returns the sum of two integers.\nfunc Add(a, b int) int {\n    return a + b\n}\n```\n\n### Naming Conventions\n\n```go\n// Exported (public) - starts with uppercase\ntype Strategy struct{}\nfunc CalculateProfit() {}\nconst MaxRetries = 3\nvar DefaultTimeout = 5 * time.Second\n\n// Unexported (private) - starts with lowercase\ntype position struct{}\nfunc calculateLoss() {}\nconst maxAttempts = 5\nvar defaultBuffer = 1024\n\n// Package names - lowercase, single word\npackage trading  // Good\npackage tradingEngine  // Bad - use trading or engine\n\n// Interface names - typically end with -er\ntype Reader interface{}\ntype Writer interface{}\ntype Closer interface{}\ntype ReadWriteCloser interface{}  // Composition\n\n// Acronyms - keep consistent case\nvar httpClient HTTP  // Bad\nvar HTTPClient HTTP  // Good\nvar xmlParser XML    // Bad\nvar XMLParser XML    // Good\n```\n\n## Variables and Constants\n\n### Variable Declaration\n\n```go\n// var declaration with type\nvar name string\nvar age int\nvar balance float64\n\n// var declaration with initialization\nvar name string = \"John\"\nvar age int = 30\nvar balance = 1000.50  // Type inferred\n\n// Short variable declaration (only inside functions)\nname := \"John\"\nage := 30\nbalance := 1000.50\n\n// Multiple variable declaration\nvar (\n    firstName string = \"John\"\n    lastName  string = \"Doe\"\n    age       int    = 30\n)\n\n// Multiple assignment\nx, y := 10, 20\na, b = b, a  // Swap values\n\n// Blank identifier for unused values\n_, err := someFunction()  // Ignore first return value\n```\n\n### Constants\n\n```go\n// Single constant\nconst Pi = 3.14159\nconst MaxRetries = 3\nconst Message = \"Hello\"\n\n// Typed constants\nconst MaxInt int = 1000\nconst Timeout time.Duration = 5 * time.Second\n\n// Multiple constants\nconst (\n    StatusOK       = 200\n    StatusNotFound = 404\n    StatusError    = 500\n)\n\n// iota - constant generator\nconst (\n    Sunday = iota  // 0\n    Monday         // 1\n    Tuesday        // 2\n    Wednesday      // 3\n    Thursday       // 4\n    Friday         // 5\n    Saturday       // 6\n)\n\n// iota with expressions\nconst (\n    _  = iota             // 0 (ignored)\n    KB = 1 << (10 * iota) // 1024\n    MB                    // 1048576\n    GB                    // 1073741824\n    TB                    // 1099511627776\n)\n\n// Bit flags with iota\nconst (\n    ReadPermission = 1 << iota  // 1\n    WritePermission              // 2\n    ExecutePermission            // 4\n)\n```\n\n## Data Types\n\n### Basic Types\n\n```go\n// Boolean\nvar isActive bool = true\nvar isComplete bool  // Zero value: false\n\n// Integers\nvar i8 int8 = 127                    // -128 to 127\nvar i16 int16 = 32767                // -32768 to 32767\nvar i32 int32 = 2147483647           // -2147483648 to 2147483647\nvar i64 int64 = 9223372036854775807  // -9223372036854775808 to 9223372036854775807\nvar i int = 42                       // Platform dependent (32 or 64 bit)\n\n// Unsigned integers\nvar ui8 uint8 = 255                  // 0 to 255 (byte is alias)\nvar ui16 uint16 = 65535              // 0 to 65535\nvar ui32 uint32 = 4294967295         // 0 to 4294967295\nvar ui64 uint64 = 18446744073709551615  // 0 to 18446744073709551615\nvar ui uint = 42                     // Platform dependent\n\n// Floating point\nvar f32 float32 = 3.14               // IEEE-754 32-bit\nvar f64 float64 = 3.141592653589793  // IEEE-754 64-bit\n\n// Complex numbers\nvar c64 complex64 = 1 + 2i           // float32 real and imaginary\nvar c128 complex128 = 1 + 2i         // float64 real and imaginary\n\n// Strings\nvar str string = \"Hello, Go!\"        // UTF-8 encoded\nvar multiline = `This is\na multiline\nstring`                               // Raw string literal\n\n// Rune (Unicode code point)\nvar r rune = 'A'                     // int32 alias\nvar emoji rune = '😀'\n\n// Byte\nvar b byte = 65                      // uint8 alias\n```\n\n### Type Conversions\n\n```go\n// Explicit type conversion required\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(i)\n\n// String conversions\nimport \"strconv\"\n\n// Int to string\ns := strconv.Itoa(42)\ns := strconv.FormatInt(42, 10)  // base 10\n\n// String to int\ni, err := strconv.Atoi(\"42\")\ni64, err := strconv.ParseInt(\"42\", 10, 64)\n\n// Float to string\ns := strconv.FormatFloat(3.14, 'f', 2, 64)  // 2 decimal places\n\n// String to float\nf, err := strconv.ParseFloat(\"3.14\", 64)\n\n// Type assertions (for interfaces)\nvar x interface{} = \"hello\"\ns := x.(string)  // Panics if x is not string\ns, ok := x.(string)  // Safe assertion with ok check\n```\n\n### Zero Values\n\n```go\n// All types have zero values\nvar b bool        // false\nvar i int         // 0\nvar f float64     // 0.0\nvar s string      // \"\"\nvar p *int        // nil\nvar a []int       // nil\nvar m map[string]int  // nil\nvar c chan int    // nil\nvar fn func()     // nil\nvar iface error   // nil\n```\n\n## Control Flow\n\n### If Statements\n\n```go\n// Basic if\nif x > 0 {\n    fmt.Println(\"Positive\")\n}\n\n// If-else\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else {\n    fmt.Println(\"Non-positive\")\n}\n\n// If-else if-else\nif x > 0 {\n    fmt.Println(\"Positive\")\n} else if x < 0 {\n    fmt.Println(\"Negative\")\n} else {\n    fmt.Println(\"Zero\")\n}\n\n// If with initialization\nif err := doSomething(); err != nil {\n    return err  // err is scoped to if block\n}\n\n// Common patterns\n// Check error immediately\nif err != nil {\n    return fmt.Errorf(\"failed to process: %w\", err)\n}\n\n// Check boolean\nif !isValid {\n    return errors.New(\"invalid input\")\n}\n\n// Check nil\nif data == nil {\n    return errors.New(\"data is nil\")\n}\n```\n\n### Switch Statements\n\n```go\n// Basic switch\nswitch day {\ncase \"Monday\":\n    fmt.Println(\"Start of work week\")\ncase \"Friday\":\n    fmt.Println(\"TGIF!\")\ncase \"Saturday\", \"Sunday\":\n    fmt.Println(\"Weekend!\")\ndefault:\n    fmt.Println(\"Midweek\")\n}\n\n// Switch with no expression (like if-else chain)\nswitch {\ncase x < 0:\n    fmt.Println(\"Negative\")\ncase x == 0:\n    fmt.Println(\"Zero\")\ncase x > 0:\n    fmt.Println(\"Positive\")\n}\n\n// Switch with initialization\nswitch os := runtime.GOOS; os {\ncase \"darwin\":\n    fmt.Println(\"macOS\")\ncase \"linux\":\n    fmt.Println(\"Linux\")\ndefault:\n    fmt.Printf(\"Unknown OS: %s\\n\", os)\n}\n\n// Type switch\nfunc describe(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"Boolean: %t\\n\", v)\n    case nil:\n        fmt.Println(\"nil value\")\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\n// Fallthrough (rarely used)\nswitch num {\ncase 1:\n    fmt.Println(\"One\")\n    fallthrough  // Continue to next case\ncase 2:\n    fmt.Println(\"One or Two\")\n}\n```\n\n### Loops\n\n```go\n// For loop - traditional\nfor i := 0; i < 10; i++ {\n    fmt.Println(i)\n}\n\n// For loop - while style\ncount := 0\nfor count < 10 {\n    fmt.Println(count)\n    count++\n}\n\n// Infinite loop\nfor {\n    // Break or return to exit\n    if condition {\n        break\n    }\n}\n\n// Range over slice\nnumbers := []int{1, 2, 3, 4, 5}\nfor index, value := range numbers {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n\n// Range over slice - values only\nfor _, value := range numbers {\n    fmt.Println(value)\n}\n\n// Range over slice - indices only\nfor index := range numbers {\n    fmt.Println(index)\n}\n\n// Range over map\nages := map[string]int{\"Alice\": 30, \"Bob\": 25}\nfor name, age := range ages {\n    fmt.Printf(\"%s is %d years old\\n\", name, age)\n}\n\n// Range over string (gives runes)\nfor index, runeValue := range \"Hello, 世界\" {\n    fmt.Printf(\"%d: %c\\n\", index, runeValue)\n}\n\n// Range over channel\nch := make(chan int)\ngo func() {\n    for i := 0; i < 5; i++ {\n        ch <- i\n    }\n    close(ch)\n}()\nfor value := range ch {\n    fmt.Println(value)\n}\n\n// Continue and break with labels\nouter:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        if i == 1 && j == 1 {\n            break outer  // Break outer loop\n        }\n        fmt.Printf(\"(%d, %d) \", i, j)\n    }\n}\n```\n\n### Defer, Panic, and Recover\n\n```go\n// Defer - executes when function returns\nfunc readFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()  // Executed when function returns\n    \n    // Read file...\n    return nil\n}\n\n// Multiple defers - LIFO order\nfunc example() {\n    defer fmt.Println(\"Third\")\n    defer fmt.Println(\"Second\")\n    defer fmt.Println(\"First\")\n    // Prints: First, Second, Third\n}\n\n// Defer with arguments - evaluated immediately\nfunc deferArgs() {\n    i := 0\n    defer fmt.Println(i)  // Prints 0, not 1\n    i++\n}\n\n// Defer with closure - captures variables\nfunc deferClosure() {\n    i := 0\n    defer func() {\n        fmt.Println(i)  // Prints 1\n    }()\n    i++\n}\n\n// Panic - runtime error\nfunc divide(a, b int) int {\n    if b == 0 {\n        panic(\"division by zero\")\n    }\n    return a / b\n}\n\n// Recover - catch panic\nfunc safeFunction() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Recovered from panic: %v\\n\", r)\n        }\n    }()\n    \n    // Code that might panic\n    panic(\"something went wrong\")\n}\n\n// Practical error recovery pattern\nfunc robustFunction() (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    \n    // Potentially panicking code\n    return nil\n}\n```\n\n## Functions\n\n### Function Declaration\n\n```go\n// Basic function\nfunc greet() {\n    fmt.Println(\"Hello!\")\n}\n\n// Function with parameters\nfunc add(a int, b int) int {\n    return a + b\n}\n\n// Shorthand for same type parameters\nfunc add(a, b int) int {\n    return a + b\n}\n\n// Multiple return values\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// Named return values\nfunc getCoordinates() (x, y int) {\n    x = 10\n    y = 20\n    return  // Naked return\n}\n\n// Named returns with explicit values\nfunc calculate(a, b int) (sum, product int) {\n    sum = a + b\n    product = a * b\n    return sum, product  // Can be explicit\n}\n\n// Variadic functions\nfunc sum(numbers ...int) int {\n    total := 0\n    for _, n := range numbers {\n        total += n\n    }\n    return total\n}\n\n// Calling variadic functions\nresult := sum(1, 2, 3, 4, 5)\nnums := []int{1, 2, 3}\nresult := sum(nums...)  // Spread slice\n```\n\n### Function Types and Values\n\n```go\n// Function as type\ntype Operation func(int, int) int\n\nfunc add(a, b int) int { return a + b }\nfunc multiply(a, b int) int { return a * b }\n\nvar op Operation = add\nresult := op(5, 3)  // 8\n\n// Function as parameter\nfunc apply(op Operation, a, b int) int {\n    return op(a, b)\n}\n\nresult := apply(add, 5, 3)\nresult = apply(multiply, 5, 3)\n\n// Function returning function\nfunc makeAdder(x int) func(int) int {\n    return func(y int) int {\n        return x + y\n    }\n}\n\nadd5 := makeAdder(5)\nresult := add5(3)  // 8\n\n// Anonymous functions\nfunc() {\n    fmt.Println(\"Anonymous function\")\n}()  // Immediately invoked\n\n// Assign to variable\ngreet := func(name string) {\n    fmt.Printf(\"Hello, %s!\\n\", name)\n}\ngreet(\"World\")\n```\n\n### Closures\n\n```go\n// Closure captures variables\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nc := counter()\nfmt.Println(c())  // 1\nfmt.Println(c())  // 2\nfmt.Println(c())  // 3\n\n// Closure in loop (common pitfall)\n// Wrong way\nfuncs := []func(){}\nfor i := 0; i < 3; i++ {\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // All print 3\n    })\n}\n\n// Correct way\nfor i := 0; i < 3; i++ {\n    i := i  // Shadow variable\n    funcs = append(funcs, func() {\n        fmt.Println(i)  // Prints 0, 1, 2\n    })\n}\n\n// Alternative correct way\nfor i := 0; i < 3; i++ {\n    func(n int) {\n        funcs = append(funcs, func() {\n            fmt.Println(n)\n        })\n    }(i)\n}\n```\n\n## Methods\n\n### Method Declaration\n\n```go\n// Method on struct\ntype Rectangle struct {\n    Width, Height float64\n}\n\n// Value receiver\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\n// Pointer receiver\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n\n// Using methods\nrect := Rectangle{Width: 10, Height: 5}\narea := rect.Area()        // 50\nrect.Scale(2)              // Width=20, Height=10\n\n// Method on non-struct types\ntype MyInt int\n\nfunc (m MyInt) IsEven() bool {\n    return m%2 == 0\n}\n\nvar num MyInt = 42\nif num.IsEven() {\n    fmt.Println(\"Even number\")\n}\n\n// Method on pointer vs value\ntype Counter struct {\n    value int\n}\n\n// Value receiver - cannot modify\nfunc (c Counter) GetValue() int {\n    return c.value\n}\n\n// Pointer receiver - can modify\nfunc (c *Counter) Increment() {\n    c.value++\n}\n\n// Pointer receiver - can handle nil\nfunc (c *Counter) SafeIncrement() {\n    if c == nil {\n        return\n    }\n    c.value++\n}\n```\n\n### Method Sets\n\n```go\n// Method set rules:\n// - Type T has method set of all methods with receiver T\n// - Type *T has method set of all methods with receiver T or *T\n\ntype Shape struct {\n    Name string\n}\n\nfunc (s Shape) GetName() string {\n    return s.Name\n}\n\nfunc (s *Shape) SetName(name string) {\n    s.Name = name\n}\n\n// Value type can call value receiver methods\nshape := Shape{Name: \"Circle\"}\nname := shape.GetName()  // OK\n\n// Value type automatically gets address for pointer receiver\nshape.SetName(\"Square\")  // OK (Go converts to (&shape).SetName())\n\n// Pointer type can call both\nshapePtr := &Shape{Name: \"Triangle\"}\nname = shapePtr.GetName()  // OK\nshapePtr.SetName(\"Pentagon\")  // OK\n```\n\n## Structs\n\n### Struct Declaration and Usage\n\n```go\n// Basic struct\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n}\n\n// Creating structs\np1 := Person{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Age:       30,\n}\n\n// Positional initialization (not recommended)\np2 := Person{\"Jane\", \"Doe\", 25}\n\n// Zero value struct\nvar p3 Person  // All fields have zero values\n\n// Accessing fields\nfmt.Println(p1.FirstName)\np1.Age = 31\n\n// Struct pointer\nptr := &Person{FirstName: \"Bob\"}\nptr.Age = 40  // Automatic dereferencing\n\n// Anonymous struct\npoint := struct {\n    X, Y int\n}{X: 10, Y: 20}\n\n// Struct tags\ntype User struct {\n    ID        int    `json:\"id\" db:\"user_id\"`\n    Email     string `json:\"email\" validate:\"required,email\"`\n    Password  string `json:\"-\"`  // Omit from JSON\n    CreatedAt time.Time `json:\"created_at,omitempty\"`\n}\n\n// Accessing tags via reflection\nimport \"reflect\"\n\nt := reflect.TypeOf(User{})\nfield, _ := t.FieldByName(\"Email\")\nfmt.Println(field.Tag.Get(\"json\"))     // \"email\"\nfmt.Println(field.Tag.Get(\"validate\")) // \"required,email\"\n```\n\n### Struct Embedding\n\n```go\n// Embedding for composition\ntype Address struct {\n    Street  string\n    City    string\n    Country string\n}\n\ntype Employee struct {\n    Person  // Embedded struct\n    Address // Another embedded struct\n    Salary  float64\n}\n\nemp := Employee{\n    Person: Person{\n        FirstName: \"Alice\",\n        LastName:  \"Smith\",\n        Age:       28,\n    },\n    Address: Address{\n        City:    \"New York\",\n        Country: \"USA\",\n    },\n    Salary: 75000,\n}\n\n// Promoted fields\nfmt.Println(emp.FirstName)  // Promoted from Person\nfmt.Println(emp.City)       // Promoted from Address\n\n// Explicit access\nfmt.Println(emp.Person.FirstName)\n\n// Method promotion\ntype Writer struct{}\n\nfunc (w Writer) Write(data []byte) (int, error) {\n    return len(data), nil\n}\n\ntype Logger struct {\n    Writer  // Embedded\n    prefix string\n}\n\nlog := Logger{prefix: \"[INFO]\"}\nlog.Write([]byte(\"message\"))  // Promoted method\n```\n\n### Struct Comparison\n\n```go\n// Structs are comparable if all fields are comparable\ntype Point struct {\n    X, Y int\n}\n\np1 := Point{1, 2}\np2 := Point{1, 2}\np3 := Point{2, 3}\n\nfmt.Println(p1 == p2)  // true\nfmt.Println(p1 == p3)  // false\n\n// Non-comparable structs (contain slices, maps, functions)\ntype Data struct {\n    Values []int  // Slices are not comparable\n}\n\n// This won't compile:\n// d1 := Data{Values: []int{1, 2}}\n// d2 := Data{Values: []int{1, 2}}\n// fmt.Println(d1 == d2)  // Compile error\n```\n\n## Interfaces\n\n### Interface Declaration and Implementation\n\n```go\n// Interface declaration\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\n// Interface with multiple methods\ntype ReadWriter interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n}\n\n// Empty interface (any type)\ntype Any interface{}  // Pre Go 1.18\ntype Any = any        // Go 1.18+\n\n// Implicit implementation\ntype FileWriter struct {\n    filename string\n}\n\nfunc (f FileWriter) Write(data []byte) (int, error) {\n    // Implementation\n    return len(data), nil\n}\n\n// FileWriter implements Writer implicitly\nvar w Writer = FileWriter{filename: \"test.txt\"}\n```\n\n### Interface Composition\n\n```go\n// Composing interfaces\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Composed interface\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Alternative inline composition\ntype ReadWriter interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n}\n```\n\n### Interface Values and nil\n\n```go\n// Interface values have two components: type and value\nvar w Writer\nfmt.Printf(\"Type: %T, Value: %v\\n\", w, w)  // Type: <nil>, Value: <nil>\n\n// nil interface vs interface with nil value\ntype MyWriter struct{}\n\nfunc (m *MyWriter) Write(data []byte) (int, error) {\n    if m == nil {\n        return 0, errors.New(\"nil writer\")\n    }\n    return len(data), nil\n}\n\nvar mw *MyWriter = nil\nvar w Writer = mw\n// w is not nil (has type *MyWriter), but its value is nil\n\nif w == nil {\n    fmt.Println(\"w is nil\")  // Won't print\n}\n\n// Check for nil value\nif mw == nil {\n    fmt.Println(\"mw is nil\")  // Will print\n}\n```\n\n### Type Assertions and Type Switches\n\n```go\n// Type assertion\nvar i interface{} = \"hello\"\n\n// Direct assertion (panics if wrong type)\ns := i.(string)\nfmt.Println(s)\n\n// Safe assertion with comma-ok\ns, ok := i.(string)\nif ok {\n    fmt.Println(\"String:\", s)\n}\n\n// Check interface implementation\nvar w io.Writer = &bytes.Buffer{}\nif buf, ok := w.(*bytes.Buffer); ok {\n    fmt.Println(\"It's a buffer:\", buf)\n}\n\n// Type switch\nfunc describe(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case io.Reader:\n        fmt.Println(\"It's a reader\")\n    case nil:\n        fmt.Println(\"It's nil\")\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n```\n\n### Common Interface Patterns\n\n```go\n// Stringer interface\ntype Stringer interface {\n    String() string\n}\n\ntype Point struct {\n    X, Y int\n}\n\nfunc (p Point) String() string {\n    return fmt.Sprintf(\"(%d, %d)\", p.X, p.Y)\n}\n\n// Error interface\ntype error interface {\n    Error() string\n}\n\ntype ValidationError struct {\n    Field string\n    Value string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for field %s: %s\", e.Field, e.Value)\n}\n\n// Sort interface\ntype Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\n// Custom sort implementation\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n\n// Usage\npeople := []Person{{Name: \"Alice\", Age: 30}, {Name: \"Bob\", Age: 25}}\nsort.Sort(ByAge(people))\n```\n\n## Pointers\n\n### Pointer Basics\n\n```go\n// Declare pointer\nvar p *int\n\n// Get address of variable\nx := 42\np = &x\n\n// Dereference pointer\nfmt.Println(*p)  // 42\n*p = 100\nfmt.Println(x)   // 100\n\n// Pointer zero value is nil\nvar ptr *string\nif ptr == nil {\n    fmt.Println(\"ptr is nil\")\n}\n\n// New function allocates memory\nptr = new(string)\n*ptr = \"Hello\"\n\n// Pointer to struct\ntype Person struct {\n    Name string\n    Age  int\n}\n\nperson := &Person{Name: \"Alice\", Age: 30}\nperson.Age = 31  // Automatic dereferencing\n\n// Pointer arithmetic is NOT allowed in Go\n// p++  // This won't compile\n```\n\n### Pointers vs Values\n\n```go\n// Pass by value\nfunc modifyValue(x int) {\n    x = 100  // Doesn't affect original\n}\n\n// Pass by pointer\nfunc modifyPointer(x *int) {\n    *x = 100  // Modifies original\n}\n\nvalue := 42\nmodifyValue(value)\nfmt.Println(value)  // Still 42\n\nmodifyPointer(&value)\nfmt.Println(value)  // Now 100\n\n// Slices, maps, channels are reference types\nfunc modifySlice(s []int) {\n    s[0] = 100  // Modifies original\n}\n\nslice := []int{1, 2, 3}\nmodifySlice(slice)\nfmt.Println(slice)  // [100, 2, 3]\n\n// But reassigning doesn't affect original\nfunc reassignSlice(s []int) {\n    s = []int{4, 5, 6}  // Doesn't affect original\n}\n\n// To modify slice itself, use pointer\nfunc replaceSlice(s *[]int) {\n    *s = []int{4, 5, 6}\n}\n```\n\n## Arrays and Slices\n\n### Arrays\n\n```go\n// Array declaration\nvar arr [5]int              // [0 0 0 0 0]\narr[0] = 10\narr[4] = 50\n\n// Array initialization\narr := [5]int{1, 2, 3, 4, 5}\narr := [...]int{1, 2, 3}    // Compiler counts elements\narr := [5]int{0: 10, 4: 50} // Index:value pairs\n\n// Arrays are values (copied on assignment)\narr1 := [3]int{1, 2, 3}\narr2 := arr1\narr2[0] = 100\nfmt.Println(arr1)  // [1 2 3] - unchanged\nfmt.Println(arr2)  // [100 2 3]\n\n// Array size is part of type\nvar a [5]int\nvar b [10]int\n// a = b  // Won't compile - different types\n\n// Multidimensional arrays\nvar matrix [3][3]int\nmatrix[1][1] = 5\n\n// Array iteration\nfor i := 0; i < len(arr); i++ {\n    fmt.Println(arr[i])\n}\n\nfor index, value := range arr {\n    fmt.Printf(\"%d: %d\\n\", index, value)\n}\n```\n\n### Slices\n\n```go\n// Slice declaration\nvar slice []int            // nil slice\nslice = []int{}           // Empty slice\nslice = []int{1, 2, 3}    // Initialized slice\n\n// Make function\nslice = make([]int, 5)    // Length 5, capacity 5\nslice = make([]int, 5, 10) // Length 5, capacity 10\n\n// Slice from array\narr := [5]int{1, 2, 3, 4, 5}\nslice = arr[1:4]  // [2 3 4]\nslice = arr[:3]   // [1 2 3]\nslice = arr[2:]   // [3 4 5]\nslice = arr[:]    // [1 2 3 4 5]\n\n// Slice properties\nfmt.Println(len(slice))  // Length\nfmt.Println(cap(slice))  // Capacity\n\n// Append\nslice = []int{1, 2, 3}\nslice = append(slice, 4)\nslice = append(slice, 5, 6, 7)\nslice = append(slice, []int{8, 9}...)\n\n// Copy\nsrc := []int{1, 2, 3}\ndst := make([]int, len(src))\nn := copy(dst, src)  // Returns number copied\n\n// Slice tricks\n// Remove element at index i\nslice = append(slice[:i], slice[i+1:]...)\n\n// Insert element at index i\nslice = append(slice[:i], append([]int{x}, slice[i:]...)...)\n\n// Pop from end\nx := slice[len(slice)-1]\nslice = slice[:len(slice)-1]\n\n// Push to front\nslice = append([]int{x}, slice...)\n\n// Filter in place\nn := 0\nfor _, x := range slice {\n    if keepElement(x) {\n        slice[n] = x\n        n++\n    }\n}\nslice = slice[:n]\n```\n\n### Slice Internals\n\n```go\n// Slice header (conceptual)\ntype SliceHeader struct {\n    Data uintptr  // Pointer to underlying array\n    Len  int      // Current length\n    Cap  int      // Capacity\n}\n\n// Slices share underlying array\noriginal := []int{1, 2, 3, 4, 5}\nslice1 := original[1:4]  // [2 3 4]\nslice2 := original[2:5]  // [3 4 5]\n\nslice1[1] = 100  // Modifies shared array\nfmt.Println(slice2)  // [100 4 5]\n\n// Full slice expression controls capacity\nslice := original[1:3:4]  // [low:high:max]\n// len = high - low = 2\n// cap = max - low = 3\n\n// nil vs empty slice\nvar nilSlice []int        // nil\nemptySlice := []int{}     // Not nil, but empty\nmadeSlice := make([]int, 0) // Not nil, but empty\n\nfmt.Println(nilSlice == nil)    // true\nfmt.Println(emptySlice == nil)  // false\nfmt.Println(len(nilSlice))      // 0\nfmt.Println(len(emptySlice))    // 0\n\n// Both work with append\nnilSlice = append(nilSlice, 1)\nemptySlice = append(emptySlice, 1)\n```\n\n## Maps\n\n### Map Basics\n\n```go\n// Map declaration\nvar m map[string]int      // nil map\nm = make(map[string]int)  // Initialize\n\n// Map literal\nm = map[string]int{\n    \"Alice\": 30,\n    \"Bob\":   25,\n}\n\n// Operations\nm[\"Charlie\"] = 35         // Insert/Update\nage := m[\"Alice\"]         // Retrieve\ndelete(m, \"Bob\")          // Delete\n\n// Check if key exists\nage, exists := m[\"David\"]\nif exists {\n    fmt.Printf(\"David is %d years old\\n\", age)\n}\n\n// Zero value for missing key\nfmt.Println(m[\"Unknown\"])  // 0 (zero value for int)\n\n// Iteration (order is random)\nfor key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n\n// Keys only\nfor key := range m {\n    fmt.Println(key)\n}\n\n// Values only\nfor _, value := range m {\n    fmt.Println(value)\n}\n```\n\n### Map Patterns\n\n```go\n// Map as set\nset := make(map[string]bool)\nset[\"apple\"] = true\nset[\"banana\"] = true\n\nif set[\"apple\"] {\n    fmt.Println(\"apple is in the set\")\n}\n\n// Alternative set using empty struct (memory efficient)\ntype void struct{}\nvar member void\n\nset := make(map[string]void)\nset[\"apple\"] = member\nset[\"banana\"] = member\n\nif _, exists := set[\"apple\"]; exists {\n    fmt.Println(\"apple is in the set\")\n}\n\n// Counting with maps\ncounts := make(map[string]int)\nwords := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"}\n\nfor _, word := range words {\n    counts[word]++  // Works even if key doesn't exist\n}\n\n// Grouping with maps\ntype Person struct {\n    Name string\n    Age  int\n}\n\npeople := []Person{\n    {\"Alice\", 30},\n    {\"Bob\", 25},\n    {\"Charlie\", 30},\n    {\"David\", 25},\n}\n\nageGroups := make(map[int][]Person)\nfor _, person := range people {\n    ageGroups[person.Age] = append(ageGroups[person.Age], person)\n}\n\n// Map of maps\nnested := make(map[string]map[string]int)\nnested[\"scores\"] = make(map[string]int)\nnested[\"scores\"][\"Alice\"] = 95\nnested[\"scores\"][\"Bob\"] = 87\n\n// Safe nested access\nif scores, ok := nested[\"scores\"]; ok {\n    if score, ok := scores[\"Alice\"]; ok {\n        fmt.Printf(\"Alice's score: %d\\n\", score)\n    }\n}\n```\n\n### Maps and Concurrency\n\n```go\n// Maps are not safe for concurrent access\n// Use sync.Map or mutex\n\nimport \"sync\"\n\n// With mutex\ntype SafeMap struct {\n    mu sync.RWMutex\n    m  map[string]int\n}\n\nfunc (sm *SafeMap) Set(key string, value int) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    sm.m[key] = value\n}\n\nfunc (sm *SafeMap) Get(key string) (int, bool) {\n    sm.mu.RLock()\n    defer sm.mu.RUnlock()\n    value, exists := sm.m[key]\n    return value, exists\n}\n\n// Using sync.Map (for specific use cases)\nvar m sync.Map\n\n// Store\nm.Store(\"key\", \"value\")\n\n// Load\nvalue, ok := m.Load(\"key\")\n\n// LoadOrStore\nactual, loaded := m.LoadOrStore(\"key\", \"new-value\")\n\n// Delete\nm.Delete(\"key\")\n\n// Range\nm.Range(func(key, value interface{}) bool {\n    fmt.Printf(\"%v: %v\\n\", key, value)\n    return true  // Continue iteration\n})\n```\n\n## Error Handling\n\n### Error Interface\n\n```go\n// Error interface\ntype error interface {\n    Error() string\n}\n\n// Creating errors\nimport \"errors\"\n\nerr := errors.New(\"something went wrong\")\nerr := fmt.Errorf(\"failed to process %s: %v\", filename, originalErr)\n\n// Custom error types\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Msg   string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error: field=%s value=%v msg=%s\", \n        e.Field, e.Value, e.Msg)\n}\n\n// Sentinel errors\nvar (\n    ErrNotFound   = errors.New(\"not found\")\n    ErrPermission = errors.New(\"permission denied\")\n    ErrTimeout    = errors.New(\"operation timed out\")\n)\n\n// Error wrapping (Go 1.13+)\noriginalErr := errors.New(\"original error\")\nwrappedErr := fmt.Errorf(\"wrapped: %w\", originalErr)\n\n// Unwrap errors\nif errors.Is(wrappedErr, originalErr) {\n    fmt.Println(\"Error is originalErr\")\n}\n\nvar validationErr ValidationError\nif errors.As(wrappedErr, &validationErr) {\n    fmt.Printf(\"Validation error: %s\\n\", validationErr.Field)\n}\n```\n\n### Error Handling Patterns\n\n```go\n// Immediate error checking\nresult, err := doSomething()\nif err != nil {\n    return fmt.Errorf(\"doSomething failed: %w\", err)\n}\n\n// Multiple error sources\nfunc processFile(filename string) error {\n    file, err := os.Open(filename)\n    if err != nil {\n        return fmt.Errorf(\"open file: %w\", err)\n    }\n    defer file.Close()\n    \n    data, err := io.ReadAll(file)\n    if err != nil {\n        return fmt.Errorf(\"read file: %w\", err)\n    }\n    \n    if err := processData(data); err != nil {\n        return fmt.Errorf(\"process data: %w\", err)\n    }\n    \n    return nil\n}\n\n// Error accumulation\nvar errs []error\n\nfor _, item := range items {\n    if err := process(item); err != nil {\n        errs = append(errs, err)\n    }\n}\n\nif len(errs) > 0 {\n    return fmt.Errorf(\"processing failed with %d errors\", len(errs))\n}\n\n// Retry pattern\nfunc retryOperation(maxAttempts int) error {\n    var lastErr error\n    \n    for i := 0; i < maxAttempts; i++ {\n        if err := attemptOperation(); err != nil {\n            lastErr = err\n            time.Sleep(time.Second * time.Duration(i+1))\n            continue\n        }\n        return nil  // Success\n    }\n    \n    return fmt.Errorf(\"failed after %d attempts: %w\", maxAttempts, lastErr)\n}\n\n// Cleanup on error\nfunc createResources() (err error) {\n    resource1, err := createResource1()\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if err != nil {\n            resource1.Cleanup()\n        }\n    }()\n    \n    resource2, err := createResource2()\n    if err != nil {\n        return err  // resource1 cleaned up by defer\n    }\n    \n    return nil\n}\n```\n\n## Packages and Modules\n\n### Package Organization\n\n```go\n// Package declaration (first non-comment line)\npackage mypackage\n\n// Package documentation\n// Package mypackage provides utilities for data processing.\n// It includes functions for parsing, validation, and transformation.\npackage mypackage\n\n// Import statements\nimport (\n    \"fmt\"           // Standard library\n    \"time\"\n    \n    \"github.com/pkg/errors\"  // External packages\n    \n    \"myproject/internal/utils\"  // Internal packages\n)\n\n// Import aliasing\nimport (\n    \"context\"\n    stdlog \"log\"  // Alias to avoid conflicts\n    . \"math\"      // Dot import (use sparingly)\n    _ \"image/png\" // Import for side effects only\n)\n\n// Package initialization\nfunc init() {\n    // Runs when package is imported\n    // Can have multiple init functions\n    fmt.Println(\"Package initialized\")\n}\n\n// Exported (public) - uppercase\nfunc PublicFunction() {}\ntype PublicType struct{}\nconst PublicConst = 42\nvar PublicVar = \"hello\"\n\n// Unexported (private) - lowercase\nfunc privateFunction() {}\ntype privateType struct{}\nconst privateConst = 42\nvar privateVar = \"hello\"\n```\n\n### Module Management\n\n```bash\n# Initialize module\ngo mod init github.com/username/projectname\n\n# Add dependencies\ngo get github.com/pkg/errors\ngo get github.com/stretchr/testify@v1.8.0\n\n# Update dependencies\ngo get -u ./...              # Update all\ngo get -u github.com/pkg/errors  # Update specific\n\n# Clean up\ngo mod tidy  # Remove unused dependencies\n\n# Vendor dependencies\ngo mod vendor  # Copy dependencies to vendor/\n\n# Module directives in go.mod\nmodule github.com/username/project\n\ngo 1.21\n\nrequire (\n    github.com/pkg/errors v0.9.1\n    github.com/stretchr/testify v1.8.0\n)\n\nreplace github.com/old/package => github.com/new/package v1.0.0\n\nexclude github.com/bad/package v1.0.0\n```\n\n### Internal Packages\n\n```go\n// Internal packages can only be imported by nearby code\nmyproject/\n├── cmd/\n│   └── app/\n│       └── main.go  // Can import internal/\n├── internal/\n│   ├── database/    // Only accessible within myproject\n│   └── utils/\n├── pkg/             // Public packages\n│   └── api/\n└── go.mod\n\n// This import works in myproject\nimport \"myproject/internal/database\"\n\n// This import fails outside myproject\nimport \"github.com/other/project/internal/database\"  // Error\n```\n\n## Type Assertions and Type Switches\n\n### Type Assertions\n\n```go\n// Basic type assertion\nvar i interface{} = \"hello\"\ns := i.(string)  // Panics if not string\nfmt.Println(s)\n\n// Safe type assertion\ns, ok := i.(string)\nif !ok {\n    fmt.Println(\"Not a string\")\n}\n\n// Common patterns\nfunc processValue(v interface{}) {\n    // Try multiple types\n    switch value := v.(type) {\n    case string:\n        fmt.Printf(\"String: %s\\n\", value)\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", value)\n    case []byte:\n        fmt.Printf(\"Bytes: %s\\n\", string(value))\n    default:\n        fmt.Printf(\"Unknown: %T\\n\", value)\n    }\n}\n\n// Check for interface implementation\ntype Stringer interface {\n    String() string\n}\n\nfunc toString(v interface{}) string {\n    if s, ok := v.(Stringer); ok {\n        return s.String()\n    }\n    return fmt.Sprintf(\"%v\", v)\n}\n\n// Nil interface gotcha\nvar p *Person  // nil pointer\nvar i interface{} = p\n\nif i == nil {\n    fmt.Println(\"i is nil\")  // Won't print!\n}\n\nif p == nil {\n    fmt.Println(\"p is nil\")  // Will print\n}\n```\n\n## Embedding and Composition\n\n### Struct Embedding\n\n```go\n// Base types\ntype Person struct {\n    Name string\n    Age  int\n}\n\ntype Address struct {\n    Street string\n    City   string\n}\n\n// Embedding\ntype Employee struct {\n    Person      // Anonymous field\n    Address     // Another anonymous field\n    Department string\n    Salary     float64\n}\n\nemp := Employee{\n    Person:     Person{Name: \"Alice\", Age: 30},\n    Address:    Address{City: \"New York\"},\n    Department: \"Engineering\",\n}\n\n// Field promotion\nfmt.Println(emp.Name)  // Accessed directly\nfmt.Println(emp.City)\n\n// Method promotion\nfunc (p Person) Introduce() {\n    fmt.Printf(\"Hi, I'm %s\\n\", p.Name)\n}\n\nemp.Introduce()  // Method promoted from Person\n\n// Shadowing\ntype Manager struct {\n    Employee\n    Name string  // Shadows Person.Name\n}\n\nmgr := Manager{\n    Employee: emp,\n    Name:     \"Manager Name\",  // This shadows Employee.Person.Name\n}\n\nfmt.Println(mgr.Name)              // \"Manager Name\"\nfmt.Println(mgr.Employee.Name)     // \"Alice\"\nfmt.Println(mgr.Employee.Person.Name)  // \"Alice\"\n```\n\n### Interface Embedding\n\n```go\n// Base interfaces\ntype Reader interface {\n    Read([]byte) (int, error)\n}\n\ntype Writer interface {\n    Write([]byte) (int, error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Embedded interfaces\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n\n// Alternative syntax\ntype ReadWriteCloser interface {\n    Read([]byte) (int, error)\n    Write([]byte) (int, error)\n    Close() error\n}\n\n// Implementation\ntype File struct {\n    // fields\n}\n\nfunc (f *File) Read(p []byte) (int, error) {\n    // implementation\n}\n\nfunc (f *File) Write(p []byte) (int, error) {\n    // implementation\n}\n\nfunc (f *File) Close() error {\n    // implementation\n}\n\n// File now implements ReadWriteCloser\nvar rwc ReadWriteCloser = &File{}\n```\n\n## Generics\n\n### Generic Functions\n\n```go\n// Generic function with type parameter\nfunc Max[T comparable](a, b T) T {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n// Usage\nmaxInt := Max(10, 20)           // Type inferred\nmaxFloat := Max[float64](3.14, 2.71)  // Explicit type\n\n// Multiple type parameters\nfunc Swap[T, U any](a T, b U) (U, T) {\n    return b, a\n}\n\n// Type constraints\ntype Number interface {\n    int | int32 | int64 | float32 | float64\n}\n\nfunc Sum[T Number](numbers []T) T {\n    var sum T\n    for _, n := range numbers {\n        sum += n\n    }\n    return sum\n}\n\n// Using standard constraints\nimport \"golang.org/x/exp/constraints\"\n\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n### Generic Types\n\n```go\n// Generic struct\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    var zero T\n    if len(s.items) == 0 {\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\n// Usage\nintStack := Stack[int]{}\nintStack.Push(42)\nvalue, ok := intStack.Pop()\n\n// Generic interface\ntype Container[T any] interface {\n    Add(T)\n    Get(int) T\n    Size() int\n}\n\n// Type inference with generics\ntype Pair[T, U any] struct {\n    First  T\n    Second U\n}\n\n// Constructor function\nfunc NewPair[T, U any](first T, second U) Pair[T, U] {\n    return Pair[T, U]{First: first, Second: second}\n}\n\n// Type inference in use\np := NewPair(1, \"hello\")  // Pair[int, string] inferred\n```\n\n### Type Constraints\n\n```go\n// Custom constraints\ntype Signed interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64\n}\n\ntype Unsigned interface {\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64\n}\n\ntype Integer interface {\n    Signed | Unsigned\n}\n\n// Tilde (~) allows underlying types\ntype MyInt int\n\nfunc Double[T ~int](x T) T {\n    return x * 2\n}\n\nvar mi MyInt = 5\nresult := Double(mi)  // Works because MyInt's underlying type is int\n\n// Constraint with methods\ntype Stringer interface {\n    String() string\n}\n\nfunc PrintAll[T Stringer](items []T) {\n    for _, item := range items {\n        fmt.Println(item.String())\n    }\n}\n\n// Complex constraints\ntype Number interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |\n    ~float32 | ~float64\n}\n\ntype Addable[T any] interface {\n    Add(T) T\n}\n\ntype AddableNumber[T Number] interface {\n    Number\n    Addable[T]\n}\n```\n\n## Best Practices Summary\n\n### Code Organization\n- Keep packages small and focused\n- Use clear, descriptive names\n- Group related functionality\n- Minimize package dependencies\n- Use internal packages for private code\n\n### Error Handling\n- Always check errors\n- Wrap errors with context\n- Use sentinel errors for known conditions\n- Create custom error types when needed\n- Handle errors at the appropriate level\n\n### Concurrency\n- Don't communicate by sharing memory; share memory by communicating\n- Use channels for coordination\n- Keep goroutines simple\n- Always handle goroutine cleanup\n- Use context for cancellation\n\n### Performance\n- Measure before optimizing\n- Preallocate slices when size is known\n- Use string.Builder for string concatenation\n- Be aware of memory allocations\n- Profile your code\n\n### Testing\n- Write table-driven tests\n- Test edge cases\n- Use subtests for better organization\n- Mock external dependencies\n- Aim for high test coverage\n\n### Documentation\n- Document all exported items\n- Write clear package documentation\n- Include examples in documentation\n- Keep comments up to date\n- Use godoc format\n\nThis comprehensive guide covers the fundamental aspects of Go programming. Each topic includes practical examples and best practices to help write idiomatic, efficient Go code.","structuredPatch":[{"oldStart":1,"oldLines":191,"newStart":1,"newLines":286,"lines":["-# Go Fundamentals - Complete Language Reference","+# Go Language Fundamentals - Complete Reference"," "," ## Table of Contents","-1. [Basic Syntax](#basic-syntax)","-2. [Types and Variables](#types-and-variables)","-3. [Control Flow](#control-flow)","-4. [Functions](#functions)","-5. [Methods](#methods)","-6. [Structs](#structs)","-7. [Interfaces](#interfaces)","-8. [Error Handling Basics](#error-handling-basics)","-9. [Pointers](#pointers)","-10. [Arrays and Slices](#arrays-and-slices)","-11. [Maps](#maps)","-12. [Type Assertions and Type Switches](#type-assertions-and-type-switches)","+1. [Introduction](#introduction)","+2. [Basic Syntax](#basic-syntax)","+3. [Variables and Constants](#variables-and-constants)","+4. [Data Types](#data-types)","+5. [Control Flow](#control-flow)","+6. [Functions](#functions)","+7. [Methods](#methods)","+8. [Structs](#structs)","+9. [Interfaces](#interfaces)","+10. [Pointers](#pointers)","+11. [Arrays and Slices](#arrays-and-slices)","+12. [Maps](#maps)","+13. [Error Handling](#error-handling)","+14. [Packages and Modules](#packages-and-modules)","+15. [Type Assertions and Type Switches](#type-assertions-and-type-switches)","+16. [Embedding and Composition](#embedding-and-composition)","+17. [Generics](#generics)"," ","+## Introduction","+","+Go is a statically typed, compiled language designed for simplicity, efficiency, and reliable software. Created at Google in 2007 by Robert Griesemer, Rob Pike, and Ken Thompson, Go combines the performance of compiled languages with the ease of programming of dynamic languages.","+","+### Core Philosophy","+- **Simplicity**: Less is exponentially more","+- **Readability**: Code is read more often than written","+- **Efficiency**: Fast compilation, fast execution","+- **Concurrency**: Built-in primitives for concurrent programming","+- **Pragmatism**: Solve real problems with practical solutions","+"," ## Basic Syntax"," ","-### Package Declaration","-Every Go file starts with a package declaration:","+### Program Structure"," ","-```go","-package main  // Executable programs use package main","-package trading  // Library packages use lowercase names","-```","+Every Go program starts with a package declaration and imports:"," ","-### Import Statements"," ```go","-import \"fmt\"  // Single import","+package main"," ","-// Multiple imports (preferred style)"," import (","     \"fmt\"","     \"strings\"","     \"time\"","-    ","-    // Third-party packages","-    \"github.com/shopspring/decimal\"","-    ","-    // Internal packages","-    \"myproject/internal/trading\""," )"," ","-// Aliased imports","-import (","-    stdlog \"log\"  // Alias to avoid naming conflicts","-    _ \"github.com/lib/pq\"  // Import for side effects only","-    . \"math\"  // Dot import (use sparingly)","-)","+func main() {","+    fmt.Println(\"Hello, Go!\")","+}"," ```"," "," ### Comments","+"," ```go"," // Single-line comment"," "," /*","-Multi-line comment","-Used for longer explanations","+   Multi-line comment","+   Can span multiple lines"," */"," ","-// Package comments precede package declaration","-// Package trading provides core trading functionality.","-package trading","+// Package documentation comment (must precede package declaration)","+// Package math provides basic mathematical functions.","+package math"," ","-// Function comments precede the function","-// CalculateProfit returns the profit from a trade.","-func CalculateProfit(entry, exit decimal.Decimal) decimal.Decimal {","-    return exit.Sub(entry)","+// Function documentation (must precede function declaration)","+// Add returns the sum of two integers.","+func Add(a, b int) int {","+    return a + b"," }"," ```"," ","-## Types and Variables","+### Naming Conventions"," ","-### Basic Types"," ```go","-// Boolean","-var isActive bool = true","-var isEnabled = false  // Type inference","+// Exported (public) - starts with uppercase","+type Strategy struct{}","+func CalculateProfit() {}","+const MaxRetries = 3","+var DefaultTimeout = 5 * time.Second"," ","-// Numeric Types","-var count int = 42        // Platform-dependent size (32 or 64 bits)","-var port int64 = 8080     // Explicit 64-bit integer","-var smallNum int8 = 127   // 8-bit integer (-128 to 127)","-var byteVal byte = 255    // Alias for uint8","-var runeVal rune = 'A'    // Alias for int32, represents Unicode code point","+// Unexported (private) - starts with lowercase","+type position struct{}","+func calculateLoss() {}","+const maxAttempts = 5","+var defaultBuffer = 1024"," ","-// Floating-point","-var price float64 = 99.99","-var rate float32 = 0.05","+// Package names - lowercase, single word","+package trading  // Good","+package tradingEngine  // Bad - use trading or engine"," ","-// Complex numbers","-var c complex128 = 1 + 2i","-var c64 complex64 = complex(1, 2)","+// Interface names - typically end with -er","+type Reader interface{}","+type Writer interface{}","+type Closer interface{}","+type ReadWriteCloser interface{}  // Composition"," ","-// String","-var message string = \"Hello, Go!\"","-var multiline = `This is a","-multi-line string","-with backticks`","+// Acronyms - keep consistent case","+var httpClient HTTP  // Bad","+var HTTPClient HTTP  // Good","+var xmlParser XML    // Bad","+var XMLParser XML    // Good"," ```"," ","+## Variables and Constants","+"," ### Variable Declaration","+"," ```go","-// var keyword with type","-var x int","-var y int = 10","+// var declaration with type","+var name string","+var age int","+var balance float64"," ","-// var with type inference","-var z = 20  // int inferred","+// var declaration with initialization","+var name string = \"John\"","+var age int = 30","+var balance = 1000.50  // Type inferred"," ","-// Short declaration (only inside functions)","-w := 30  // Same as: var w = 30","+// Short variable declaration (only inside functions)","+name := \"John\"","+age := 30","+balance := 1000.50"," ","-// Multiple variables","-var a, b, c int","-var d, e = 1, \"hello\"","-f, g := true, 3.14","-","-// Grouped declaration","+// Multiple variable declaration"," var (","-    name   string = \"Alice\"","-    age    int    = 30","-    active bool   = true","+    firstName string = \"John\"","+    lastName  string = \"Doe\"","+    age       int    = 30"," )"," ","-// Constants","-const pi = 3.14159","-const (","-    StatusOK    = 200","-    StatusError = 500","-)","+// Multiple assignment","+x, y := 10, 20","+a, b = b, a  // Swap values"," ","+// Blank identifier for unused values","+_, err := someFunction()  // Ignore first return value","+```","+","+### Constants","+","+```go","+// Single constant","+const Pi = 3.14159","+const MaxRetries = 3","+const Message = \"Hello\"","+"," // Typed constants","-const typedConst int64 = 1234","+const MaxInt int = 1000","+const Timeout time.Duration = 5 * time.Second"," ","-// iota for enumerations","+// Multiple constants"," const (","+    StatusOK       = 200","+    StatusNotFound = 404","+    StatusError    = 500","+)","+","+// iota - constant generator","+const (","     Sunday = iota  // 0","     Monday         // 1","     Tuesday        // 2","     Wednesday      // 3","+    Thursday       // 4","+    Friday         // 5","+    Saturday       // 6"," )"," ","-// Complex iota usage","+// iota with expressions"," const (","-    _  = iota             // Skip 0","+    _  = iota             // 0 (ignored)","     KB = 1 << (10 * iota) // 1024","     MB                    // 1048576","     GB                    // 1073741824","+    TB                    // 1099511627776"," )","+","+// Bit flags with iota","+const (","+    ReadPermission = 1 << iota  // 1","+    WritePermission              // 2","+    ExecutePermission            // 4","+)"," ```"," ","-### Zero Values","+## Data Types","+","+### Basic Types","+"," ```go","-var i int        // 0","-var f float64    // 0.0","-var b bool       // false","-var s string     // \"\"","-var p *int       // nil","-var a []int      // nil","-var m map[string]int  // nil","-var ch chan int  // nil","-var fn func()    // nil","-var inf interface{}  // nil","+// Boolean","+var isActive bool = true","+var isComplete bool  // Zero value: false","+","+// Integers","+var i8 int8 = 127                    // -128 to 127","+var i16 int16 = 32767                // -32768 to 32767","+var i32 int32 = 2147483647           // -2147483648 to 2147483647","+var i64 int64 = 9223372036854775807  // -9223372036854775808 to 9223372036854775807","+var i int = 42                       // Platform dependent (32 or 64 bit)","+","+// Unsigned integers","+var ui8 uint8 = 255                  // 0 to 255 (byte is alias)","+var ui16 uint16 = 65535              // 0 to 65535","+var ui32 uint32 = 4294967295         // 0 to 4294967295","+var ui64 uint64 = 18446744073709551615  // 0 to 18446744073709551615","+var ui uint = 42                     // Platform dependent","+","+// Floating point","+var f32 float32 = 3.14               // IEEE-754 32-bit","+var f64 float64 = 3.141592653589793  // IEEE-754 64-bit","+","+// Complex numbers","+var c64 complex64 = 1 + 2i           // float32 real and imaginary","+var c128 complex128 = 1 + 2i         // float64 real and imaginary","+","+// Strings","+var str string = \"Hello, Go!\"        // UTF-8 encoded","+var multiline = `This is","+a multiline","+string`                               // Raw string literal","+","+// Rune (Unicode code point)","+var r rune = 'A'                     // int32 alias","+var emoji rune = '😀'","+","+// Byte","+var b byte = 65                      // uint8 alias"," ```"," "," ### Type Conversions","+"," ```go","-// Explicit conversion required","+// Explicit type conversion required"," var i int = 42"," var f float64 = float64(i)"," var u uint = uint(i)"," "," // String conversions","-var s string = string(65)  // \"A\" (from ASCII/Unicode)","-var bytes = []byte(\"hello\")  // String to byte slice","-var str = string(bytes)      // Byte slice to string","-","-// Numeric parsing"," import \"strconv\"","-i, err := strconv.Atoi(\"123\")  // String to int","-s := strconv.Itoa(123)          // Int to string","-f, err := strconv.ParseFloat(\"3.14\", 64)  // String to float64","+","+// Int to string","+s := strconv.Itoa(42)","+s := strconv.FormatInt(42, 10)  // base 10","+","+// String to int","+i, err := strconv.Atoi(\"42\")","+i64, err := strconv.ParseInt(\"42\", 10, 64)","+","+// Float to string","+s := strconv.FormatFloat(3.14, 'f', 2, 64)  // 2 decimal places","+","+// String to float","+f, err := strconv.ParseFloat(\"3.14\", 64)","+","+// Type assertions (for interfaces)","+var x interface{} = \"hello\"","+s := x.(string)  // Panics if x is not string","+s, ok := x.(string)  // Safe assertion with ok check"," ```"," ","+### Zero Values","+","+```go","+// All types have zero values","+var b bool        // false","+var i int         // 0","+var f float64     // 0.0","+var s string      // \"\"","+var p *int        // nil","+var a []int       // nil","+var m map[string]int  // nil","+var c chan int    // nil","+var fn func()     // nil","+var iface error   // nil","+```","+"," ## Control Flow"," "," ### If Statements","+"," ```go"," // Basic if"," if x > 0 {"]},{"oldStart":195,"oldLines":6,"newStart":290,"newLines":13,"lines":[" // If-else"," if x > 0 {","     fmt.Println(\"Positive\")","+} else {","+    fmt.Println(\"Non-positive\")","+}","+","+// If-else if-else","+if x > 0 {","+    fmt.Println(\"Positive\")"," } else if x < 0 {","     fmt.Println(\"Negative\")"," } else {"]},{"oldStart":207,"oldLines":27,"newStart":309,"newLines":96,"lines":[" }"," "," // Common patterns","-if val, ok := m[key]; ok {","-    // Use val - key exists in map","+// Check error immediately","+if err != nil {","+    return fmt.Errorf(\"failed to process: %w\", err)"," }"," ","-if v, err := getValue(); err == nil {","-    // Use v - no error occurred","+// Check boolean","+if !isValid {","+    return errors.New(\"invalid input\")"," }","+","+// Check nil","+if data == nil {","+    return errors.New(\"data is nil\")","+}"," ```"," ","-### For Loops","+### Switch Statements","+"," ```go","-// Traditional for loop","+// Basic switch","+switch day {","+case \"Monday\":","+    fmt.Println(\"Start of work week\")","+case \"Friday\":","+    fmt.Println(\"TGIF!\")","+case \"Saturday\", \"Sunday\":","+    fmt.Println(\"Weekend!\")","+default:","+    fmt.Println(\"Midweek\")","+}","+","+// Switch with no expression (like if-else chain)","+switch {","+case x < 0:","+    fmt.Println(\"Negative\")","+case x == 0:","+    fmt.Println(\"Zero\")","+case x > 0:","+    fmt.Println(\"Positive\")","+}","+","+// Switch with initialization","+switch os := runtime.GOOS; os {","+case \"darwin\":","+    fmt.Println(\"macOS\")","+case \"linux\":","+    fmt.Println(\"Linux\")","+default:","+    fmt.Printf(\"Unknown OS: %s\\n\", os)","+}","+","+// Type switch","+func describe(i interface{}) {","+    switch v := i.(type) {","+    case int:","+        fmt.Printf(\"Integer: %d\\n\", v)","+    case string:","+        fmt.Printf(\"String: %s\\n\", v)","+    case bool:","+        fmt.Printf(\"Boolean: %t\\n\", v)","+    case nil:","+        fmt.Println(\"nil value\")","+    default:","+        fmt.Printf(\"Unknown type: %T\\n\", v)","+    }","+}","+","+// Fallthrough (rarely used)","+switch num {","+case 1:","+    fmt.Println(\"One\")","+    fallthrough  // Continue to next case","+case 2:","+    fmt.Println(\"One or Two\")","+}","+```","+","+### Loops","+","+```go","+// For loop - traditional"," for i := 0; i < 10; i++ {","     fmt.Println(i)"," }"," ","-// While-style loop","-i := 0","-for i < 10 {","-    fmt.Println(i)","-    i++","+// For loop - while style","+count := 0","+for count < 10 {","+    fmt.Println(count)","+    count++"," }"," "," // Infinite loop"]},{"oldStart":238,"oldLines":116,"newStart":409,"newLines":73,"lines":["     }"," }"," ","-// Range over slice/array","+// Range over slice"," numbers := []int{1, 2, 3, 4, 5}"," for index, value := range numbers {","     fmt.Printf(\"%d: %d\\n\", index, value)"," }"," ","-// Ignore index with blank identifier","+// Range over slice - values only"," for _, value := range numbers {","     fmt.Println(value)"," }"," ","+// Range over slice - indices only","+for index := range numbers {","+    fmt.Println(index)","+}","+"," // Range over map","-m := map[string]int{\"a\": 1, \"b\": 2}","-for key, value := range m {","-    fmt.Printf(\"%s: %d\\n\", key, value)","+ages := map[string]int{\"Alice\": 30, \"Bob\": 25}","+for name, age := range ages {","+    fmt.Printf(\"%s is %d years old\\n\", name, age)"," }"," ","-// Range over string (iterates over runes)","+// Range over string (gives runes)"," for index, runeValue := range \"Hello, 世界\" {","     fmt.Printf(\"%d: %c\\n\", index, runeValue)"," }"," "," // Range over channel","-for msg := range ch {","-    fmt.Println(msg)  // Receives until channel is closed","+ch := make(chan int)","+go func() {","+    for i := 0; i < 5; i++ {","+        ch <- i","+    }","+    close(ch)","+}()","+for value := range ch {","+    fmt.Println(value)"," }"," "," // Continue and break with labels"," outer:"," for i := 0; i < 3; i++ {","     for j := 0; j < 3; j++ {","-        if i == j {","-            continue outer  // Continue outer loop","+        if i == 1 && j == 1 {","+            break outer  // Break outer loop","         }","-        if i+j > 3 {","-            break outer  // Break from outer loop","-        }","+        fmt.Printf(\"(%d, %d) \", i, j)","     }"," }"," ```"," ","-### Switch Statements","-```go","-// Basic switch","-switch day {","-case \"Monday\":","-    fmt.Println(\"Start of work week\")","-case \"Friday\":","-    fmt.Println(\"TGIF\")","-case \"Saturday\", \"Sunday\":  // Multiple cases","-    fmt.Println(\"Weekend!\")","-default:","-    fmt.Println(\"Midweek\")","-}","-","-// Switch with initialization","-switch hour := time.Now().Hour(); {","-case hour < 12:","-    fmt.Println(\"Morning\")","-case hour < 18:","-    fmt.Println(\"Afternoon\")","-default:","-    fmt.Println(\"Evening\")","-}","-","-// Switch without expression (replaces if-else chains)","-switch {","-case x < 0:","-    fmt.Println(\"Negative\")","-case x == 0:","-    fmt.Println(\"Zero\")","-case x > 0:","-    fmt.Println(\"Positive\")","-}","-","-// Fallthrough (rarely used)","-switch n {","-case 0:","-    fmt.Println(\"Zero\")","-    fallthrough  // Continue to next case","-case 1:","-    fmt.Println(\"One or fallthrough from Zero\")","-}","-","-// Type switch (covered in detail later)","-switch v := x.(type) {","-case int:","-    fmt.Printf(\"Integer: %d\\n\", v)","-case string:","-    fmt.Printf(\"String: %s\\n\", v)","-default:","-    fmt.Printf(\"Unknown type: %T\\n\", v)","-}","-```","-"," ### Defer, Panic, and Recover","+"," ```go","-// Defer - executes at function exit (LIFO order)","+// Defer - executes when function returns"," func readFile(filename string) error {","     file, err := os.Open(filename)","     if err != nil {","         return err","     }","-    defer file.Close()  // Ensures file is closed","+    defer file.Close()  // Executed when function returns","     ","     // Read file...","     return nil"," }"," ","-// Multiple defers execute in reverse order","+// Multiple defers - LIFO order"," func example() {","     defer fmt.Println(\"Third\")","     defer fmt.Println(\"Second\")"]},{"oldStart":355,"oldLines":34,"newStart":483,"newLines":51,"lines":["     // Prints: First, Second, Third"," }"," ","-// Defer with function values","-func measure(name string) func() {","-    start := time.Now()","-    return func() {","-        fmt.Printf(\"%s took %v\\n\", name, time.Since(start))","-    }","+// Defer with arguments - evaluated immediately","+func deferArgs() {","+    i := 0","+    defer fmt.Println(i)  // Prints 0, not 1","+    i++"," }"," ","-func slowOperation() {","-    defer measure(\"slowOperation\")()  // Note the extra ()","-    time.Sleep(1 * time.Second)","+// Defer with closure - captures variables","+func deferClosure() {","+    i := 0","+    defer func() {","+        fmt.Println(i)  // Prints 1","+    }()","+    i++"," }"," ","-// Panic - for unrecoverable errors","-func mustNotBeZero(x int) {","-    if x == 0 {","-        panic(\"x cannot be zero\")","+// Panic - runtime error","+func divide(a, b int) int {","+    if b == 0 {","+        panic(\"division by zero\")","     }","+    return a / b"," }"," ","-// Recover - catch panics","-func safeExecute(fn func()) (err error) {","+// Recover - catch panic","+func safeFunction() {","     defer func() {","         if r := recover(); r != nil {","+            fmt.Printf(\"Recovered from panic: %v\\n\", r)","+        }","+    }()","+    ","+    // Code that might panic","+    panic(\"something went wrong\")","+}","+","+// Practical error recovery pattern","+func robustFunction() (err error) {","+    defer func() {","+        if r := recover(); r != nil {","             err = fmt.Errorf(\"panic recovered: %v\", r)","         }","     }()","-    fn()  // May panic","+    ","+    // Potentially panicking code","     return nil"," }"," ```"]},{"oldStart":390,"oldLines":86,"newStart":535,"newLines":106,"lines":[" ## Functions"," "," ### Function Declaration","+"," ```go"," // Basic function","-func add(x int, y int) int {","-    return x + y","+func greet() {","+    fmt.Println(\"Hello!\")"," }"," ","-// Shortened parameter types","-func add2(x, y int) int {  // Both x and y are int","-    return x + y","+// Function with parameters","+func add(a int, b int) int {","+    return a + b"," }"," ","+// Shorthand for same type parameters","+func add(a, b int) int {","+    return a + b","+}","+"," // Multiple return values","-func divide(x, y float64) (float64, error) {","-    if y == 0 {","+func divide(a, b float64) (float64, error) {","+    if b == 0 {","         return 0, errors.New(\"division by zero\")","     }","-    return x / y, nil","+    return a / b, nil"," }"," "," // Named return values","-func split(sum int) (x, y int) {","-    x = sum * 4 / 9","-    y = sum - x","-    return  // Naked return (use sparingly)","+func getCoordinates() (x, y int) {","+    x = 10","+    y = 20","+    return  // Naked return"," }"," ","+// Named returns with explicit values","+func calculate(a, b int) (sum, product int) {","+    sum = a + b","+    product = a * b","+    return sum, product  // Can be explicit","+}","+"," // Variadic functions","-func sum(nums ...int) int {","+func sum(numbers ...int) int {","     total := 0","-    for _, n := range nums {","+    for _, n := range numbers {","         total += n","     }","     return total"," }"," ","-// Call variadic function","+// Calling variadic functions"," result := sum(1, 2, 3, 4, 5)","-numbers := []int{1, 2, 3}","-result2 := sum(numbers...)  // Spread slice","+nums := []int{1, 2, 3}","+result := sum(nums...)  // Spread slice"," ```"," "," ### Function Types and Values","+"," ```go"," // Function as type","-type Calculator func(int, int) int","+type Operation func(int, int) int"," ","-// Function as variable","-var operation Calculator = add","+func add(a, b int) int { return a + b }","+func multiply(a, b int) int { return a * b }"," ","-// Anonymous functions","-multiply := func(x, y int) int {","-    return x * y","-}","+var op Operation = add","+result := op(5, 3)  // 8"," ","-// Immediately invoked function","-result := func(x, y int) int {","-    return x + y","-}(5, 3)","-","-// Functions as parameters","-func apply(fn func(int, int) int, x, y int) int {","-    return fn(x, y)","+// Function as parameter","+func apply(op Operation, a, b int) int {","+    return op(a, b)"," }"," ","-result := apply(add, 10, 5)","+result := apply(add, 5, 3)","+result = apply(multiply, 5, 3)"," ","-// Functions returning functions","+// Function returning function"," func makeAdder(x int) func(int) int {","     return func(y int) int {","-        return x + y  // Closure captures x","+        return x + y","     }"," }"," "," add5 := makeAdder(5)"," result := add5(3)  // 8","+","+// Anonymous functions","+func() {","+    fmt.Println(\"Anonymous function\")","+}()  // Immediately invoked","+","+// Assign to variable","+greet := func(name string) {","+    fmt.Printf(\"Hello, %s!\\n\", name)","+}","+greet(\"World\")"," ```"," "," ### Closures","+"," ```go","-// Closure captures variables from outer scope","+// Closure captures variables"," func counter() func() int {","     count := 0","     return func() int {"]},{"oldStart":483,"oldLines":285,"newStart":648,"newLines":298,"lines":[" fmt.Println(c())  // 2"," fmt.Println(c())  // 3"," ","-// Common pitfall with closures in loops","-// BAD:","-var funcs []func()","+// Closure in loop (common pitfall)","+// Wrong way","+funcs := []func(){}"," for i := 0; i < 3; i++ {","     funcs = append(funcs, func() {","-        fmt.Println(i)  // Captures loop variable","+        fmt.Println(i)  // All print 3","     })"," }","-// All functions print 3"," ","-// GOOD:","+// Correct way"," for i := 0; i < 3; i++ {","-    i := i  // Create new variable","+    i := i  // Shadow variable","     funcs = append(funcs, func() {","-        fmt.Println(i)","+        fmt.Println(i)  // Prints 0, 1, 2","     })"," }","-// Functions print 0, 1, 2","+","+// Alternative correct way","+for i := 0; i < 3; i++ {","+    func(n int) {","+        funcs = append(funcs, func() {","+            fmt.Println(n)","+        })","+    }(i)","+}"," ```"," "," ## Methods"," "," ### Method Declaration","+"," ```go","-// Methods are functions with a receiver","-type Point struct {","-    X, Y float64","+// Method on struct","+type Rectangle struct {","+    Width, Height float64"," }"," "," // Value receiver","-func (p Point) Distance() float64 {","-    return math.Sqrt(p.X*p.X + p.Y*p.Y)","+func (r Rectangle) Area() float64 {","+    return r.Width * r.Height"," }"," ","-// Pointer receiver (can modify the receiver)","-func (p *Point) Scale(factor float64) {","-    p.X *= factor","-    p.Y *= factor","+// Pointer receiver","+func (r *Rectangle) Scale(factor float64) {","+    r.Width *= factor","+    r.Height *= factor"," }"," "," // Using methods","-p := Point{3, 4}","-fmt.Println(p.Distance())  // 5","-p.Scale(2)  // p is now {6, 8}","+rect := Rectangle{Width: 10, Height: 5}","+area := rect.Area()        // 50","+rect.Scale(2)              // Width=20, Height=10"," ","-// Methods on non-struct types","+// Method on non-struct types"," type MyInt int"," ","-func (i MyInt) IsPositive() bool {","-    return i > 0","+func (m MyInt) IsEven() bool {","+    return m%2 == 0"," }"," ","-var num MyInt = 10","-fmt.Println(num.IsPositive())  // true","-```","+var num MyInt = 42","+if num.IsEven() {","+    fmt.Println(\"Even number\")","+}"," ","-### Value vs Pointer Receivers","-```go","-// Guidelines for choosing receiver type:","+// Method on pointer vs value","+type Counter struct {","+    value int","+}"," ","-// Use pointer receiver when:","-// 1. Method needs to modify the receiver","-func (u *User) SetName(name string) {","-    u.Name = name","+// Value receiver - cannot modify","+func (c Counter) GetValue() int {","+    return c.value"," }"," ","-// 2. Struct is large (avoid copying)","-func (d *LargeData) Process() {","-    // Processing large struct","+// Pointer receiver - can modify","+func (c *Counter) Increment() {","+    c.value++"," }"," ","-// 3. Consistency - if one method needs pointer, use for all","-type Account struct {","-    balance decimal.Decimal","+// Pointer receiver - can handle nil","+func (c *Counter) SafeIncrement() {","+    if c == nil {","+        return","+    }","+    c.value++"," }","+```"," ","-func (a *Account) Deposit(amount decimal.Decimal) {","-    a.balance = a.balance.Add(amount)","+### Method Sets","+","+```go","+// Method set rules:","+// - Type T has method set of all methods with receiver T","+// - Type *T has method set of all methods with receiver T or *T","+","+type Shape struct {","+    Name string"," }"," ","-func (a *Account) Balance() decimal.Decimal {","-    return a.balance  // Pointer receiver for consistency","+func (s Shape) GetName() string {","+    return s.Name"," }"," ","-// Use value receiver when:","-// 1. Method doesn't modify receiver","-// 2. Type is small and copying is cheap","-// 3. You want immutability","-func (p Point) DistanceTo(other Point) float64 {","-    dx := p.X - other.X","-    dy := p.Y - other.Y","-    return math.Sqrt(dx*dx + dy*dy)","+func (s *Shape) SetName(name string) {","+    s.Name = name"," }","+","+// Value type can call value receiver methods","+shape := Shape{Name: \"Circle\"}","+name := shape.GetName()  // OK","+","+// Value type automatically gets address for pointer receiver","+shape.SetName(\"Square\")  // OK (Go converts to (&shape).SetName())","+","+// Pointer type can call both","+shapePtr := &Shape{Name: \"Triangle\"}","+name = shapePtr.GetName()  // OK","+shapePtr.SetName(\"Pentagon\")  // OK"," ```"," "," ## Structs"," "," ### Struct Declaration and Usage","+"," ```go"," // Basic struct"," type Person struct {","-    Name string","-    Age  int","+    FirstName string","+    LastName  string","+    Age       int"," }"," "," // Creating structs","-p1 := Person{Name: \"Alice\", Age: 30}","-p2 := Person{\"Bob\", 25}  // Positional (not recommended)","-p3 := Person{Name: \"Charlie\"}  // Partial initialization","-var p4 Person  // Zero value","+p1 := Person{","+    FirstName: \"John\",","+    LastName:  \"Doe\",","+    Age:       30,","+}"," ","+// Positional initialization (not recommended)","+p2 := Person{\"Jane\", \"Doe\", 25}","+","+// Zero value struct","+var p3 Person  // All fields have zero values","+"," // Accessing fields","-fmt.Println(p1.Name)","+fmt.Println(p1.FirstName)"," p1.Age = 31"," ","-// Struct pointers","-ptr := &Person{Name: \"Dave\", Age: 40}","-ptr.Age = 41  // Same as (*ptr).Age = 41","+// Struct pointer","+ptr := &Person{FirstName: \"Bob\"}","+ptr.Age = 40  // Automatic dereferencing"," ","-// Anonymous structs","+// Anonymous struct"," point := struct {","     X, Y int","-}{10, 20}","+}{X: 10, Y: 20}"," "," // Struct tags"," type User struct {","-    ID       int    `json:\"id\" db:\"user_id\"`","-    Username string `json:\"username\" db:\"user_name\"`","-    Password string `json:\"-\"` // Omit from JSON","-    Admin    bool   `json:\"is_admin,omitempty\"`","+    ID        int    `json:\"id\" db:\"user_id\"`","+    Email     string `json:\"email\" validate:\"required,email\"`","+    Password  string `json:\"-\"`  // Omit from JSON","+    CreatedAt time.Time `json:\"created_at,omitempty\"`"," }"," "," // Accessing tags via reflection"," import \"reflect\"","+"," t := reflect.TypeOf(User{})","-field, _ := t.FieldByName(\"ID\")","-fmt.Println(field.Tag.Get(\"json\"))  // \"id\"","+field, _ := t.FieldByName(\"Email\")","+fmt.Println(field.Tag.Get(\"json\"))     // \"email\"","+fmt.Println(field.Tag.Get(\"validate\")) // \"required,email\"","+```"," ","-// Embedded structs (composition)","-type Employee struct {","-    Person  // Embedded","-    ID      int","-    Manager *Employee","-}","+### Struct Embedding"," ","-emp := Employee{","-    Person: Person{Name: \"Eve\", Age: 28},","-    ID:     12345,","+```go","+// Embedding for composition","+type Address struct {","+    Street  string","+    City    string","+    Country string"," }","-fmt.Println(emp.Name)  // Promoted field"," ","-// Field alignment and memory optimization","-// Bad: 24 bytes on 64-bit systems","-type Inefficient struct {","-    a bool   // 1 byte + 7 padding","-    b int64  // 8 bytes","-    c bool   // 1 byte + 7 padding","+type Employee struct {","+    Person  // Embedded struct","+    Address // Another embedded struct","+    Salary  float64"," }"," ","-// Good: 16 bytes on 64-bit systems","-type Efficient struct {","-    b int64  // 8 bytes","-    a bool   // 1 byte","-    c bool   // 1 byte + 6 padding","+emp := Employee{","+    Person: Person{","+        FirstName: \"Alice\",","+        LastName:  \"Smith\",","+        Age:       28,","+    },","+    Address: Address{","+        City:    \"New York\",","+        Country: \"USA\",","+    },","+    Salary: 75000,"," }","-```"," ","-### Struct Methods and Composition","-```go","-// Composition for code reuse","-type Writer interface {","-    Write([]byte) (int, error)","-}","+// Promoted fields","+fmt.Println(emp.FirstName)  // Promoted from Person","+fmt.Println(emp.City)       // Promoted from Address"," ","-type Reader interface {","-    Read([]byte) (int, error)","-}","+// Explicit access","+fmt.Println(emp.Person.FirstName)"," ","-// Composed interface","-type ReadWriter interface {","-    Reader","-    Writer","-}","+// Method promotion","+type Writer struct{}"," ","-// Struct embedding for composition","-type Base struct {","-    ID   int","-    Name string","+func (w Writer) Write(data []byte) (int, error) {","+    return len(data), nil"," }"," ","-func (b *Base) SetName(name string) {","-    b.Name = name","+type Logger struct {","+    Writer  // Embedded","+    prefix string"," }"," ","-type Derived struct {","-    Base  // Embed Base","-    Extra string","-}","-","-d := Derived{","-    Base:  Base{ID: 1, Name: \"Test\"},","-    Extra: \"additional\",","-}","-d.SetName(\"New Name\")  // Call Base method","+log := Logger{prefix: \"[INFO]\"}","+log.Write([]byte(\"message\"))  // Promoted method"," ```"," ","-## Interfaces","+### Struct Comparison"," ","-### Interface Declaration and Implementation"," ```go","-// Interface definition","-type Shape interface {","-    Area() float64","-    Perimeter() float64","+// Structs are comparable if all fields are comparable","+type Point struct {","+    X, Y int"," }"," ","-// Implementation is implicit","-type Rectangle struct {","-    Width, Height float64","-}","+p1 := Point{1, 2}","+p2 := Point{1, 2}","+p3 := Point{2, 3}"," ","-func (r Rectangle) Area() float64 {","-    return r.Width * r.Height","-}","+fmt.Println(p1 == p2)  // true","+fmt.Println(p1 == p3)  // false"," ","-func (r Rectangle) Perimeter() float64 {","-    return 2 * (r.Width + r.Height)","+// Non-comparable structs (contain slices, maps, functions)","+type Data struct {","+    Values []int  // Slices are not comparable"," }"," ","-// Rectangle implements Shape implicitly","-var s Shape = Rectangle{Width: 10, Height: 5}","+// This won't compile:","+// d1 := Data{Values: []int{1, 2}}","+// d2 := Data{Values: []int{1, 2}}","+// fmt.Println(d1 == d2)  // Compile error","+```"," ","-// Empty interface (accepts any type)","-var anything interface{}","-anything = 42","-anything = \"hello\"","-anything = Rectangle{10, 5}","+## Interfaces"," ","-// Interface satisfaction","+### Interface Declaration and Implementation","+","+```go","+// Interface declaration"," type Writer interface {","     Write([]byte) (int, error)"," }"," ","-// Any type with Write method satisfies Writer","-type File struct{}","-func (f *File) Write(data []byte) (int, error) {","-    return len(data), nil","+// Interface with multiple methods","+type ReadWriter interface {","+    Read([]byte) (int, error)","+    Write([]byte) (int, error)"," }"," ","-var w Writer = &File{}  // Note: pointer type","+// Empty interface (any type)","+type Any interface{}  // Pre Go 1.18","+type Any = any        // Go 1.18+"," ","-// Interface values","-type Stringer interface {","-    String() string","+// Implicit implementation","+type FileWriter struct {","+    filename string"," }"," ","-type Person struct {","-    Name string","+func (f FileWriter) Write(data []byte) (int, error) {","+    // Implementation","+    return len(data), nil"," }"," ","-func (p Person) String() string {","-    return p.Name","-}","-","-var s Stringer = Person{\"Alice\"}","-// Interface value has (value, type) = (Person{\"Alice\"}, Person)","-","-// Nil interface gotcha","-var p *Person = nil","-var s Stringer = p  // s is not nil!","-if s == nil {","-    // This won't execute","-}","-// s has (value, type) = (nil, *Person)","+// FileWriter implements Writer implicitly","+var w Writer = FileWriter{filename: \"test.txt\"}"," ```"," ","-### Common Interface Patterns","+### Interface Composition","+"," ```go","-// Small interfaces (Go philosophy)","+// Composing interfaces"," type Reader interface {","     Read([]byte) (int, error)"," }"]},{"oldStart":774,"oldLines":146,"newStart":952,"newLines":167,"lines":["     Close() error"," }"," ","-// Composed interfaces","-type ReadWriter interface {","-    Reader","-    Writer","-}","-","+// Composed interface"," type ReadWriteCloser interface {","     Reader","     Writer","     Closer"," }"," ","-// Accept interfaces, return structs","-func process(r Reader) error {","-    // Accept any Reader","-    data := make([]byte, 1024)","-    _, err := r.Read(data)","-    return err","+// Alternative inline composition","+type ReadWriter interface {","+    Read([]byte) (int, error)","+    Write([]byte) (int, error)"," }","+```"," ","-func newBuffer() *bytes.Buffer {","-    // Return concrete type","-    return &bytes.Buffer{}","+### Interface Values and nil","+","+```go","+// Interface values have two components: type and value","+var w Writer","+fmt.Printf(\"Type: %T, Value: %v\\n\", w, w)  // Type: <nil>, Value: <nil>","+","+// nil interface vs interface with nil value","+type MyWriter struct{}","+","+func (m *MyWriter) Write(data []byte) (int, error) {","+    if m == nil {","+        return 0, errors.New(\"nil writer\")","+    }","+    return len(data), nil"," }"," ","-// Interface guards (compile-time check)","-var _ Shape = (*Rectangle)(nil)  // Ensures Rectangle implements Shape","-var _ Shape = Rectangle{}        // Alternative syntax","-```","+var mw *MyWriter = nil","+var w Writer = mw","+// w is not nil (has type *MyWriter), but its value is nil"," ","-## Error Handling Basics","+if w == nil {","+    fmt.Println(\"w is nil\")  // Won't print","+}"," ","-### Error Interface","-```go","-// Error is a built-in interface","-type error interface {","-    Error() string","+// Check for nil value","+if mw == nil {","+    fmt.Println(\"mw is nil\")  // Will print"," }","+```"," ","-// Creating errors","-import \"errors\"","-err := errors.New(\"something went wrong\")","+### Type Assertions and Type Switches"," ","-// Formatted errors","-err := fmt.Errorf(\"failed to process %s: %v\", filename, originalErr)","+```go","+// Type assertion","+var i interface{} = \"hello\""," ","-// Custom error types","-type ValidationError struct {","-    Field string","-    Value interface{}","+// Direct assertion (panics if wrong type)","+s := i.(string)","+fmt.Println(s)","+","+// Safe assertion with comma-ok","+s, ok := i.(string)","+if ok {","+    fmt.Println(\"String:\", s)"," }"," ","-func (e ValidationError) Error() string {","-    return fmt.Sprintf(\"validation failed for field %s: invalid value %v\", ","-        e.Field, e.Value)","+// Check interface implementation","+var w io.Writer = &bytes.Buffer{}","+if buf, ok := w.(*bytes.Buffer); ok {","+    fmt.Println(\"It's a buffer:\", buf)"," }"," ","-// Returning errors","-func divide(a, b float64) (float64, error) {","-    if b == 0 {","-        return 0, errors.New(\"division by zero\")","+// Type switch","+func describe(i interface{}) {","+    switch v := i.(type) {","+    case int:","+        fmt.Printf(\"Integer: %d\\n\", v)","+    case string:","+        fmt.Printf(\"String: %s\\n\", v)","+    case io.Reader:","+        fmt.Println(\"It's a reader\")","+    case nil:","+        fmt.Println(\"It's nil\")","+    default:","+        fmt.Printf(\"Unknown type: %T\\n\", v)","     }","-    return a / b, nil"," }","+```"," ","-// Checking errors","-result, err := divide(10, 0)","-if err != nil {","-    log.Printf(\"Error: %v\", err)","-    return err","+### Common Interface Patterns","+","+```go","+// Stringer interface","+type Stringer interface {","+    String() string"," }"," ","-// Error wrapping (Go 1.13+)","-err := doSomething()","-if err != nil {","-    return fmt.Errorf(\"operation failed: %w\", err)","+type Point struct {","+    X, Y int"," }"," ","-// Error unwrapping","-var pathError *os.PathError","-if errors.As(err, &pathError) {","-    fmt.Printf(\"Path error: %s\\n\", pathError.Path)","+func (p Point) String() string {","+    return fmt.Sprintf(\"(%d, %d)\", p.X, p.Y)"," }"," ","-// Checking error types","-if errors.Is(err, os.ErrNotExist) {","-    // Handle file not found","+// Error interface","+type error interface {","+    Error() string"," }"," ","-// Sentinel errors","-var (","-    ErrNotFound = errors.New(\"not found\")","-    ErrInvalid  = errors.New(\"invalid input\")","-)","+type ValidationError struct {","+    Field string","+    Value string","+}"," ","-// Multiple error handling patterns","-// Pattern 1: Return immediately","-if err := step1(); err != nil {","-    return fmt.Errorf(\"step1 failed: %w\", err)","+func (e ValidationError) Error() string {","+    return fmt.Sprintf(\"validation failed for field %s: %s\", e.Field, e.Value)"," }"," ","-// Pattern 2: Accumulate errors","-var errs []error","-if err := step1(); err != nil {","-    errs = append(errs, err)","+// Sort interface","+type Interface interface {","+    Len() int","+    Less(i, j int) bool","+    Swap(i, j int)"," }","-if err := step2(); err != nil {","-    errs = append(errs, err)","-}","-if len(errs) > 0 {","-    return fmt.Errorf(\"multiple errors: %v\", errs)","-}","+","+// Custom sort implementation","+type ByAge []Person","+","+func (a ByAge) Len() int           { return len(a) }","+func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }","+func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }","+","+// Usage","+people := []Person{{Name: \"Alice\", Age: 30}, {Name: \"Bob\", Age: 25}}","+sort.Sort(ByAge(people))"," ```"," "," ## Pointers"," "," ### Pointer Basics","+"," ```go","-// Pointer declaration","-var p *int  // Pointer to int","+// Declare pointer","+var p *int"," ","-// Address operator &","+// Get address of variable"," x := 42","-p = &x  // p points to x","+p = &x"," ","-// Dereference operator *","+// Dereference pointer"," fmt.Println(*p)  // 42","-*p = 100  // x is now 100","+*p = 100","+fmt.Println(x)   // 100"," "," // Pointer zero value is nil"," var ptr *string"," if ptr == nil {","-    fmt.Println(\"Pointer is nil\")","+    fmt.Println(\"ptr is nil\")"," }"," ","-// Allocating memory","-p1 := new(int)  // Allocates zeroed int, returns *int","-*p1 = 42","+// New function allocates memory","+ptr = new(string)","+*ptr = \"Hello\""," ","-// Pointers to structs","+// Pointer to struct"," type Person struct {","     Name string","     Age  int"]},{"oldStart":922,"oldLines":73,"newStart":1121,"newLines":124,"lines":[" person := &Person{Name: \"Alice\", Age: 30}"," person.Age = 31  // Automatic dereferencing"," ","-// Pointer receivers","-func (p *Person) Birthday() {","-    p.Age++  // Modifies the original","+// Pointer arithmetic is NOT allowed in Go","+// p++  // This won't compile","+```","+","+### Pointers vs Values","+","+```go","+// Pass by value","+func modifyValue(x int) {","+    x = 100  // Doesn't affect original"," }"," ","-// When to use pointers:","-// 1. Large structs (avoid copying)","-// 2. Need to modify the original","-// 3. Optional values (nil represents absence)","-// 4. Implementing interfaces with pointer receivers","+// Pass by pointer","+func modifyPointer(x *int) {","+    *x = 100  // Modifies original","+}","+","+value := 42","+modifyValue(value)","+fmt.Println(value)  // Still 42","+","+modifyPointer(&value)","+fmt.Println(value)  // Now 100","+","+// Slices, maps, channels are reference types","+func modifySlice(s []int) {","+    s[0] = 100  // Modifies original","+}","+","+slice := []int{1, 2, 3}","+modifySlice(slice)","+fmt.Println(slice)  // [100, 2, 3]","+","+// But reassigning doesn't affect original","+func reassignSlice(s []int) {","+    s = []int{4, 5, 6}  // Doesn't affect original","+}","+","+// To modify slice itself, use pointer","+func replaceSlice(s *[]int) {","+    *s = []int{4, 5, 6}","+}"," ```"," "," ## Arrays and Slices"," "," ### Arrays","+"," ```go","-// Arrays have fixed size","-var arr [5]int  // Array of 5 ints","+// Array declaration","+var arr [5]int              // [0 0 0 0 0]"," arr[0] = 10"," arr[4] = 50"," ","-// Array literals","-primes := [5]int{2, 3, 5, 7, 11}","-partial := [5]int{1, 2}  // Rest are zeros","+// Array initialization","+arr := [5]int{1, 2, 3, 4, 5}","+arr := [...]int{1, 2, 3}    // Compiler counts elements","+arr := [5]int{0: 10, 4: 50} // Index:value pairs"," ","-// Size inference","-auto := [...]int{1, 2, 3, 4, 5}  // Size 5","-"," // Arrays are values (copied on assignment)","-arr2 := arr  // Full copy","-arr2[0] = 100  // Doesn't affect arr","+arr1 := [3]int{1, 2, 3}","+arr2 := arr1","+arr2[0] = 100","+fmt.Println(arr1)  // [1 2 3] - unchanged","+fmt.Println(arr2)  // [100 2 3]"," ","+// Array size is part of type","+var a [5]int","+var b [10]int","+// a = b  // Won't compile - different types","+"," // Multidimensional arrays"," var matrix [3][3]int"," matrix[1][1] = 5","+","+// Array iteration","+for i := 0; i < len(arr); i++ {","+    fmt.Println(arr[i])","+}","+","+for index, value := range arr {","+    fmt.Printf(\"%d: %d\\n\", index, value)","+}"," ```"," "," ### Slices","+"," ```go","-// Slices are dynamic references to arrays","-var slice []int  // nil slice","+// Slice declaration","+var slice []int            // nil slice","+slice = []int{}           // Empty slice","+slice = []int{1, 2, 3}    // Initialized slice"," ","-// Creating slices","-slice1 := []int{1, 2, 3, 4, 5}  // Slice literal","-slice2 := make([]int, 5)        // Length 5, capacity 5","-slice3 := make([]int, 5, 10)    // Length 5, capacity 10","+// Make function","+slice = make([]int, 5)    // Length 5, capacity 5","+slice = make([]int, 5, 10) // Length 5, capacity 10"," ","-// Slicing operations","+// Slice from array"," arr := [5]int{1, 2, 3, 4, 5}","-s1 := arr[1:4]  // [2, 3, 4]","-s2 := arr[:3]   // [1, 2, 3]","-s3 := arr[2:]   // [3, 4, 5]","-s4 := arr[:]    // [1, 2, 3, 4, 5]","+slice = arr[1:4]  // [2 3 4]","+slice = arr[:3]   // [1 2 3]","+slice = arr[2:]   // [3 4 5]","+slice = arr[:]    // [1 2 3 4 5]"," "," // Slice properties","-fmt.Println(len(s1))  // 3","-fmt.Println(cap(s1))  // 4 (capacity from underlying array)","+fmt.Println(len(slice))  // Length","+fmt.Println(cap(slice))  // Capacity"," ","-// Appending to slices","-slice = append(slice, 6)","-slice = append(slice, 7, 8, 9)","-slice = append(slice, anotherSlice...)","+// Append","+slice = []int{1, 2, 3}","+slice = append(slice, 4)","+slice = append(slice, 5, 6, 7)","+slice = append(slice, []int{8, 9}...)"," ","-// Copy slices","+// Copy"," src := []int{1, 2, 3}"," dst := make([]int, len(src))","-copy(dst, src)","+n := copy(dst, src)  // Returns number copied"," "," // Slice tricks"," // Remove element at index i"]},{"oldStart":997,"oldLines":210,"newStart":1247,"newLines":817,"lines":[" // Insert element at index i"," slice = append(slice[:i], append([]int{x}, slice[i:]...)...)"," ","+// Pop from end","+x := slice[len(slice)-1]","+slice = slice[:len(slice)-1]","+","+// Push to front","+slice = append([]int{x}, slice...)","+"," // Filter in place"," n := 0"," for _, x := range slice {","-    if keepCondition(x) {","+    if keepElement(x) {","         slice[n] = x","         n++","     }"," }"," slice = slice[:n]","+```"," ","-// Nil vs empty slice","-var nilSlice []int      // nil","-emptySlice := []int{}   // Not nil, but empty","-emptyMake := make([]int, 0)  // Not nil, but empty","+### Slice Internals"," ","-// Slice internals","-// A slice is a struct with:","-// - Pointer to underlying array","-// - Length","-// - Capacity","-","-// Growing slices efficiently","-// Preallocate when size is known","-result := make([]int, 0, expectedSize)","-for i := 0; i < expectedSize; i++ {","-    result = append(result, process(i))","+```go","+// Slice header (conceptual)","+type SliceHeader struct {","+    Data uintptr  // Pointer to underlying array","+    Len  int      // Current length","+    Cap  int      // Capacity"," }","+","+// Slices share underlying array","+original := []int{1, 2, 3, 4, 5}","+slice1 := original[1:4]  // [2 3 4]","+slice2 := original[2:5]  // [3 4 5]","+","+slice1[1] = 100  // Modifies shared array","+fmt.Println(slice2)  // [100 4 5]","+","+// Full slice expression controls capacity","+slice := original[1:3:4]  // [low:high:max]","+// len = high - low = 2","+// cap = max - low = 3","+","+// nil vs empty slice","+var nilSlice []int        // nil","+emptySlice := []int{}     // Not nil, but empty","+madeSlice := make([]int, 0) // Not nil, but empty","+","+fmt.Println(nilSlice == nil)    // true","+fmt.Println(emptySlice == nil)  // false","+fmt.Println(len(nilSlice))      // 0","+fmt.Println(len(emptySlice))    // 0","+","+// Both work with append","+nilSlice = append(nilSlice, 1)","+emptySlice = append(emptySlice, 1)"," ```"," "," ## Maps"," ","-### Map Operations","+### Map Basics","+"," ```go"," // Map declaration","-var m map[string]int  // nil map (read-only)","+var m map[string]int      // nil map","+m = make(map[string]int)  // Initialize"," ","-// Creating maps","-m1 := make(map[string]int)","-m2 := map[string]int{","-    \"alice\": 30,","-    \"bob\":   25,","+// Map literal","+m = map[string]int{","+    \"Alice\": 30,","+    \"Bob\":   25,"," }"," ","-// Map operations","-m1[\"key\"] = 42          // Set","-value := m1[\"key\"]      // Get","-delete(m1, \"key\")       // Delete","+// Operations","+m[\"Charlie\"] = 35         // Insert/Update","+age := m[\"Alice\"]         // Retrieve","+delete(m, \"Bob\")          // Delete"," "," // Check if key exists","-value, exists := m1[\"key\"]","+age, exists := m[\"David\"]"," if exists {","-    fmt.Println(\"Value:\", value)","+    fmt.Printf(\"David is %d years old\\n\", age)"," }"," ","-// Common pattern","-if val, ok := m[\"key\"]; ok {","-    // Use val","-}","+// Zero value for missing key","+fmt.Println(m[\"Unknown\"])  // 0 (zero value for int)"," ","-// Iterate over map","-for key, value := range m2 {","+// Iteration (order is random)","+for key, value := range m {","     fmt.Printf(\"%s: %d\\n\", key, value)"," }"," "," // Keys only","-for key := range m2 {","+for key := range m {","     fmt.Println(key)"," }"," ","-// Map of slices","-groups := make(map[string][]string)","-groups[\"admins\"] = append(groups[\"admins\"], \"alice\")","+// Values only","+for _, value := range m {","+    fmt.Println(value)","+}","+```"," ","-// Map of maps","-nested := make(map[string]map[string]int)","-if nested[\"outer\"] == nil {","-    nested[\"outer\"] = make(map[string]int)","+### Map Patterns","+","+```go","+// Map as set","+set := make(map[string]bool)","+set[\"apple\"] = true","+set[\"banana\"] = true","+","+if set[\"apple\"] {","+    fmt.Println(\"apple is in the set\")"," }","-nested[\"outer\"][\"inner\"] = 42"," ","-// Maps are reference types","-m3 := m2  // Both reference same map","-m3[\"charlie\"] = 35  // Affects m2","+// Alternative set using empty struct (memory efficient)","+type void struct{}","+var member void"," ","-// Zero value for map values","+set := make(map[string]void)","+set[\"apple\"] = member","+set[\"banana\"] = member","+","+if _, exists := set[\"apple\"]; exists {","+    fmt.Println(\"apple is in the set\")","+}","+","+// Counting with maps"," counts := make(map[string]int)","-counts[\"new\"]++  // Works! int zero value is 0","+words := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"}"," ","-// Map as set","-set := make(map[string]struct{})","-set[\"item\"] = struct{}{}  // Add to set","-if _, exists := set[\"item\"]; exists {","-    // Item in set","+for _, word := range words {","+    counts[word]++  // Works even if key doesn't exist"," }","-delete(set, \"item\")  // Remove from set"," ","-// Concurrent map access needs synchronization","+// Grouping with maps","+type Person struct {","+    Name string","+    Age  int","+}","+","+people := []Person{","+    {\"Alice\", 30},","+    {\"Bob\", 25},","+    {\"Charlie\", 30},","+    {\"David\", 25},","+}","+","+ageGroups := make(map[int][]Person)","+for _, person := range people {","+    ageGroups[person.Age] = append(ageGroups[person.Age], person)","+}","+","+// Map of maps","+nested := make(map[string]map[string]int)","+nested[\"scores\"] = make(map[string]int)","+nested[\"scores\"][\"Alice\"] = 95","+nested[\"scores\"][\"Bob\"] = 87","+","+// Safe nested access","+if scores, ok := nested[\"scores\"]; ok {","+    if score, ok := scores[\"Alice\"]; ok {","+        fmt.Printf(\"Alice's score: %d\\n\", score)","+    }","+}","+```","+","+### Maps and Concurrency","+","+```go","+// Maps are not safe for concurrent access","+// Use sync.Map or mutex","+","+import \"sync\"","+","+// With mutex"," type SafeMap struct {","     mu sync.RWMutex","     m  map[string]int"," }"," ","+func (sm *SafeMap) Set(key string, value int) {","+    sm.mu.Lock()","+    defer sm.mu.Unlock()","+    sm.m[key] = value","+}","+"," func (sm *SafeMap) Get(key string) (int, bool) {","     sm.mu.RLock()","     defer sm.mu.RUnlock()","-    val, ok := sm.m[key]","-    return val, ok","+    value, exists := sm.m[key]","+    return value, exists"," }"," ","-func (sm *SafeMap) Set(key string, value int) {","-    sm.mu.Lock()","-    defer sm.mu.Unlock()","-    sm.m[key] = value","+// Using sync.Map (for specific use cases)","+var m sync.Map","+","+// Store","+m.Store(\"key\", \"value\")","+","+// Load","+value, ok := m.Load(\"key\")","+","+// LoadOrStore","+actual, loaded := m.LoadOrStore(\"key\", \"new-value\")","+","+// Delete","+m.Delete(\"key\")","+","+// Range","+m.Range(func(key, value interface{}) bool {","+    fmt.Printf(\"%v: %v\\n\", key, value)","+    return true  // Continue iteration","+})","+```","+","+## Error Handling","+","+### Error Interface","+","+```go","+// Error interface","+type error interface {","+    Error() string"," }","+","+// Creating errors","+import \"errors\"","+","+err := errors.New(\"something went wrong\")","+err := fmt.Errorf(\"failed to process %s: %v\", filename, originalErr)","+","+// Custom error types","+type ValidationError struct {","+    Field string","+    Value interface{}","+    Msg   string","+}","+","+func (e ValidationError) Error() string {","+    return fmt.Sprintf(\"validation error: field=%s value=%v msg=%s\", ","+        e.Field, e.Value, e.Msg)","+}","+","+// Sentinel errors","+var (","+    ErrNotFound   = errors.New(\"not found\")","+    ErrPermission = errors.New(\"permission denied\")","+    ErrTimeout    = errors.New(\"operation timed out\")","+)","+","+// Error wrapping (Go 1.13+)","+originalErr := errors.New(\"original error\")","+wrappedErr := fmt.Errorf(\"wrapped: %w\", originalErr)","+","+// Unwrap errors","+if errors.Is(wrappedErr, originalErr) {","+    fmt.Println(\"Error is originalErr\")","+}","+","+var validationErr ValidationError","+if errors.As(wrappedErr, &validationErr) {","+    fmt.Printf(\"Validation error: %s\\n\", validationErr.Field)","+}"," ```"," ","+### Error Handling Patterns","+","+```go","+// Immediate error checking","+result, err := doSomething()","+if err != nil {","+    return fmt.Errorf(\"doSomething failed: %w\", err)","+}","+","+// Multiple error sources","+func processFile(filename string) error {","+    file, err := os.Open(filename)","+    if err != nil {","+        return fmt.Errorf(\"open file: %w\", err)","+    }","+    defer file.Close()","+    ","+    data, err := io.ReadAll(file)","+    if err != nil {","+        return fmt.Errorf(\"read file: %w\", err)","+    }","+    ","+    if err := processData(data); err != nil {","+        return fmt.Errorf(\"process data: %w\", err)","+    }","+    ","+    return nil","+}","+","+// Error accumulation","+var errs []error","+","+for _, item := range items {","+    if err := process(item); err != nil {","+        errs = append(errs, err)","+    }","+}","+","+if len(errs) > 0 {","+    return fmt.Errorf(\"processing failed with %d errors\", len(errs))","+}","+","+// Retry pattern","+func retryOperation(maxAttempts int) error {","+    var lastErr error","+    ","+    for i := 0; i < maxAttempts; i++ {","+        if err := attemptOperation(); err != nil {","+            lastErr = err","+            time.Sleep(time.Second * time.Duration(i+1))","+            continue","+        }","+        return nil  // Success","+    }","+    ","+    return fmt.Errorf(\"failed after %d attempts: %w\", maxAttempts, lastErr)","+}","+","+// Cleanup on error","+func createResources() (err error) {","+    resource1, err := createResource1()","+    if err != nil {","+        return err","+    }","+    defer func() {","+        if err != nil {","+            resource1.Cleanup()","+        }","+    }()","+    ","+    resource2, err := createResource2()","+    if err != nil {","+        return err  // resource1 cleaned up by defer","+    }","+    ","+    return nil","+}","+```","+","+## Packages and Modules","+","+### Package Organization","+","+```go","+// Package declaration (first non-comment line)","+package mypackage","+","+// Package documentation","+// Package mypackage provides utilities for data processing.","+// It includes functions for parsing, validation, and transformation.","+package mypackage","+","+// Import statements","+import (","+    \"fmt\"           // Standard library","+    \"time\"","+    ","+    \"github.com/pkg/errors\"  // External packages","+    ","+    \"myproject/internal/utils\"  // Internal packages","+)","+","+// Import aliasing","+import (","+    \"context\"","+    stdlog \"log\"  // Alias to avoid conflicts","+    . \"math\"      // Dot import (use sparingly)","+    _ \"image/png\" // Import for side effects only","+)","+","+// Package initialization","+func init() {","+    // Runs when package is imported","+    // Can have multiple init functions","+    fmt.Println(\"Package initialized\")","+}","+","+// Exported (public) - uppercase","+func PublicFunction() {}","+type PublicType struct{}","+const PublicConst = 42","+var PublicVar = \"hello\"","+","+// Unexported (private) - lowercase","+func privateFunction() {}","+type privateType struct{}","+const privateConst = 42","+var privateVar = \"hello\"","+```","+","+### Module Management","+","+```bash","+# Initialize module","+go mod init github.com/username/projectname","+","+# Add dependencies","+go get github.com/pkg/errors","+go get github.com/stretchr/testify@v1.8.0","+","+# Update dependencies","+go get -u ./...              # Update all","+go get -u github.com/pkg/errors  # Update specific","+","+# Clean up","+go mod tidy  # Remove unused dependencies","+","+# Vendor dependencies","+go mod vendor  # Copy dependencies to vendor/","+","+# Module directives in go.mod","+module github.com/username/project","+","+go 1.21","+","+require (","+    github.com/pkg/errors v0.9.1","+    github.com/stretchr/testify v1.8.0","+)","+","+replace github.com/old/package => github.com/new/package v1.0.0","+","+exclude github.com/bad/package v1.0.0","+```","+","+### Internal Packages","+","+```go","+// Internal packages can only be imported by nearby code","+myproject/","+├── cmd/","+│   └── app/","+│       └── main.go  // Can import internal/","+├── internal/","+│   ├── database/    // Only accessible within myproject","+│   └── utils/","+├── pkg/             // Public packages","+│   └── api/","+└── go.mod","+","+// This import works in myproject","+import \"myproject/internal/database\"","+","+// This import fails outside myproject","+import \"github.com/other/project/internal/database\"  // Error","+```","+"," ## Type Assertions and Type Switches"," "," ### Type Assertions","+"," ```go","-// Type assertion from interface","+// Basic type assertion"," var i interface{} = \"hello\"","+s := i.(string)  // Panics if not string","+fmt.Println(s)"," ","-// Simple assertion (panics if wrong type)","-s := i.(string)","-","-// Safe assertion with ok check","+// Safe type assertion"," s, ok := i.(string)","-if ok {","-    fmt.Printf(\"String: %s\\n\", s)","-} else {","+if !ok {","     fmt.Println(\"Not a string\")"," }"," ","-// Common pattern with error checking","-if str, ok := i.(string); ok {","-    // Use str","+// Common patterns","+func processValue(v interface{}) {","+    // Try multiple types","+    switch value := v.(type) {","+    case string:","+        fmt.Printf(\"String: %s\\n\", value)","+    case int:","+        fmt.Printf(\"Integer: %d\\n\", value)","+    case []byte:","+        fmt.Printf(\"Bytes: %s\\n\", string(value))","+    default:","+        fmt.Printf(\"Unknown: %T\\n\", value)","+    }"," }"," ","-// Asserting to interface","+// Check for interface implementation"," type Stringer interface {","     String() string"," }"," ","-if s, ok := i.(Stringer); ok {","-    fmt.Println(s.String())","+func toString(v interface{}) string {","+    if s, ok := v.(Stringer); ok {","+        return s.String()","+    }","+    return fmt.Sprintf(\"%v\", v)"," }","+","+// Nil interface gotcha","+var p *Person  // nil pointer","+var i interface{} = p","+","+if i == nil {","+    fmt.Println(\"i is nil\")  // Won't print!","+}","+","+if p == nil {","+    fmt.Println(\"p is nil\")  // Will print","+}"," ```"," ","-### Type Switches","+## Embedding and Composition","+","+### Struct Embedding","+"," ```go","-// Type switch for multiple type checks","-func describe(i interface{}) {","-    switch v := i.(type) {","-    case int:","-        fmt.Printf(\"Integer: %d\\n\", v)","-    case string:","-        fmt.Printf(\"String: %s\\n\", v)","-    case bool:","-        fmt.Printf(\"Boolean: %t\\n\", v)","-    case []int:","-        fmt.Printf(\"Slice of ints: %v\\n\", v)","-    case map[string]int:","-        fmt.Printf(\"Map: %v\\n\", v)","-    case func():","-        fmt.Println(\"Function\")","-        v()  // Can call it","-    case nil:","-        fmt.Println(\"nil\")","-    default:","-        fmt.Printf(\"Unknown type: %T\\n\", v)","+// Base types","+type Person struct {","+    Name string","+    Age  int","+}","+","+type Address struct {","+    Street string","+    City   string","+}","+","+// Embedding","+type Employee struct {","+    Person      // Anonymous field","+    Address     // Another anonymous field","+    Department string","+    Salary     float64","+}","+","+emp := Employee{","+    Person:     Person{Name: \"Alice\", Age: 30},","+    Address:    Address{City: \"New York\"},","+    Department: \"Engineering\",","+}","+","+// Field promotion","+fmt.Println(emp.Name)  // Accessed directly","+fmt.Println(emp.City)","+","+// Method promotion","+func (p Person) Introduce() {","+    fmt.Printf(\"Hi, I'm %s\\n\", p.Name)","+}","+","+emp.Introduce()  // Method promoted from Person","+","+// Shadowing","+type Manager struct {","+    Employee","+    Name string  // Shadows Person.Name","+}","+","+mgr := Manager{","+    Employee: emp,","+    Name:     \"Manager Name\",  // This shadows Employee.Person.Name","+}","+","+fmt.Println(mgr.Name)              // \"Manager Name\"","+fmt.Println(mgr.Employee.Name)     // \"Alice\"","+fmt.Println(mgr.Employee.Person.Name)  // \"Alice\"","+```","+","+### Interface Embedding","+","+```go","+// Base interfaces","+type Reader interface {","+    Read([]byte) (int, error)","+}","+","+type Writer interface {","+    Write([]byte) (int, error)","+}","+","+type Closer interface {","+    Close() error","+}","+","+// Embedded interfaces","+type ReadWriter interface {","+    Reader","+    Writer","+}","+","+type ReadWriteCloser interface {","+    Reader","+    Writer","+    Closer","+}","+","+// Alternative syntax","+type ReadWriteCloser interface {","+    Read([]byte) (int, error)","+    Write([]byte) (int, error)","+    Close() error","+}","+","+// Implementation","+type File struct {","+    // fields","+}","+","+func (f *File) Read(p []byte) (int, error) {","+    // implementation","+}","+","+func (f *File) Write(p []byte) (int, error) {","+    // implementation","+}","+","+func (f *File) Close() error {","+    // implementation","+}","+","+// File now implements ReadWriteCloser","+var rwc ReadWriteCloser = &File{}","+```","+","+## Generics","+","+### Generic Functions","+","+```go","+// Generic function with type parameter","+func Max[T comparable](a, b T) T {","+    if a > b {","+        return a","     }","+    return b"," }"," ","-// Type switch with multiple cases","-switch v := i.(type) {","-case int, int32, int64:","-    fmt.Println(\"Some integer type\")","-case string, []byte:","-    fmt.Println(\"String-like type\")","+// Usage","+maxInt := Max(10, 20)           // Type inferred","+maxFloat := Max[float64](3.14, 2.71)  // Explicit type","+","+// Multiple type parameters","+func Swap[T, U any](a T, b U) (U, T) {","+    return b, a"," }"," ","-// Type switch in error handling","-func handleError(err error) {","-    switch e := err.(type) {","-    case *os.PathError:","-        fmt.Printf(\"Path error: %s\\n\", e.Path)","-    case *json.SyntaxError:","-        fmt.Printf(\"JSON syntax error at offset %d\\n\", e.Offset)","-    default:","-        fmt.Printf(\"Generic error: %v\\n\", err)","+// Type constraints","+type Number interface {","+    int | int32 | int64 | float32 | float64","+}","+","+func Sum[T Number](numbers []T) T {","+    var sum T","+    for _, n := range numbers {","+        sum += n","     }","+    return sum"," }","+","+// Using standard constraints","+import \"golang.org/x/exp/constraints\"","+","+func Min[T constraints.Ordered](a, b T) T {","+    if a < b {","+        return a","+    }","+    return b","+}"," ```"," ","+### Generic Types","+","+```go","+// Generic struct","+type Stack[T any] struct {","+    items []T","+}","+","+func (s *Stack[T]) Push(item T) {","+    s.items = append(s.items, item)","+}","+","+func (s *Stack[T]) Pop() (T, bool) {","+    var zero T","+    if len(s.items) == 0 {","+        return zero, false","+    }","+    item := s.items[len(s.items)-1]","+    s.items = s.items[:len(s.items)-1]","+    return item, true","+}","+","+// Usage","+intStack := Stack[int]{}","+intStack.Push(42)","+value, ok := intStack.Pop()","+","+// Generic interface","+type Container[T any] interface {","+    Add(T)","+    Get(int) T","+    Size() int","+}","+","+// Type inference with generics","+type Pair[T, U any] struct {","+    First  T","+    Second U","+}","+","+// Constructor function","+func NewPair[T, U any](first T, second U) Pair[T, U] {","+    return Pair[T, U]{First: first, Second: second}","+}","+","+// Type inference in use","+p := NewPair(1, \"hello\")  // Pair[int, string] inferred","+```","+","+### Type Constraints","+","+```go","+// Custom constraints","+type Signed interface {","+    ~int | ~int8 | ~int16 | ~int32 | ~int64","+}","+","+type Unsigned interface {","+    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64","+}","+","+type Integer interface {","+    Signed | Unsigned","+}","+","+// Tilde (~) allows underlying types","+type MyInt int","+","+func Double[T ~int](x T) T {","+    return x * 2","+}","+","+var mi MyInt = 5","+result := Double(mi)  // Works because MyInt's underlying type is int","+","+// Constraint with methods","+type Stringer interface {","+    String() string","+}","+","+func PrintAll[T Stringer](items []T) {","+    for _, item := range items {","+        fmt.Println(item.String())","+    }","+}","+","+// Complex constraints","+type Number interface {","+    ~int | ~int8 | ~int16 | ~int32 | ~int64 |","+    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |","+    ~float32 | ~float64","+}","+","+type Addable[T any] interface {","+    Add(T) T","+}","+","+type AddableNumber[T Number] interface {","+    Number","+    Addable[T]","+}","+```","+"," ## Best Practices Summary"," ","-1. **Naming**: Use clear, descriptive names. Short names for short-lived variables.","-2. **Error Handling**: Always check errors, wrap with context","-3. **Interfaces**: Keep them small and focused","-4. **Zero Values**: Design types to be useful at their zero value","-5. **Channels**: Use for communication between goroutines","-6. **Defer**: Use for cleanup, runs in LIFO order","-7. **Pointers**: Use when modifying or avoiding copies","-8. **Slices**: Prefer over arrays for flexibility","-9. **Maps**: Remember they're not thread-safe","-10. **Type Assertions**: Always use the two-value form for safety","\\ No newline at end of file","+### Code Organization","+- Keep packages small and focused","+- Use clear, descriptive names","+- Group related functionality","+- Minimize package dependencies","+- Use internal packages for private code","+","+### Error Handling","+- Always check errors","+- Wrap errors with context","+- Use sentinel errors for known conditions","+- Create custom error types when needed","+- Handle errors at the appropriate level","+","+### Concurrency","+- Don't communicate by sharing memory; share memory by communicating","+- Use channels for coordination","+- Keep goroutines simple","+- Always handle goroutine cleanup","+- Use context for cancellation","+","+### Performance","+- Measure before optimizing","+- Preallocate slices when size is known","+- Use string.Builder for string concatenation","+- Be aware of memory allocations","+- Profile your code","+","+### Testing","+- Write table-driven tests","+- Test edge cases","+- Use subtests for better organization","+- Mock external dependencies","+- Aim for high test coverage","+","+### Documentation","+- Document all exported items","+- Write clear package documentation","+- Include examples in documentation","+- Keep comments up to date","+- Use godoc format","+","+This comprehensive guide covers the fundamental aspects of Go programming. Each topic includes practical examples and best practices to help write idiomatic, efficient Go code.","\\ No newline at end of file"]}]}}
{"parentUuid":"585f78f1-2c40-413f-9eaa-bd1364fb728a","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01B1P8v22jcWGjap2yF29T2j","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now updating todo.md and continuing with the next task:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":47782,"cache_read_input_tokens":34798,"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CS5M6TxyEWWiRjeY7MPhv","type":"assistant","uuid":"b98766fb-54a4-4ea1-b9eb-788222d4de48","timestamp":"2025-08-13T07:53:28.321Z"}
{"parentUuid":"b98766fb-54a4-4ea1-b9eb-788222d4de48","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01B1P8v22jcWGjap2yF29T2j","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01MGSHE5GnoShxEpRN4Ue2kg","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed"},{"id":"2","content":"Create comprehensive Go language fundamentals documentation","status":"completed"},{"id":"3","content":"Document all Go design patterns and idioms","status":"in_progress"},{"id":"4","content":"Create advanced Go concurrency documentation","status":"pending"},{"id":"5","content":"Document Go testing and benchmarking practices","status":"pending"},{"id":"6","content":"Create Go performance optimization guide","status":"pending"},{"id":"7","content":"Document Go security best practices","status":"pending"},{"id":"8","content":"Create Go tooling and ecosystem documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":47782,"cache_read_input_tokens":34798,"output_tokens":271,"service_tier":"standard"}},"requestId":"req_011CS5M6TxyEWWiRjeY7MPhv","type":"assistant","uuid":"cc457571-cd4b-4ad0-adde-b1c4de000d74","timestamp":"2025-08-13T07:53:32.223Z"}
{"parentUuid":"cc457571-cd4b-4ad0-adde-b1c4de000d74","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MGSHE5GnoShxEpRN4Ue2kg","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"7f02de8d-4d31-4bd0-9fc9-430a7f1e52bd","timestamp":"2025-08-13T07:53:32.248Z","toolUseResult":{"oldTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"in_progress","id":"2"},{"content":"Document all Go design patterns and idioms","status":"pending","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}],"newTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"completed","id":"2"},{"content":"Document all Go design patterns and idioms","status":"in_progress","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}]}}
{"parentUuid":"7f02de8d-4d31-4bd0-9fc9-430a7f1e52bd","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01TQhZDXnrbWrPHkiBefXaXZ","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01Np3jiXhWtgmRRhJEZvz1Sf","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/todo.md","content":"# Task List\n\n## High Priority\n- [x] Examine existing /back/.docs/code/practices-patterns file\n- [x] Create comprehensive Go language fundamentals documentation (go-fundamentals.md)\n- [ ] Document all Go design patterns and idioms (in progress)\n- [ ] Create advanced Go concurrency documentation\n- [ ] Document Go testing and benchmarking practices\n- [ ] Create Go performance optimization guide\n- [ ] Document Go security best practices\n- [ ] Create Go tooling and ecosystem documentation\n\n## Notes\nCreating comprehensive Go documentation suite in /back/.docs/code/ directory to serve as the definitive reference for Go programming."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":521,"cache_read_input_tokens":82580,"output_tokens":228,"service_tier":"standard"}},"requestId":"req_011CS5M7TKogXNyXM9ZhMzp1","type":"assistant","uuid":"3de5f12c-cb8b-4504-9286-d87f30d896b0","timestamp":"2025-08-13T07:53:39.687Z"}
{"parentUuid":"3de5f12c-cb8b-4504-9286-d87f30d896b0","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has not been read yet. Read it first before writing to it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01Np3jiXhWtgmRRhJEZvz1Sf"}]},"uuid":"9c29ed8b-45ad-48ad-a137-91bc28b5226a","timestamp":"2025-08-13T07:53:39.723Z","toolUseResult":"Error: File has not been read yet. Read it first before writing to it."}
{"parentUuid":"9c29ed8b-45ad-48ad-a137-91bc28b5226a","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01Er377Q6zf2V8nrhGahoSTv","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01TTweuA4UZc8g69hc7sAgi5","name":"Read","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/todo.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":273,"cache_read_input_tokens":83101,"output_tokens":71,"service_tier":"standard"}},"requestId":"req_011CS5M7zrNX2aYaPyBqNucR","type":"assistant","uuid":"59b20f75-4d05-4d53-a39c-bc531bce3d45","timestamp":"2025-08-13T07:53:43.548Z"}
{"parentUuid":"59b20f75-4d05-4d53-a39c-bc531bce3d45","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TTweuA4UZc8g69hc7sAgi5","type":"tool_result","content":"     1→# TODO List\n     2→\n     3→## Critical Priority\n     4→None\n     5→\n     6→## High Priority  \n     7→None\n     8→\n     9→## Medium Priority\n    10→None\n    11→\n    12→## Low Priority\n    13→None\n    14→\n    15→## Completed\n    16→- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)\n    17→- [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)\n    18→- [x] Update import paths with module prefix (updated to github.com/dominicnunez/bigmeanie)\n    19→- [x] Add thread-safe MockClock implementation example (added SafeMockClock wrapper with mutex)\n    20→- [x] Document error handling in indicators (added comprehensive error handling section)\n    21→- [x] Update goroutine package documented features (added TrackedGo, ListActive, StopAll to API docs)\n    22→- [x] Fix naming inconsistencies (changed misc → pinescript to match actual directory)\n    23→- [x] Add benchmarks or qualify performance claims (added environment notes and benchmark commands)\n    24→- [x] Add external error wrapping examples (added comprehensive examples for stdlib and third-party)\n    25→- [x] Fix package declaration in fees.go\n    26→- [x] Remove verbose type names (CheckpointWorker → Worker, GracefulShutdown → Shutdown, CrashDetector → Monitor)\n    27→- [x] Remove Get prefixes and verbose method names (GetCandles → Candles, NewSlidingWindow → NewWindow)\n    28→- [x] Restructure fees.go with nested structs (Spot.Maker/Taker, Perp.Maker/Taker)\n    29→- [x] Simplify function names in context.go (ProcessWithPeriodicCheck → Process, OperationWithTimeout → DoTimeout, ProcessItemsWithTimeouts → ProcessBatch, WorkerWithGracefulShutdown → Worker)\n    30→- [x] Rename generator types in paramsgen (DynamicGenerator → Generator, GeneratorConfig → Config, ParameterSweep → Sweep)\n    31→- [x] Update decimal cache constants (OnePercent → Pct1, FivePercent → Pct5, TenPercent → Pct10, etc.)\n    32→- [x] Rename interfaces and helper functions (SignalGenerator → Strategy, RunSafeWorker → RunSafe, OptimalWorkerCount → WorkerCount, OptimizedWorker → Worker)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c57b5783-15a8-4858-8f40-723565db78c0","timestamp":"2025-08-13T07:53:43.570Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/todo.md","content":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \nNone\n\n## Medium Priority\nNone\n\n## Low Priority\nNone\n\n## Completed\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)\n- [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)\n- [x] Update import paths with module prefix (updated to github.com/dominicnunez/bigmeanie)\n- [x] Add thread-safe MockClock implementation example (added SafeMockClock wrapper with mutex)\n- [x] Document error handling in indicators (added comprehensive error handling section)\n- [x] Update goroutine package documented features (added TrackedGo, ListActive, StopAll to API docs)\n- [x] Fix naming inconsistencies (changed misc → pinescript to match actual directory)\n- [x] Add benchmarks or qualify performance claims (added environment notes and benchmark commands)\n- [x] Add external error wrapping examples (added comprehensive examples for stdlib and third-party)\n- [x] Fix package declaration in fees.go\n- [x] Remove verbose type names (CheckpointWorker → Worker, GracefulShutdown → Shutdown, CrashDetector → Monitor)\n- [x] Remove Get prefixes and verbose method names (GetCandles → Candles, NewSlidingWindow → NewWindow)\n- [x] Restructure fees.go with nested structs (Spot.Maker/Taker, Perp.Maker/Taker)\n- [x] Simplify function names in context.go (ProcessWithPeriodicCheck → Process, OperationWithTimeout → DoTimeout, ProcessItemsWithTimeouts → ProcessBatch, WorkerWithGracefulShutdown → Worker)\n- [x] Rename generator types in paramsgen (DynamicGenerator → Generator, GeneratorConfig → Config, ParameterSweep → Sweep)\n- [x] Update decimal cache constants (OnePercent → Pct1, FivePercent → Pct5, TenPercent → Pct10, etc.)\n- [x] Rename interfaces and helper functions (SignalGenerator → Strategy, RunSafeWorker → RunSafe, OptimalWorkerCount → WorkerCount, OptimizedWorker → Worker)","numLines":32,"startLine":1,"totalLines":32}}}
{"parentUuid":"c57b5783-15a8-4858-8f40-723565db78c0","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01NmJKdti2dwCGAa6A8rBvf2","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01RJmTDYs3fUKnjuXLqyiMzA","name":"Edit","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/todo.md","old_string":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \nNone\n\n## Medium Priority\nNone\n\n## Low Priority\nNone","new_string":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \n- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)\n- [ ] Create advanced Go concurrency documentation (go-concurrency.md)\n- [ ] Document Go testing and benchmarking practices (go-testing.md)\n- [ ] Create Go performance optimization guide (go-performance.md)\n- [ ] Document Go security best practices (go-security.md)\n- [ ] Create Go tooling and ecosystem documentation (go-tools.md)\n\n## Medium Priority\nNone\n\n## Low Priority\nNone"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":788,"cache_read_input_tokens":83374,"output_tokens":270,"service_tier":"standard"}},"requestId":"req_011CS5M8GSjPeHnXegDGxf1z","type":"assistant","uuid":"0d2bef89-0193-4d21-9b93-a64fa1a2e0eb","timestamp":"2025-08-13T07:53:51.285Z"}
{"parentUuid":"0d2bef89-0193-4d21-9b93-a64fa1a2e0eb","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RJmTDYs3fUKnjuXLqyiMzA","type":"tool_result","content":"The file /home/aural/Code/bigmeanie/back/.docs/todo.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→# TODO List\n     2→\n     3→## Critical Priority\n     4→None\n     5→\n     6→## High Priority  \n     7→- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)\n     8→- [ ] Create advanced Go concurrency documentation (go-concurrency.md)\n     9→- [ ] Document Go testing and benchmarking practices (go-testing.md)\n    10→- [ ] Create Go performance optimization guide (go-performance.md)\n    11→- [ ] Document Go security best practices (go-security.md)\n    12→- [ ] Create Go tooling and ecosystem documentation (go-tools.md)\n    13→\n    14→## Medium Priority\n    15→None\n    16→\n    17→## Low Priority\n    18→None\n    19→\n    20→## Completed\n    21→- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)\n    22→- [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)"}]},"uuid":"6f7450df-1138-46dd-8520-fdf15a85c851","timestamp":"2025-08-13T07:53:51.314Z","toolUseResult":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/todo.md","oldString":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \nNone\n\n## Medium Priority\nNone\n\n## Low Priority\nNone","newString":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \n- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)\n- [ ] Create advanced Go concurrency documentation (go-concurrency.md)\n- [ ] Document Go testing and benchmarking practices (go-testing.md)\n- [ ] Create Go performance optimization guide (go-performance.md)\n- [ ] Document Go security best practices (go-security.md)\n- [ ] Create Go tooling and ecosystem documentation (go-tools.md)\n\n## Medium Priority\nNone\n\n## Low Priority\nNone","originalFile":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \nNone\n\n## Medium Priority\nNone\n\n## Low Priority\nNone\n\n## Completed\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)\n- [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)\n- [x] Update import paths with module prefix (updated to github.com/dominicnunez/bigmeanie)\n- [x] Add thread-safe MockClock implementation example (added SafeMockClock wrapper with mutex)\n- [x] Document error handling in indicators (added comprehensive error handling section)\n- [x] Update goroutine package documented features (added TrackedGo, ListActive, StopAll to API docs)\n- [x] Fix naming inconsistencies (changed misc → pinescript to match actual directory)\n- [x] Add benchmarks or qualify performance claims (added environment notes and benchmark commands)\n- [x] Add external error wrapping examples (added comprehensive examples for stdlib and third-party)\n- [x] Fix package declaration in fees.go\n- [x] Remove verbose type names (CheckpointWorker → Worker, GracefulShutdown → Shutdown, CrashDetector → Monitor)\n- [x] Remove Get prefixes and verbose method names (GetCandles → Candles, NewSlidingWindow → NewWindow)\n- [x] Restructure fees.go with nested structs (Spot.Maker/Taker, Perp.Maker/Taker)\n- [x] Simplify function names in context.go (ProcessWithPeriodicCheck → Process, OperationWithTimeout → DoTimeout, ProcessItemsWithTimeouts → ProcessBatch, WorkerWithGracefulShutdown → Worker)\n- [x] Rename generator types in paramsgen (DynamicGenerator → Generator, GeneratorConfig → Config, ParameterSweep → Sweep)\n- [x] Update decimal cache constants (OnePercent → Pct1, FivePercent → Pct5, TenPercent → Pct10, etc.)\n- [x] Rename interfaces and helper functions (SignalGenerator → Strategy, RunSafeWorker → RunSafe, OptimalWorkerCount → WorkerCount, OptimizedWorker → Worker)","structuredPatch":[{"oldStart":4,"oldLines":7,"newStart":4,"newLines":12,"lines":[" None"," "," ## High Priority  ","-None","+- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)","+- [ ] Create advanced Go concurrency documentation (go-concurrency.md)","+- [ ] Document Go testing and benchmarking practices (go-testing.md)","+- [ ] Create Go performance optimization guide (go-performance.md)","+- [ ] Document Go security best practices (go-security.md)","+- [ ] Create Go tooling and ecosystem documentation (go-tools.md)"," "," ## Medium Priority"," None"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"6f7450df-1138-46dd-8520-fdf15a85c851","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01FNVck9wBzinTAsFcpyym5o","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_014WBKZib593BNy1f7m1QHtg","name":"Edit","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/todo.md","old_string":"## Completed\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)","new_string":"## Completed\n- [x] Examine existing /back/.docs/code/practices-patterns file\n- [x] Create comprehensive Go language fundamentals documentation (go-fundamentals.md created)\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":581,"cache_read_input_tokens":84162,"output_tokens":193,"service_tier":"standard"}},"requestId":"req_011CS5M8sAnnQLYhLEf7Pgy4","type":"assistant","uuid":"4069dfc1-f4af-44a0-b63c-c3476bcf4702","timestamp":"2025-08-13T07:53:57.815Z"}
{"parentUuid":"4069dfc1-f4af-44a0-b63c-c3476bcf4702","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014WBKZib593BNy1f7m1QHtg","type":"tool_result","content":"The file /home/aural/Code/bigmeanie/back/.docs/todo.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    16→\n    17→## Low Priority\n    18→None\n    19→\n    20→## Completed\n    21→- [x] Examine existing /back/.docs/code/practices-patterns file\n    22→- [x] Create comprehensive Go language fundamentals documentation (go-fundamentals.md created)\n    23→- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)\n    24→- [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)\n    25→- [x] Update import paths with module prefix (updated to github.com/dominicnunez/bigmeanie)\n    26→- [x] Add thread-safe MockClock implementation example (added SafeMockClock wrapper with mutex)\n    27→- [x] Document error handling in indicators (added comprehensive error handling section)"}]},"uuid":"18977389-2868-455f-a0e1-51849bfe45a9","timestamp":"2025-08-13T07:53:57.849Z","toolUseResult":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/todo.md","oldString":"## Completed\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)","newString":"## Completed\n- [x] Examine existing /back/.docs/code/practices-patterns file\n- [x] Create comprehensive Go language fundamentals documentation (go-fundamentals.md created)\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)","originalFile":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \n- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)\n- [ ] Create advanced Go concurrency documentation (go-concurrency.md)\n- [ ] Document Go testing and benchmarking practices (go-testing.md)\n- [ ] Create Go performance optimization guide (go-performance.md)\n- [ ] Document Go security best practices (go-security.md)\n- [ ] Create Go tooling and ecosystem documentation (go-tools.md)\n\n## Medium Priority\nNone\n\n## Low Priority\nNone\n\n## Completed\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)\n- [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)\n- [x] Update import paths with module prefix (updated to github.com/dominicnunez/bigmeanie)\n- [x] Add thread-safe MockClock implementation example (added SafeMockClock wrapper with mutex)\n- [x] Document error handling in indicators (added comprehensive error handling section)\n- [x] Update goroutine package documented features (added TrackedGo, ListActive, StopAll to API docs)\n- [x] Fix naming inconsistencies (changed misc → pinescript to match actual directory)\n- [x] Add benchmarks or qualify performance claims (added environment notes and benchmark commands)\n- [x] Add external error wrapping examples (added comprehensive examples for stdlib and third-party)\n- [x] Fix package declaration in fees.go\n- [x] Remove verbose type names (CheckpointWorker → Worker, GracefulShutdown → Shutdown, CrashDetector → Monitor)\n- [x] Remove Get prefixes and verbose method names (GetCandles → Candles, NewSlidingWindow → NewWindow)\n- [x] Restructure fees.go with nested structs (Spot.Maker/Taker, Perp.Maker/Taker)\n- [x] Simplify function names in context.go (ProcessWithPeriodicCheck → Process, OperationWithTimeout → DoTimeout, ProcessItemsWithTimeouts → ProcessBatch, WorkerWithGracefulShutdown → Worker)\n- [x] Rename generator types in paramsgen (DynamicGenerator → Generator, GeneratorConfig → Config, ParameterSweep → Sweep)\n- [x] Update decimal cache constants (OnePercent → Pct1, FivePercent → Pct5, TenPercent → Pct10, etc.)\n- [x] Rename interfaces and helper functions (SignalGenerator → Strategy, RunSafeWorker → RunSafe, OptimalWorkerCount → WorkerCount, OptimizedWorker → Worker)","structuredPatch":[{"oldStart":18,"oldLines":6,"newStart":18,"newLines":8,"lines":[" None"," "," ## Completed","+- [x] Examine existing /back/.docs/code/practices-patterns file","+- [x] Create comprehensive Go language fundamentals documentation (go-fundamentals.md created)"," - [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)"," - [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)"," - [x] Update import paths with module prefix (updated to github.com/dominicnunez/bigmeanie)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"18977389-2868-455f-a0e1-51849bfe45a9","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01VCQUsmM26RiAC2yQ7273ju","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Created comprehensive Go fundamentals documentation (go-fundamentals.md) covering all core language features with extensive examples and best practices. The file includes 2000+ lines of detailed documentation on:\n\n- Basic syntax and naming conventions\n- Variables, constants, and data types\n- Control flow (if, switch, loops, defer/panic/recover)\n- Functions, methods, and closures\n- Structs and interfaces\n- Pointers, arrays, slices, and maps\n- Error handling patterns\n- Packages and modules\n- Type assertions and embedding\n- Generics (Go 1.18+)\n- Best practices summary\n\nNext up: Creating Go design patterns documentation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":451,"cache_read_input_tokens":84743,"output_tokens":149,"service_tier":"standard"}},"requestId":"req_011CS5M9LcHnuPfFP2FXwrps","type":"assistant","uuid":"bcac52e9-ef1c-44e3-b1fe-974cccfd45fa","timestamp":"2025-08-13T07:54:04.977Z"}
{"parentUuid":"bcac52e9-ef1c-44e3-b1fe-974cccfd45fa","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"system","content":"\u001b[1mStop\u001b[22m [paplay /run/current-system/sw/share/sounds/freedesktop/stereo/bell.oga] completed successfully","isMeta":false,"timestamp":"2025-08-13T07:54:05.246Z","uuid":"d9e10a80-8912-4478-8405-c3cb3d33d649","toolUseID":"45527051-a118-403c-af15-55cf777de2cc","level":"info"}
{"parentUuid":"d9e10a80-8912-4478-8405-c3cb3d33d649","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":"there needs to be more differentiation on what is in 02-design-patterns and go-patterns. also numbered/go prefixes are unneccessary or redundant"},"uuid":"9bad4f34-be15-448e-80c3-1d796d21e52f","timestamp":"2025-08-13T08:03:52.385Z"}
{"parentUuid":"9bad4f34-be15-448e-80c3-1d796d21e52f","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01QQJhHz4WNJFwcChT5fAvVa","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"You're right. Let me check what exists and create better differentiated documentation without redundant prefixes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":85382,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS5MuBaJ7FikYZtFxYddE","type":"assistant","uuid":"c9cc2471-65c5-45b5-a490-4387e8e484fb","timestamp":"2025-08-13T08:03:56.794Z"}
{"parentUuid":"c9cc2471-65c5-45b5-a490-4387e8e484fb","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01QQJhHz4WNJFwcChT5fAvVa","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01URcekec9TgnGbmGU2SVKMc","name":"Glob","input":{"pattern":"**/*.md","path":"/home/aural/Code/bigmeanie/back/.docs/code"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":85382,"cache_read_input_tokens":0,"output_tokens":109,"service_tier":"standard"}},"requestId":"req_011CS5MuBaJ7FikYZtFxYddE","type":"assistant","uuid":"fd8d736f-da4f-465a-90fa-65d2dce30c58","timestamp":"2025-08-13T08:03:57.776Z"}
{"parentUuid":"fd8d736f-da4f-465a-90fa-65d2dce30c58","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01URcekec9TgnGbmGU2SVKMc","type":"tool_result","content":"/home/aural/Code/bigmeanie/back/.docs/code/01-core-language.md\n/home/aural/Code/bigmeanie/back/.docs/code/02-design-patterns.md\n/home/aural/Code/bigmeanie/back/.docs/code/go-concurrency.md\n/home/aural/Code/bigmeanie/back/.docs/code/go-patterns.md\n/home/aural/Code/bigmeanie/back/.docs/code/go-testing.md\n/home/aural/Code/bigmeanie/back/.docs/code/go-performance.md\n/home/aural/Code/bigmeanie/back/.docs/code/go-packages.md\n/home/aural/Code/bigmeanie/back/.docs/code/go-errors.md\n/home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md"}]},"uuid":"4a938285-e0de-4be6-bd5b-5b8731e55641","timestamp":"2025-08-13T08:03:57.803Z","toolUseResult":{"filenames":["/home/aural/Code/bigmeanie/back/.docs/code/01-core-language.md","/home/aural/Code/bigmeanie/back/.docs/code/02-design-patterns.md","/home/aural/Code/bigmeanie/back/.docs/code/go-concurrency.md","/home/aural/Code/bigmeanie/back/.docs/code/go-patterns.md","/home/aural/Code/bigmeanie/back/.docs/code/go-testing.md","/home/aural/Code/bigmeanie/back/.docs/code/go-performance.md","/home/aural/Code/bigmeanie/back/.docs/code/go-packages.md","/home/aural/Code/bigmeanie/back/.docs/code/go-errors.md","/home/aural/Code/bigmeanie/back/.docs/code/go-fundamentals.md"],"durationMs":5,"numFiles":9,"truncated":false}}
{"parentUuid":"4a938285-e0de-4be6-bd5b-5b8731e55641","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01BzuCSEw3eCUJYX1WcY4xna","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01UXTEBMSnvL2FmbkW9PtFow","name":"Read","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/02-design-patterns.md","limit":100}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":338,"cache_read_input_tokens":85382,"output_tokens":94,"service_tier":"standard"}},"requestId":"req_011CS5MuYZc6CRJBC2jEdPsF","type":"assistant","uuid":"7fc70401-9e4b-4ebf-bc81-0ec5f094c870","timestamp":"2025-08-13T08:04:02.117Z"}
{"parentUuid":"7fc70401-9e4b-4ebf-bc81-0ec5f094c870","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UXTEBMSnvL2FmbkW9PtFow","type":"tool_result","content":"     1→# Go Design Patterns - Comprehensive Guide\n     2→\n     3→## Table of Contents\n     4→1. [Creational Patterns](#creational-patterns)\n     5→2. [Structural Patterns](#structural-patterns)\n     6→3. [Behavioral Patterns](#behavioral-patterns)\n     7→4. [Concurrency Patterns](#concurrency-patterns)\n     8→5. [Go-Specific Idioms](#go-specific-idioms)\n     9→6. [Messaging Patterns](#messaging-patterns)\n    10→7. [Error Handling Patterns](#error-handling-patterns)\n    11→8. [Architecture Patterns](#architecture-patterns)\n    12→\n    13→## Creational Patterns\n    14→\n    15→### Singleton Pattern\n    16→\n    17→```go\n    18→// Thread-safe singleton using sync.Once\n    19→package singleton\n    20→\n    21→import (\n    22→    \"database/sql\"\n    23→    \"sync\"\n    24→)\n    25→\n    26→type Database struct {\n    27→    conn *sql.DB\n    28→}\n    29→\n    30→var (\n    31→    instance *Database\n    32→    once     sync.Once\n    33→)\n    34→\n    35→func GetInstance() *Database {\n    36→    once.Do(func() {\n    37→        conn, err := sql.Open(\"postgres\", \"connection-string\")\n    38→        if err != nil {\n    39→            panic(err)\n    40→        }\n    41→        instance = &Database{conn: conn}\n    42→    })\n    43→    return instance\n    44→}\n    45→\n    46→// Alternative: Package-level variable (simpler)\n    47→var db = &Database{\n    48→    conn: initDB(),\n    49→}\n    50→\n    51→func initDB() *sql.DB {\n    52→    conn, err := sql.Open(\"postgres\", \"connection-string\")\n    53→    if err != nil {\n    54→        panic(err)\n    55→    }\n    56→    return conn\n    57→}\n    58→\n    59→func GetDB() *Database {\n    60→    return db\n    61→}\n    62→```\n    63→\n    64→### Factory Pattern\n    65→\n    66→```go\n    67→// Factory Method Pattern\n    68→package factory\n    69→\n    70→type PaymentMethod interface {\n    71→    Pay(amount float64) error\n    72→    ValidateDetails() error\n    73→}\n    74→\n    75→type PaymentType string\n    76→\n    77→const (\n    78→    CreditCard PaymentType = \"credit_card\"\n    79→    PayPal     PaymentType = \"paypal\"\n    80→    Bitcoin    PaymentType = \"bitcoin\"\n    81→)\n    82→\n    83→// Factory function\n    84→func NewPaymentMethod(t PaymentType, details map[string]string) (PaymentMethod, error) {\n    85→    switch t {\n    86→    case CreditCard:\n    87→        return &CreditCardPayment{\n    88→            Number: details[\"number\"],\n    89→            CVV:    details[\"cvv\"],\n    90→            Expiry: details[\"expiry\"],\n    91→        }, nil\n    92→    case PayPal:\n    93→        return &PayPalPayment{\n    94→            Email:    details[\"email\"],\n    95→            Password: details[\"password\"],\n    96→        }, nil\n    97→    case Bitcoin:\n    98→        return &BitcoinPayment{\n    99→            WalletAddress: details[\"wallet\"],\n   100→            PrivateKey:    details[\"key\"],\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b28bc1a2-0bef-4c5f-94d8-92e6048fd46f","timestamp":"2025-08-13T08:04:02.143Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/code/02-design-patterns.md","content":"# Go Design Patterns - Comprehensive Guide\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Concurrency Patterns](#concurrency-patterns)\n5. [Go-Specific Idioms](#go-specific-idioms)\n6. [Messaging Patterns](#messaging-patterns)\n7. [Error Handling Patterns](#error-handling-patterns)\n8. [Architecture Patterns](#architecture-patterns)\n\n## Creational Patterns\n\n### Singleton Pattern\n\n```go\n// Thread-safe singleton using sync.Once\npackage singleton\n\nimport (\n    \"database/sql\"\n    \"sync\"\n)\n\ntype Database struct {\n    conn *sql.DB\n}\n\nvar (\n    instance *Database\n    once     sync.Once\n)\n\nfunc GetInstance() *Database {\n    once.Do(func() {\n        conn, err := sql.Open(\"postgres\", \"connection-string\")\n        if err != nil {\n            panic(err)\n        }\n        instance = &Database{conn: conn}\n    })\n    return instance\n}\n\n// Alternative: Package-level variable (simpler)\nvar db = &Database{\n    conn: initDB(),\n}\n\nfunc initDB() *sql.DB {\n    conn, err := sql.Open(\"postgres\", \"connection-string\")\n    if err != nil {\n        panic(err)\n    }\n    return conn\n}\n\nfunc GetDB() *Database {\n    return db\n}\n```\n\n### Factory Pattern\n\n```go\n// Factory Method Pattern\npackage factory\n\ntype PaymentMethod interface {\n    Pay(amount float64) error\n    ValidateDetails() error\n}\n\ntype PaymentType string\n\nconst (\n    CreditCard PaymentType = \"credit_card\"\n    PayPal     PaymentType = \"paypal\"\n    Bitcoin    PaymentType = \"bitcoin\"\n)\n\n// Factory function\nfunc NewPaymentMethod(t PaymentType, details map[string]string) (PaymentMethod, error) {\n    switch t {\n    case CreditCard:\n        return &CreditCardPayment{\n            Number: details[\"number\"],\n            CVV:    details[\"cvv\"],\n            Expiry: details[\"expiry\"],\n        }, nil\n    case PayPal:\n        return &PayPalPayment{\n            Email:    details[\"email\"],\n            Password: details[\"password\"],\n        }, nil\n    case Bitcoin:\n        return &BitcoinPayment{\n            WalletAddress: details[\"wallet\"],\n            PrivateKey:    details[\"key\"],","numLines":100,"startLine":1,"totalLines":2518}}}
{"parentUuid":"b28bc1a2-0bef-4c5f-94d8-92e6048fd46f","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01Y81QTZxAVzDNfmpQXj2jpg","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01182BG423TZZYLkRYZ8NQG5","name":"Read","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/go-patterns.md","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1112,"cache_read_input_tokens":85720,"output_tokens":92,"service_tier":"standard"}},"requestId":"req_011CS5Mut5MwE3jsKVRsBskF","type":"assistant","uuid":"33879796-fd60-4892-bf6e-1bb58d614a3f","timestamp":"2025-08-13T08:04:07.295Z"}
{"parentUuid":"33879796-fd60-4892-bf6e-1bb58d614a3f","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01182BG423TZZYLkRYZ8NQG5","type":"tool_result","content":"     1→# Go Design Patterns - Comprehensive Pattern Guide\n     2→\n     3→## Table of Contents\n     4→1. [Creational Patterns](#creational-patterns)\n     5→2. [Structural Patterns](#structural-patterns)\n     6→3. [Behavioral Patterns](#behavioral-patterns)\n     7→4. [Concurrency Patterns](#concurrency-patterns)\n     8→5. [Go Idioms](#go-idioms)\n     9→6. [Functional Options](#functional-options)\n    10→7. [Dependency Injection](#dependency-injection)\n    11→8. [Error Handling Patterns](#error-handling-patterns)\n    12→9. [Testing Patterns](#testing-patterns)\n    13→10. [Performance Patterns](#performance-patterns)\n    14→\n    15→## Creational Patterns\n    16→\n    17→### Singleton\n    18→```go\n    19→// Thread-safe singleton using sync.Once\n    20→type singleton struct {\n    21→    data string\n    22→}\n    23→\n    24→var (\n    25→    instance *singleton\n    26→    once     sync.Once\n    27→)\n    28→\n    29→func GetInstance() *singleton {\n    30→    once.Do(func() {\n    31→        instance = &singleton{\n    32→            data: \"initialized\",\n    33→        }\n    34→    })\n    35→    return instance\n    36→}\n    37→\n    38→// Singleton with initialization parameters\n    39→type Database struct {\n    40→    connection string\n    41→}\n    42→\n    43→var (\n    44→    db     *Database\n    45→    dbOnce sync.Once\n    46→)\n    47→\n    48→func InitDatabase(conn string) *Database {\n    49→    dbOnce.Do(func() {\n    50→        db = &Database{\n    51→            connection: conn,\n    52→        }\n    53→    })\n    54→    return db\n    55→}\n    56→\n    57→func GetDatabase() *Database {\n    58→    if db == nil {\n    59→        panic(\"database not initialized\")\n    60→    }\n    61→    return db\n    62→}\n    63→```\n    64→\n    65→### Factory\n    66→```go\n    67→// Simple factory\n    68→type StorageType int\n    69→\n    70→const (\n    71→    DiskStorage StorageType = iota\n    72→    MemoryStorage\n    73→    CloudStorage\n    74→)\n    75→\n    76→type Storage interface {\n    77→    Save(data []byte) error\n    78→    Load(id string) ([]byte, error)\n    79→}\n    80→\n    81→func NewStorage(t StorageType) Storage {\n    82→    switch t {\n    83→    case DiskStorage:\n    84→        return &diskStorage{}\n    85→    case MemoryStorage:\n    86→        return &memoryStorage{}\n    87→    case CloudStorage:\n    88→        return &cloudStorage{}\n    89→    default:\n    90→        return &memoryStorage{}\n    91→    }\n    92→}\n    93→\n    94→// Factory with registration\n    95→type Creator func() Storage\n    96→\n    97→var creators = make(map[string]Creator)\n    98→\n    99→func RegisterStorage(name string, creator Creator) {\n   100→    creators[name] = creator\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4d1a6068-f6a1-4d75-a73b-e24ae2ab724c","timestamp":"2025-08-13T08:04:07.322Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/code/go-patterns.md","content":"# Go Design Patterns - Comprehensive Pattern Guide\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Concurrency Patterns](#concurrency-patterns)\n5. [Go Idioms](#go-idioms)\n6. [Functional Options](#functional-options)\n7. [Dependency Injection](#dependency-injection)\n8. [Error Handling Patterns](#error-handling-patterns)\n9. [Testing Patterns](#testing-patterns)\n10. [Performance Patterns](#performance-patterns)\n\n## Creational Patterns\n\n### Singleton\n```go\n// Thread-safe singleton using sync.Once\ntype singleton struct {\n    data string\n}\n\nvar (\n    instance *singleton\n    once     sync.Once\n)\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &singleton{\n            data: \"initialized\",\n        }\n    })\n    return instance\n}\n\n// Singleton with initialization parameters\ntype Database struct {\n    connection string\n}\n\nvar (\n    db     *Database\n    dbOnce sync.Once\n)\n\nfunc InitDatabase(conn string) *Database {\n    dbOnce.Do(func() {\n        db = &Database{\n            connection: conn,\n        }\n    })\n    return db\n}\n\nfunc GetDatabase() *Database {\n    if db == nil {\n        panic(\"database not initialized\")\n    }\n    return db\n}\n```\n\n### Factory\n```go\n// Simple factory\ntype StorageType int\n\nconst (\n    DiskStorage StorageType = iota\n    MemoryStorage\n    CloudStorage\n)\n\ntype Storage interface {\n    Save(data []byte) error\n    Load(id string) ([]byte, error)\n}\n\nfunc NewStorage(t StorageType) Storage {\n    switch t {\n    case DiskStorage:\n        return &diskStorage{}\n    case MemoryStorage:\n        return &memoryStorage{}\n    case CloudStorage:\n        return &cloudStorage{}\n    default:\n        return &memoryStorage{}\n    }\n}\n\n// Factory with registration\ntype Creator func() Storage\n\nvar creators = make(map[string]Creator)\n\nfunc RegisterStorage(name string, creator Creator) {\n    creators[name] = creator","numLines":100,"startLine":1,"totalLines":2049}}}
{"parentUuid":"4d1a6068-f6a1-4d75-a73b-e24ae2ab724c","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01NAeHptmstsupvSiKb5U784","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"I see the issue - we have duplicate pattern files with overlapping content. Let me reorganize this to have clear differentiation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1041,"cache_read_input_tokens":86832,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS5MvGZxYnqzC7ooRbbuq","type":"assistant","uuid":"a48bbece-55c5-4806-a3d8-e2009fb8ccab","timestamp":"2025-08-13T08:04:12.782Z"}
{"parentUuid":"a48bbece-55c5-4806-a3d8-e2009fb8ccab","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01NAeHptmstsupvSiKb5U784","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_0182mBdcxrHHXzxsvg2KZF96","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed"},{"id":"2","content":"Create comprehensive Go language fundamentals documentation","status":"completed"},{"id":"3","content":"Reorganize and differentiate pattern documentation files","status":"in_progress"},{"id":"4","content":"Create advanced Go concurrency documentation","status":"pending"},{"id":"5","content":"Document Go testing and benchmarking practices","status":"pending"},{"id":"6","content":"Create Go performance optimization guide","status":"pending"},{"id":"7","content":"Document Go security best practices","status":"pending"},{"id":"8","content":"Create Go tooling and ecosystem documentation","status":"pending"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1041,"cache_read_input_tokens":86832,"output_tokens":286,"service_tier":"standard"}},"requestId":"req_011CS5MvGZxYnqzC7ooRbbuq","type":"assistant","uuid":"35699af8-cb29-41e7-9c3e-defe5a613c32","timestamp":"2025-08-13T08:04:17.041Z"}
{"parentUuid":"35699af8-cb29-41e7-9c3e-defe5a613c32","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0182mBdcxrHHXzxsvg2KZF96","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"c48aadce-5cd6-43bb-b6d0-7a74cbca8e2d","timestamp":"2025-08-13T08:04:17.066Z","toolUseResult":{"oldTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"completed","id":"2"},{"content":"Document all Go design patterns and idioms","status":"in_progress","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}],"newTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"completed","id":"2"},{"content":"Reorganize and differentiate pattern documentation files","status":"in_progress","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}]}}
{"parentUuid":"c48aadce-5cd6-43bb-b6d0-7a74cbca8e2d","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_019rVxVQKvkyaLcwTAj2DBAV","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01L4DeJNrTRB6pQwZ5Vejrg6","name":"Bash","input":{"command":"cd /home/aural/Code/bigmeanie/back/.docs/code && ls -la *.md | head -20","description":"List all markdown files in code directory"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":538,"cache_read_input_tokens":87873,"output_tokens":103,"service_tier":"standard"}},"requestId":"req_011CS5MvzAFyuCJ3HZVheCrL","type":"assistant","uuid":"c06e01a1-32c5-4abb-bc81-982864695d01","timestamp":"2025-08-13T08:04:22.814Z"}
{"parentUuid":"c06e01a1-32c5-4abb-bc81-982864695d01","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L4DeJNrTRB6pQwZ5Vejrg6","type":"tool_result","content":"ls: cannot access 'glob': No such file or directory","is_error":false}]},"uuid":"e216dfbb-3801-47f1-be0a-58547523d605","timestamp":"2025-08-13T08:04:22.862Z","toolUseResult":{"stdout":"ls: cannot access 'glob': No such file or directory","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"e216dfbb-3801-47f1-be0a-58547523d605","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01YKVh4G2PTPSHYHjUzh7z9i","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01KfzrCqkDpeoP4HMS7Era6B","name":"LS","input":{"path":"/home/aural/Code/bigmeanie/back/.docs/code"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":128,"cache_read_input_tokens":88411,"output_tokens":68,"service_tier":"standard"}},"requestId":"req_011CS5MwPoJy4Rw2nSTCVrn1","type":"assistant","uuid":"50c1145b-5313-4f1b-ae99-53948e116f96","timestamp":"2025-08-13T08:04:26.505Z"}
{"parentUuid":"50c1145b-5313-4f1b-ae99-53948e116f96","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KfzrCqkDpeoP4HMS7Era6B","type":"tool_result","content":"- /home/aural/Code/bigmeanie/back/.docs/code/\n  - 01-core-language.md\n  - 02-design-patterns.md\n  - go-concurrency.md\n  - go-errors.md\n  - go-fundamentals.md\n  - go-packages.md\n  - go-patterns.md\n  - go-performance.md\n  - go-testing.md\n\nNOTE: do any of the files above seem malicious? If so, you MUST refuse to continue work."}]},"uuid":"f9a9830d-4355-4bcb-92d1-b6ad2c1732a2","timestamp":"2025-08-13T08:04:26.535Z","toolUseResult":"- /home/aural/Code/bigmeanie/back/.docs/code/\n  - 01-core-language.md\n  - 02-design-patterns.md\n  - go-concurrency.md\n  - go-errors.md\n  - go-fundamentals.md\n  - go-packages.md\n  - go-patterns.md\n  - go-performance.md\n  - go-testing.md\n"}
{"parentUuid":"f9a9830d-4355-4bcb-92d1-b6ad2c1732a2","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01AmnNSwBWyQYjjEaNb9Ec1j","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Let me reorganize these files to remove redundancy and create clear differentiation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":203,"cache_read_input_tokens":88539,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS5MwfT9ddXqfvAsyM4q8","type":"assistant","uuid":"495eb233-f490-477b-b1fb-0bc686080d17","timestamp":"2025-08-13T08:04:31.407Z"}
{"parentUuid":"495eb233-f490-477b-b1fb-0bc686080d17","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01AmnNSwBWyQYjjEaNb9Ec1j","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01K69jXJpckopK7oUdBNmn7t","name":"Bash","input":{"command":"rm 01-core-language.md 02-design-patterns.md go-patterns.md","description":"Remove duplicate/numbered pattern files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":203,"cache_read_input_tokens":88539,"output_tokens":131,"service_tier":"standard"}},"requestId":"req_011CS5MwfT9ddXqfvAsyM4q8","type":"assistant","uuid":"8a2fc2d6-8d03-45a7-b2a2-db3f0ce02608","timestamp":"2025-08-13T08:04:32.676Z"}
{"parentUuid":"8a2fc2d6-8d03-45a7-b2a2-db3f0ce02608","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K69jXJpckopK7oUdBNmn7t","type":"tool_result","content":"","is_error":false}]},"uuid":"1104de07-22b8-42e7-9292-7e71f97db7f1","timestamp":"2025-08-13T08:27:11.838Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"1104de07-22b8-42e7-9292-7e71f97db7f1","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_0179qo7DK5HdG4fPHUp1exrV","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now let me create a properly organized design patterns file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":77328,"cache_read_input_tokens":11551,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CS5PgLqH2vXDhw1zRaE1m","type":"assistant","uuid":"9037a941-7e7a-4534-87d7-5f184f63273e","timestamp":"2025-08-13T08:27:18.046Z"}
{"parentUuid":"9037a941-7e7a-4534-87d7-5f184f63273e","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_0179qo7DK5HdG4fPHUp1exrV","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01Br5EVyPtBJMcY7chynPt3d","name":"Write","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/code/design-patterns.md","content":"# Design Patterns in Go\n\n## Overview\nThis document covers classic design patterns (Gang of Four) and architectural patterns as they apply to Go. For Go-specific idioms and conventions, see `practices-patterns.md`.\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Architectural Patterns](#architectural-patterns)\n5. [Domain-Driven Design Patterns](#domain-driven-design-patterns)\n\n## Creational Patterns\n\n### Singleton\nThe singleton pattern ensures only one instance of a type exists. In Go, use `sync.Once` for thread-safe initialization.\n\n```go\npackage database\n\nimport (\n    \"database/sql\"\n    \"sync\"\n)\n\ntype DB struct {\n    conn *sql.DB\n}\n\nvar (\n    instance *DB\n    once     sync.Once\n)\n\n// GetInstance returns the singleton database instance\nfunc GetInstance() *DB {\n    once.Do(func() {\n        conn, _ := sql.Open(\"postgres\", \"connection-string\")\n        instance = &DB{conn: conn}\n    })\n    return instance\n}\n\n// Alternative: Package-level initialization (simpler for most cases)\nvar defaultDB = initDB()\n\nfunc initDB() *DB {\n    conn, _ := sql.Open(\"postgres\", \"connection-string\")\n    return &DB{conn: conn}\n}\n```\n\n### Factory Method\nFactory method defines an interface for creating objects but lets subclasses decide which class to instantiate.\n\n```go\n// Product interface\ntype Transport interface {\n    Deliver() string\n    Cost() float64\n}\n\n// Concrete products\ntype Truck struct {\n    capacity int\n}\n\nfunc (t *Truck) Deliver() string {\n    return \"Delivering by land\"\n}\n\nfunc (t *Truck) Cost() float64 {\n    return 100.0\n}\n\ntype Ship struct {\n    tonnage int\n}\n\nfunc (s *Ship) Deliver() string {\n    return \"Delivering by sea\"\n}\n\nfunc (s *Ship) Cost() float64 {\n    return 500.0\n}\n\n// Factory\ntype LogisticsFactory interface {\n    CreateTransport() Transport\n}\n\ntype RoadLogistics struct{}\n\nfunc (r *RoadLogistics) CreateTransport() Transport {\n    return &Truck{capacity: 1000}\n}\n\ntype SeaLogistics struct{}\n\nfunc (s *SeaLogistics) CreateTransport() Transport {\n    return &Ship{tonnage: 10000}\n}\n\n// Usage\nfunc planDelivery(factory LogisticsFactory) {\n    transport := factory.CreateTransport()\n    fmt.Println(transport.Deliver())\n    fmt.Printf(\"Cost: $%.2f\\n\", transport.Cost())\n}\n```\n\n### Abstract Factory\nAbstract factory provides an interface for creating families of related objects.\n\n```go\n// Abstract products\ntype Button interface {\n    Paint()\n}\n\ntype Checkbox interface {\n    Check()\n}\n\n// Concrete products - Windows family\ntype WindowsButton struct{}\n\nfunc (w *WindowsButton) Paint() {\n    fmt.Println(\"Rendering Windows button\")\n}\n\ntype WindowsCheckbox struct{}\n\nfunc (w *WindowsCheckbox) Check() {\n    fmt.Println(\"Checking Windows checkbox\")\n}\n\n// Concrete products - Mac family\ntype MacButton struct{}\n\nfunc (m *MacButton) Paint() {\n    fmt.Println(\"Rendering Mac button\")\n}\n\ntype MacCheckbox struct{}\n\nfunc (m *MacCheckbox) Check() {\n    fmt.Println(\"Checking Mac checkbox\")\n}\n\n// Abstract factory\ntype GUIFactory interface {\n    CreateButton() Button\n    CreateCheckbox() Checkbox\n}\n\n// Concrete factories\ntype WindowsFactory struct{}\n\nfunc (w *WindowsFactory) CreateButton() Button {\n    return &WindowsButton{}\n}\n\nfunc (w *WindowsFactory) CreateCheckbox() Checkbox {\n    return &WindowsCheckbox{}\n}\n\ntype MacFactory struct{}\n\nfunc (m *MacFactory) CreateButton() Button {\n    return &MacButton{}\n}\n\nfunc (m *MacFactory) CreateCheckbox() Checkbox {\n    return &MacCheckbox{}\n}\n\n// Application\ntype Application struct {\n    factory GUIFactory\n    button  Button\n    checkbox Checkbox\n}\n\nfunc NewApplication(factory GUIFactory) *Application {\n    return &Application{\n        factory:  factory,\n        button:   factory.CreateButton(),\n        checkbox: factory.CreateCheckbox(),\n    }\n}\n\nfunc (a *Application) Paint() {\n    a.button.Paint()\n    a.checkbox.Check()\n}\n```\n\n### Builder\nBuilder pattern separates the construction of complex objects from their representation.\n\n```go\n// Product\ntype House struct {\n    Foundation string\n    Structure  string\n    Roof       string\n    Interior   string\n    Garden     bool\n    Pool       bool\n}\n\n// Builder interface\ntype HouseBuilder interface {\n    SetFoundation() HouseBuilder\n    SetStructure() HouseBuilder\n    SetRoof() HouseBuilder\n    SetInterior() HouseBuilder\n    SetGarden() HouseBuilder\n    SetPool() HouseBuilder\n    Build() *House\n}\n\n// Concrete builder\ntype ModernHouseBuilder struct {\n    house *House\n}\n\nfunc NewModernHouseBuilder() *ModernHouseBuilder {\n    return &ModernHouseBuilder{\n        house: &House{},\n    }\n}\n\nfunc (b *ModernHouseBuilder) SetFoundation() HouseBuilder {\n    b.house.Foundation = \"Concrete, brick, and stone\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetStructure() HouseBuilder {\n    b.house.Structure = \"Steel and glass\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetRoof() HouseBuilder {\n    b.house.Roof = \"Flat concrete\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetInterior() HouseBuilder {\n    b.house.Interior = \"Modern minimalist\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetGarden() HouseBuilder {\n    b.house.Garden = true\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetPool() HouseBuilder {\n    b.house.Pool = true\n    return b\n}\n\nfunc (b *ModernHouseBuilder) Build() *House {\n    return b.house\n}\n\n// Director (optional)\ntype ConstructionDirector struct {\n    builder HouseBuilder\n}\n\nfunc (d *ConstructionDirector) ConstructLuxuryHouse() *House {\n    return d.builder.\n        SetFoundation().\n        SetStructure().\n        SetRoof().\n        SetInterior().\n        SetGarden().\n        SetPool().\n        Build()\n}\n\n// Usage\nfunc main() {\n    builder := NewModernHouseBuilder()\n    \n    // Direct use\n    house := builder.\n        SetFoundation().\n        SetStructure().\n        SetRoof().\n        Build()\n    \n    // Using director\n    director := &ConstructionDirector{builder: builder}\n    luxuryHouse := director.ConstructLuxuryHouse()\n}\n```\n\n### Prototype\nPrototype pattern creates objects by cloning existing instances.\n\n```go\n// Prototype interface\ntype Prototype interface {\n    Clone() Prototype\n}\n\n// Concrete prototype\ntype Document struct {\n    Title    string\n    Content  string\n    Images   []string\n    Metadata map[string]string\n}\n\nfunc (d *Document) Clone() Prototype {\n    // Deep copy\n    newDoc := &Document{\n        Title:   d.Title,\n        Content: d.Content,\n        Images:  make([]string, len(d.Images)),\n        Metadata: make(map[string]string),\n    }\n    \n    copy(newDoc.Images, d.Images)\n    \n    for k, v := range d.Metadata {\n        newDoc.Metadata[k] = v\n    }\n    \n    return newDoc\n}\n\n// Prototype registry\ntype DocumentRegistry struct {\n    prototypes map[string]Prototype\n}\n\nfunc NewDocumentRegistry() *DocumentRegistry {\n    return &DocumentRegistry{\n        prototypes: make(map[string]Prototype),\n    }\n}\n\nfunc (r *DocumentRegistry) Register(name string, prototype Prototype) {\n    r.prototypes[name] = prototype\n}\n\nfunc (r *DocumentRegistry) Create(name string) Prototype {\n    if prototype, exists := r.prototypes[name]; exists {\n        return prototype.Clone()\n    }\n    return nil\n}\n\n// Usage\nfunc main() {\n    registry := NewDocumentRegistry()\n    \n    // Register prototypes\n    registry.Register(\"report\", &Document{\n        Title:    \"Monthly Report Template\",\n        Content:  \"...\",\n        Metadata: map[string]string{\"type\": \"report\"},\n    })\n    \n    registry.Register(\"letter\", &Document{\n        Title:    \"Business Letter Template\",\n        Content:  \"...\",\n        Metadata: map[string]string{\"type\": \"letter\"},\n    })\n    \n    // Create new documents from prototypes\n    report := registry.Create(\"report\").(*Document)\n    report.Title = \"January Report\"\n}\n```\n\n## Structural Patterns\n\n### Adapter\nAdapter allows incompatible interfaces to work together.\n\n```go\n// Target interface (what client expects)\ntype PaymentProcessor interface {\n    ProcessPayment(amount float64) error\n}\n\n// Adaptee (incompatible interface)\ntype LegacyPaymentSystem struct{}\n\nfunc (l *LegacyPaymentSystem) MakePayment(sum float64, currency string) string {\n    return fmt.Sprintf(\"Payment of %.2f %s processed\", sum, currency)\n}\n\n// Adapter\ntype PaymentAdapter struct {\n    legacy   *LegacyPaymentSystem\n    currency string\n}\n\nfunc NewPaymentAdapter(legacy *LegacyPaymentSystem, currency string) *PaymentAdapter {\n    return &PaymentAdapter{\n        legacy:   legacy,\n        currency: currency,\n    }\n}\n\nfunc (a *PaymentAdapter) ProcessPayment(amount float64) error {\n    result := a.legacy.MakePayment(amount, a.currency)\n    if result != \"\" {\n        return nil\n    }\n    return fmt.Errorf(\"payment failed\")\n}\n\n// Client code\nfunc processOrder(processor PaymentProcessor, amount float64) {\n    if err := processor.ProcessPayment(amount); err != nil {\n        fmt.Printf(\"Payment failed: %v\\n\", err)\n    } else {\n        fmt.Println(\"Payment successful\")\n    }\n}\n\n// Usage\nfunc main() {\n    legacy := &LegacyPaymentSystem{}\n    adapter := NewPaymentAdapter(legacy, \"USD\")\n    processOrder(adapter, 100.00)\n}\n```\n\n### Bridge\nBridge decouples abstraction from implementation so both can vary independently.\n\n```go\n// Implementation interface\ntype MessageSender interface {\n    Send(title, body string) error\n}\n\n// Concrete implementations\ntype EmailSender struct {\n    emailAddress string\n}\n\nfunc (e *EmailSender) Send(title, body string) error {\n    fmt.Printf(\"Email to %s: %s - %s\\n\", e.emailAddress, title, body)\n    return nil\n}\n\ntype SMSSender struct {\n    phoneNumber string\n}\n\nfunc (s *SMSSender) Send(title, body string) error {\n    fmt.Printf(\"SMS to %s: %s\\n\", s.phoneNumber, body)\n    return nil\n}\n\n// Abstraction\ntype Message struct {\n    sender MessageSender\n}\n\nfunc NewMessage(sender MessageSender) *Message {\n    return &Message{sender: sender}\n}\n\nfunc (m *Message) Send(title, body string) error {\n    return m.sender.Send(title, body)\n}\n\n// Refined abstraction\ntype UrgentMessage struct {\n    Message\n}\n\nfunc NewUrgentMessage(sender MessageSender) *UrgentMessage {\n    return &UrgentMessage{\n        Message: Message{sender: sender},\n    }\n}\n\nfunc (u *UrgentMessage) Send(title, body string) error {\n    title = \"URGENT: \" + title\n    return u.sender.Send(title, body)\n}\n\n// Usage\nfunc main() {\n    // Regular email\n    email := NewMessage(&EmailSender{emailAddress: \"user@example.com\"})\n    email.Send(\"Hello\", \"This is a test message\")\n    \n    // Urgent SMS\n    sms := NewUrgentMessage(&SMSSender{phoneNumber: \"+1234567890\"})\n    sms.Send(\"Alert\", \"Server is down\")\n}\n```\n\n### Composite\nComposite lets you compose objects into tree structures to represent part-whole hierarchies.\n\n```go\n// Component interface\ntype FileSystemNode interface {\n    GetName() string\n    GetSize() int64\n    Print(indent string)\n}\n\n// Leaf\ntype File struct {\n    name string\n    size int64\n}\n\nfunc (f *File) GetName() string {\n    return f.name\n}\n\nfunc (f *File) GetSize() int64 {\n    return f.size\n}\n\nfunc (f *File) Print(indent string) {\n    fmt.Printf(\"%sFile: %s (%d bytes)\\n\", indent, f.name, f.size)\n}\n\n// Composite\ntype Directory struct {\n    name     string\n    children []FileSystemNode\n}\n\nfunc (d *Directory) GetName() string {\n    return d.name\n}\n\nfunc (d *Directory) GetSize() int64 {\n    var total int64\n    for _, child := range d.children {\n        total += child.GetSize()\n    }\n    return total\n}\n\nfunc (d *Directory) Add(node FileSystemNode) {\n    d.children = append(d.children, node)\n}\n\nfunc (d *Directory) Remove(node FileSystemNode) {\n    for i, child := range d.children {\n        if child == node {\n            d.children = append(d.children[:i], d.children[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (d *Directory) Print(indent string) {\n    fmt.Printf(\"%sDirectory: %s (%d bytes)\\n\", indent, d.name, d.GetSize())\n    for _, child := range d.children {\n        child.Print(indent + \"  \")\n    }\n}\n\n// Usage\nfunc main() {\n    root := &Directory{name: \"root\"}\n    \n    home := &Directory{name: \"home\"}\n    root.Add(home)\n    \n    documents := &Directory{name: \"documents\"}\n    home.Add(documents)\n    \n    documents.Add(&File{name: \"report.pdf\", size: 1024000})\n    documents.Add(&File{name: \"presentation.pptx\", size: 2048000})\n    \n    home.Add(&File{name: \"notes.txt\", size: 1024})\n    \n    root.Print(\"\")\n}\n```\n\n### Decorator\nDecorator adds new functionality to objects without altering their structure.\n\n```go\n// Component interface\ntype Coffee interface {\n    GetCost() float64\n    GetDescription() string\n}\n\n// Concrete component\ntype SimpleCoffee struct{}\n\nfunc (c *SimpleCoffee) GetCost() float64 {\n    return 2.0\n}\n\nfunc (c *SimpleCoffee) GetDescription() string {\n    return \"Simple coffee\"\n}\n\n// Base decorator\ntype CoffeeDecorator struct {\n    coffee Coffee\n}\n\nfunc (d *CoffeeDecorator) GetCost() float64 {\n    return d.coffee.GetCost()\n}\n\nfunc (d *CoffeeDecorator) GetDescription() string {\n    return d.coffee.GetDescription()\n}\n\n// Concrete decorators\ntype MilkDecorator struct {\n    CoffeeDecorator\n}\n\nfunc NewMilkDecorator(coffee Coffee) *MilkDecorator {\n    return &MilkDecorator{\n        CoffeeDecorator: CoffeeDecorator{coffee: coffee},\n    }\n}\n\nfunc (m *MilkDecorator) GetCost() float64 {\n    return m.coffee.GetCost() + 0.5\n}\n\nfunc (m *MilkDecorator) GetDescription() string {\n    return m.coffee.GetDescription() + \", milk\"\n}\n\ntype SugarDecorator struct {\n    CoffeeDecorator\n}\n\nfunc NewSugarDecorator(coffee Coffee) *SugarDecorator {\n    return &SugarDecorator{\n        CoffeeDecorator: CoffeeDecorator{coffee: coffee},\n    }\n}\n\nfunc (s *SugarDecorator) GetCost() float64 {\n    return s.coffee.GetCost() + 0.2\n}\n\nfunc (s *SugarDecorator) GetDescription() string {\n    return s.coffee.GetDescription() + \", sugar\"\n}\n\n// Usage\nfunc main() {\n    coffee := &SimpleCoffee{}\n    fmt.Printf(\"%s: $%.2f\\n\", coffee.GetDescription(), coffee.GetCost())\n    \n    coffeeWithMilk := NewMilkDecorator(coffee)\n    fmt.Printf(\"%s: $%.2f\\n\", coffeeWithMilk.GetDescription(), coffeeWithMilk.GetCost())\n    \n    coffeeWithMilkAndSugar := NewSugarDecorator(coffeeWithMilk)\n    fmt.Printf(\"%s: $%.2f\\n\", coffeeWithMilkAndSugar.GetDescription(), coffeeWithMilkAndSugar.GetCost())\n}\n```\n\n### Facade\nFacade provides a simplified interface to a complex subsystem.\n\n```go\n// Complex subsystem components\ntype AccountService struct{}\n\nfunc (a *AccountService) GetAccount(id string) string {\n    return fmt.Sprintf(\"Account %s\", id)\n}\n\nfunc (a *AccountService) CheckBalance(id string) float64 {\n    return 1000.00\n}\n\ntype SecurityService struct{}\n\nfunc (s *SecurityService) Authenticate(token string) bool {\n    return token == \"valid-token\"\n}\n\nfunc (s *SecurityService) Authorize(user, action string) bool {\n    return true\n}\n\ntype TransactionService struct{}\n\nfunc (t *TransactionService) CreateTransaction(from, to string, amount float64) string {\n    return fmt.Sprintf(\"Transaction: %s -> %s: %.2f\", from, to, amount)\n}\n\nfunc (t *TransactionService) ValidateTransaction(id string) bool {\n    return true\n}\n\ntype NotificationService struct{}\n\nfunc (n *NotificationService) SendEmail(to, message string) {\n    fmt.Printf(\"Email to %s: %s\\n\", to, message)\n}\n\nfunc (n *NotificationService) SendSMS(to, message string) {\n    fmt.Printf(\"SMS to %s: %s\\n\", to, message)\n}\n\n// Facade\ntype BankingFacade struct {\n    account      *AccountService\n    security     *SecurityService\n    transaction  *TransactionService\n    notification *NotificationService\n}\n\nfunc NewBankingFacade() *BankingFacade {\n    return &BankingFacade{\n        account:      &AccountService{},\n        security:     &SecurityService{},\n        transaction:  &TransactionService{},\n        notification: &NotificationService{},\n    }\n}\n\nfunc (b *BankingFacade) Transfer(token, from, to string, amount float64) error {\n    // Authenticate\n    if !b.security.Authenticate(token) {\n        return fmt.Errorf(\"authentication failed\")\n    }\n    \n    // Check authorization\n    if !b.security.Authorize(from, \"transfer\") {\n        return fmt.Errorf(\"not authorized\")\n    }\n    \n    // Check balance\n    if b.account.CheckBalance(from) < amount {\n        return fmt.Errorf(\"insufficient funds\")\n    }\n    \n    // Create transaction\n    txID := b.transaction.CreateTransaction(from, to, amount)\n    \n    // Validate\n    if !b.transaction.ValidateTransaction(txID) {\n        return fmt.Errorf(\"transaction validation failed\")\n    }\n    \n    // Notify\n    b.notification.SendEmail(from, fmt.Sprintf(\"Transfer of %.2f completed\", amount))\n    b.notification.SendSMS(to, fmt.Sprintf(\"Received %.2f\", amount))\n    \n    return nil\n}\n\n// Usage\nfunc main() {\n    banking := NewBankingFacade()\n    \n    err := banking.Transfer(\"valid-token\", \"account1\", \"account2\", 100.00)\n    if err != nil {\n        fmt.Printf(\"Transfer failed: %v\\n\", err)\n    } else {\n        fmt.Println(\"Transfer successful\")\n    }\n}\n```\n\n### Flyweight\nFlyweight minimizes memory usage by sharing efficiently large numbers of fine-grained objects.\n\n```go\n// Flyweight interface\ntype Character interface {\n    Display(font string, size int, color string)\n}\n\n// Concrete flyweight\ntype ConcreteCharacter struct {\n    symbol rune // Intrinsic state (shared)\n}\n\nfunc (c *ConcreteCharacter) Display(font string, size int, color string) {\n    // Extrinsic state (passed in)\n    fmt.Printf(\"Character: %c, Font: %s, Size: %d, Color: %s\\n\", \n        c.symbol, font, size, color)\n}\n\n// Flyweight factory\ntype CharacterFactory struct {\n    characters map[rune]*ConcreteCharacter\n}\n\nfunc NewCharacterFactory() *CharacterFactory {\n    return &CharacterFactory{\n        characters: make(map[rune]*ConcreteCharacter),\n    }\n}\n\nfunc (f *CharacterFactory) GetCharacter(symbol rune) Character {\n    if char, exists := f.characters[symbol]; exists {\n        return char\n    }\n    \n    char := &ConcreteCharacter{symbol: symbol}\n    f.characters[symbol] = char\n    return char\n}\n\n// Context that uses flyweights\ntype TextDocument struct {\n    characters []Character\n    fonts      []string\n    sizes      []int\n    colors     []string\n}\n\nfunc (d *TextDocument) AddCharacter(char Character, font string, size int, color string) {\n    d.characters = append(d.characters, char)\n    d.fonts = append(d.fonts, font)\n    d.sizes = append(d.sizes, size)\n    d.colors = append(d.colors, color)\n}\n\nfunc (d *TextDocument) Display() {\n    for i, char := range d.characters {\n        char.Display(d.fonts[i], d.sizes[i], d.colors[i])\n    }\n}\n\n// Usage\nfunc main() {\n    factory := NewCharacterFactory()\n    doc := &TextDocument{}\n    \n    text := \"Hello World\"\n    for _, r := range text {\n        char := factory.GetCharacter(r)\n        doc.AddCharacter(char, \"Arial\", 12, \"black\")\n    }\n    \n    doc.Display()\n    \n    // Characters 'l' and 'o' are reused (shared instances)\n    fmt.Printf(\"Total unique characters created: %d\\n\", len(factory.characters))\n}\n```\n\n### Proxy\nProxy provides a placeholder or surrogate for another object to control access to it.\n\n```go\n// Subject interface\ntype Database interface {\n    Query(sql string) ([]string, error)\n}\n\n// Real subject\ntype RealDatabase struct {\n    connectionString string\n}\n\nfunc (d *RealDatabase) Query(sql string) ([]string, error) {\n    fmt.Printf(\"Executing query: %s\\n\", sql)\n    // Simulate database query\n    return []string{\"result1\", \"result2\"}, nil\n}\n\n// Proxy with caching\ntype CachingDatabaseProxy struct {\n    database *RealDatabase\n    cache    map[string][]string\n}\n\nfunc NewCachingDatabaseProxy(connString string) *CachingDatabaseProxy {\n    return &CachingDatabaseProxy{\n        database: &RealDatabase{connectionString: connString},\n        cache:    make(map[string][]string),\n    }\n}\n\nfunc (p *CachingDatabaseProxy) Query(sql string) ([]string, error) {\n    // Check cache\n    if results, exists := p.cache[sql]; exists {\n        fmt.Printf(\"Returning cached results for: %s\\n\", sql)\n        return results, nil\n    }\n    \n    // Query real database\n    results, err := p.database.Query(sql)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Cache results\n    p.cache[sql] = results\n    return results, nil\n}\n\n// Security proxy\ntype SecureDatabaseProxy struct {\n    database Database\n    userRole string\n}\n\nfunc NewSecureDatabaseProxy(db Database, role string) *SecureDatabaseProxy {\n    return &SecureDatabaseProxy{\n        database: db,\n        userRole: role,\n    }\n}\n\nfunc (p *SecureDatabaseProxy) Query(sql string) ([]string, error) {\n    // Check permissions\n    if strings.Contains(strings.ToLower(sql), \"delete\") && p.userRole != \"admin\" {\n        return nil, fmt.Errorf(\"permission denied: only admin can delete\")\n    }\n    \n    return p.database.Query(sql)\n}\n\n// Usage\nfunc main() {\n    // Caching proxy\n    db := NewCachingDatabaseProxy(\"connection-string\")\n    \n    // First query hits the database\n    results, _ := db.Query(\"SELECT * FROM users\")\n    fmt.Println(\"Results:\", results)\n    \n    // Second identical query uses cache\n    results, _ = db.Query(\"SELECT * FROM users\")\n    fmt.Println(\"Results:\", results)\n    \n    // Security proxy\n    secureDB := NewSecureDatabaseProxy(db, \"user\")\n    _, err := secureDB.Query(\"DELETE FROM users\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n```\n\n## Behavioral Patterns\n\n### Chain of Responsibility\nChain of Responsibility passes requests along a chain of handlers until one handles it.\n\n```go\n// Handler interface\ntype Handler interface {\n    SetNext(Handler) Handler\n    Handle(request string) string\n}\n\n// Base handler\ntype BaseHandler struct {\n    next Handler\n}\n\nfunc (h *BaseHandler) SetNext(next Handler) Handler {\n    h.next = next\n    return next\n}\n\nfunc (h *BaseHandler) Handle(request string) string {\n    if h.next != nil {\n        return h.next.Handle(request)\n    }\n    return \"\"\n}\n\n// Concrete handlers\ntype AuthenticationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthenticationHandler) Handle(request string) string {\n    if request == \"auth\" {\n        return \"Authentication successful\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\ntype AuthorizationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthorizationHandler) Handle(request string) string {\n    if request == \"authz\" {\n        return \"Authorization granted\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\ntype ValidationHandler struct {\n    BaseHandler\n}\n\nfunc (h *ValidationHandler) Handle(request string) string {\n    if request == \"validate\" {\n        return \"Validation passed\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\n// Usage\nfunc main() {\n    auth := &AuthenticationHandler{}\n    authz := &AuthorizationHandler{}\n    valid := &ValidationHandler{}\n    \n    // Build chain\n    auth.SetNext(authz).SetNext(valid)\n    \n    // Process requests\n    fmt.Println(auth.Handle(\"auth\"))     // Handled by auth\n    fmt.Println(auth.Handle(\"authz\"))    // Handled by authz\n    fmt.Println(auth.Handle(\"validate\")) // Handled by valid\n    fmt.Println(auth.Handle(\"unknown\"))  // Not handled\n}\n```\n\n### Command\nCommand encapsulates a request as an object, letting you parameterize clients with different requests.\n\n```go\n// Command interface\ntype Command interface {\n    Execute() error\n    Undo() error\n}\n\n// Receiver\ntype Light struct {\n    isOn bool\n}\n\nfunc (l *Light) TurnOn() {\n    l.isOn = true\n    fmt.Println(\"Light is on\")\n}\n\nfunc (l *Light) TurnOff() {\n    l.isOn = false\n    fmt.Println(\"Light is off\")\n}\n\n// Concrete commands\ntype TurnOnCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOnCommand) Execute() error {\n    c.light.TurnOn()\n    return nil\n}\n\nfunc (c *TurnOnCommand) Undo() error {\n    c.light.TurnOff()\n    return nil\n}\n\ntype TurnOffCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOffCommand) Execute() error {\n    c.light.TurnOff()\n    return nil\n}\n\nfunc (c *TurnOffCommand) Undo() error {\n    c.light.TurnOn()\n    return nil\n}\n\n// Invoker\ntype RemoteControl struct {\n    commands []Command\n    history  []Command\n}\n\nfunc (r *RemoteControl) SetCommand(slot int, cmd Command) {\n    if slot >= len(r.commands) {\n        r.commands = append(r.commands, make([]Command, slot-len(r.commands)+1)...)\n    }\n    r.commands[slot] = cmd\n}\n\nfunc (r *RemoteControl) PressButton(slot int) {\n    if slot < len(r.commands) && r.commands[slot] != nil {\n        r.commands[slot].Execute()\n        r.history = append(r.history, r.commands[slot])\n    }\n}\n\nfunc (r *RemoteControl) PressUndo() {\n    if len(r.history) > 0 {\n        lastCommand := r.history[len(r.history)-1]\n        lastCommand.Undo()\n        r.history = r.history[:len(r.history)-1]\n    }\n}\n\n// Macro command\ntype MacroCommand struct {\n    commands []Command\n}\n\nfunc (m *MacroCommand) Execute() error {\n    for _, cmd := range m.commands {\n        if err := cmd.Execute(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc (m *MacroCommand) Undo() error {\n    // Undo in reverse order\n    for i := len(m.commands) - 1; i >= 0; i-- {\n        if err := m.commands[i].Undo(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\n// Usage\nfunc main() {\n    light := &Light{}\n    remote := &RemoteControl{}\n    \n    turnOn := &TurnOnCommand{light: light}\n    turnOff := &TurnOffCommand{light: light}\n    \n    remote.SetCommand(0, turnOn)\n    remote.SetCommand(1, turnOff)\n    \n    remote.PressButton(0) // Turn on\n    remote.PressButton(1) // Turn off\n    remote.PressUndo()    // Turn on again\n}\n```\n\n### Iterator\nIterator provides a way to access elements of a collection sequentially without exposing its underlying representation.\n\n```go\n// Iterator interface\ntype Iterator[T any] interface {\n    HasNext() bool\n    Next() T\n}\n\n// Collection interface\ntype Collection[T any] interface {\n    CreateIterator() Iterator[T]\n}\n\n// Concrete collection\ntype BookCollection struct {\n    books []string\n}\n\nfunc (c *BookCollection) Add(book string) {\n    c.books = append(c.books, book)\n}\n\nfunc (c *BookCollection) CreateIterator() Iterator[string] {\n    return &BookIterator{\n        collection: c,\n        index:      0,\n    }\n}\n\n// Concrete iterator\ntype BookIterator struct {\n    collection *BookCollection\n    index      int\n}\n\nfunc (i *BookIterator) HasNext() bool {\n    return i.index < len(i.collection.books)\n}\n\nfunc (i *BookIterator) Next() string {\n    if i.HasNext() {\n        book := i.collection.books[i.index]\n        i.index++\n        return book\n    }\n    return \"\"\n}\n\n// Usage with channels (Go idiomatic)\ntype ChannelIterator[T any] struct {\n    ch <-chan T\n    current T\n    hasNext bool\n}\n\nfunc NewChannelIterator[T any](items []T) *ChannelIterator[T] {\n    ch := make(chan T)\n    go func() {\n        for _, item := range items {\n            ch <- item\n        }\n        close(ch)\n    }()\n    \n    iter := &ChannelIterator[T]{ch: ch}\n    iter.advance()\n    return iter\n}\n\nfunc (i *ChannelIterator[T]) advance() {\n    i.current, i.hasNext = <-i.ch\n}\n\nfunc (i *ChannelIterator[T]) HasNext() bool {\n    return i.hasNext\n}\n\nfunc (i *ChannelIterator[T]) Next() T {\n    current := i.current\n    i.advance()\n    return current\n}\n\n// Usage\nfunc main() {\n    // Traditional iterator\n    collection := &BookCollection{}\n    collection.Add(\"Design Patterns\")\n    collection.Add(\"Clean Code\")\n    collection.Add(\"The Pragmatic Programmer\")\n    \n    iterator := collection.CreateIterator()\n    for iterator.HasNext() {\n        fmt.Println(iterator.Next())\n    }\n    \n    // Channel-based iterator\n    numbers := []int{1, 2, 3, 4, 5}\n    numIter := NewChannelIterator(numbers)\n    for numIter.HasNext() {\n        fmt.Println(numIter.Next())\n    }\n}\n```\n\n### Mediator\nMediator defines how a set of objects interact, promoting loose coupling.\n\n```go\n// Mediator interface\ntype ChatRoomMediator interface {\n    SendMessage(msg string, user User)\n    AddUser(user User)\n}\n\n// Colleague interface\ntype User interface {\n    Send(msg string)\n    Receive(msg string)\n    SetMediator(mediator ChatRoomMediator)\n}\n\n// Concrete mediator\ntype ChatRoom struct {\n    users []User\n}\n\nfunc (c *ChatRoom) SendMessage(msg string, sender User) {\n    for _, user := range c.users {\n        // Don't send message back to sender\n        if user != sender {\n            user.Receive(msg)\n        }\n    }\n}\n\nfunc (c *ChatRoom) AddUser(user User) {\n    c.users = append(c.users, user)\n    user.SetMediator(c)\n}\n\n// Concrete colleague\ntype ChatUser struct {\n    name     string\n    mediator ChatRoomMediator\n}\n\nfunc NewChatUser(name string) *ChatUser {\n    return &ChatUser{name: name}\n}\n\nfunc (u *ChatUser) Send(msg string) {\n    fmt.Printf(\"%s sends: %s\\n\", u.name, msg)\n    if u.mediator != nil {\n        u.mediator.SendMessage(msg, u)\n    }\n}\n\nfunc (u *ChatUser) Receive(msg string) {\n    fmt.Printf(\"%s receives: %s\\n\", u.name, msg)\n}\n\nfunc (u *ChatUser) SetMediator(mediator ChatRoomMediator) {\n    u.mediator = mediator\n}\n\n// Usage\nfunc main() {\n    chatRoom := &ChatRoom{}\n    \n    alice := NewChatUser(\"Alice\")\n    bob := NewChatUser(\"Bob\")\n    charlie := NewChatUser(\"Charlie\")\n    \n    chatRoom.AddUser(alice)\n    chatRoom.AddUser(bob)\n    chatRoom.AddUser(charlie)\n    \n    alice.Send(\"Hello everyone!\")\n    bob.Send(\"Hey Alice!\")\n}\n```\n\n### Memento\nMemento captures and externalizes an object's internal state for later restoration.\n\n```go\n// Memento\ntype EditorMemento struct {\n    content string\n    cursor  int\n}\n\n// Originator\ntype TextEditor struct {\n    content string\n    cursor  int\n}\n\nfunc (e *TextEditor) Type(text string) {\n    e.content = e.content[:e.cursor] + text + e.content[e.cursor:]\n    e.cursor += len(text)\n}\n\nfunc (e *TextEditor) Delete(length int) {\n    if e.cursor >= length {\n        e.content = e.content[:e.cursor-length] + e.content[e.cursor:]\n        e.cursor -= length\n    }\n}\n\nfunc (e *TextEditor) Save() *EditorMemento {\n    return &EditorMemento{\n        content: e.content,\n        cursor:  e.cursor,\n    }\n}\n\nfunc (e *TextEditor) Restore(memento *EditorMemento) {\n    e.content = memento.content\n    e.cursor = memento.cursor\n}\n\nfunc (e *TextEditor) String() string {\n    return fmt.Sprintf(\"Content: %s (cursor at %d)\", e.content, e.cursor)\n}\n\n// Caretaker\ntype History struct {\n    mementos []*EditorMemento\n    current  int\n}\n\nfunc (h *History) Push(memento *EditorMemento) {\n    // Remove any states after current position\n    h.mementos = h.mementos[:h.current+1]\n    h.mementos = append(h.mementos, memento)\n    h.current++\n}\n\nfunc (h *History) Undo() *EditorMemento {\n    if h.current > 0 {\n        h.current--\n        return h.mementos[h.current]\n    }\n    return nil\n}\n\nfunc (h *History) Redo() *EditorMemento {\n    if h.current < len(h.mementos)-1 {\n        h.current++\n        return h.mementos[h.current]\n    }\n    return nil\n}\n\n// Usage\nfunc main() {\n    editor := &TextEditor{}\n    history := &History{}\n    \n    // Initial state\n    history.Push(editor.Save())\n    \n    editor.Type(\"Hello \")\n    history.Push(editor.Save())\n    \n    editor.Type(\"World\")\n    history.Push(editor.Save())\n    \n    editor.Type(\"!\")\n    history.Push(editor.Save())\n    \n    fmt.Println(editor)\n    \n    // Undo\n    if memento := history.Undo(); memento != nil {\n        editor.Restore(memento)\n        fmt.Println(\"After undo:\", editor)\n    }\n    \n    // Undo again\n    if memento := history.Undo(); memento != nil {\n        editor.Restore(memento)\n        fmt.Println(\"After undo:\", editor)\n    }\n    \n    // Redo\n    if memento := history.Redo(); memento != nil {\n        editor.Restore(memento)\n        fmt.Println(\"After redo:\", editor)\n    }\n}\n```\n\n### Observer\nObserver defines a one-to-many dependency between objects where state changes are automatically notified.\n\n```go\n// Observer interface\ntype Observer interface {\n    Update(event string, data interface{})\n}\n\n// Subject interface\ntype Subject interface {\n    Attach(observer Observer)\n    Detach(observer Observer)\n    Notify(event string, data interface{})\n}\n\n// Concrete subject\ntype StockPrice struct {\n    observers map[Observer]bool\n    symbol    string\n    price     float64\n}\n\nfunc NewStockPrice(symbol string) *StockPrice {\n    return &StockPrice{\n        observers: make(map[Observer]bool),\n        symbol:    symbol,\n    }\n}\n\nfunc (s *StockPrice) Attach(observer Observer) {\n    s.observers[observer] = true\n}\n\nfunc (s *StockPrice) Detach(observer Observer) {\n    delete(s.observers, observer)\n}\n\nfunc (s *StockPrice) Notify(event string, data interface{}) {\n    for observer := range s.observers {\n        observer.Update(event, data)\n    }\n}\n\nfunc (s *StockPrice) SetPrice(price float64) {\n    oldPrice := s.price\n    s.price = price\n    \n    change := ((price - oldPrice) / oldPrice) * 100\n    s.Notify(\"price_changed\", map[string]interface{}{\n        \"symbol\":    s.symbol,\n        \"old_price\": oldPrice,\n        \"new_price\": price,\n        \"change\":    change,\n    })\n}\n\n// Concrete observers\ntype InvestorAlert struct {\n    name string\n}\n\nfunc (i *InvestorAlert) Update(event string, data interface{}) {\n    if event == \"price_changed\" {\n        priceData := data.(map[string]interface{})\n        fmt.Printf(\"[%s] Price alert: %s changed from %.2f to %.2f (%.2f%%)\\n\",\n            i.name,\n            priceData[\"symbol\"],\n            priceData[\"old_price\"],\n            priceData[\"new_price\"],\n            priceData[\"change\"])\n    }\n}\n\ntype TradingBot struct {\n    threshold float64\n}\n\nfunc (t *TradingBot) Update(event string, data interface{}) {\n    if event == \"price_changed\" {\n        priceData := data.(map[string]interface{})\n        change := priceData[\"change\"].(float64)\n        \n        if change > t.threshold {\n            fmt.Printf(\"[Bot] BUY signal: price increased by %.2f%%\\n\", change)\n        } else if change < -t.threshold {\n            fmt.Printf(\"[Bot] SELL signal: price decreased by %.2f%%\\n\", change)\n        }\n    }\n}\n\n// Usage\nfunc main() {\n    stock := NewStockPrice(\"AAPL\")\n    \n    investor := &InvestorAlert{name: \"John\"}\n    bot := &TradingBot{threshold: 5.0}\n    \n    stock.Attach(investor)\n    stock.Attach(bot)\n    \n    stock.SetPrice(100.00)\n    stock.SetPrice(105.50)\n    stock.SetPrice(98.00)\n}\n```\n\n### State\nState allows an object to alter its behavior when its internal state changes.\n\n```go\n// State interface\ntype State interface {\n    InsertCoin(m *VendingMachine)\n    SelectProduct(m *VendingMachine)\n    Dispense(m *VendingMachine)\n    Cancel(m *VendingMachine)\n}\n\n// Context\ntype VendingMachine struct {\n    state    State\n    coins    int\n    products int\n}\n\nfunc NewVendingMachine(products int) *VendingMachine {\n    vm := &VendingMachine{\n        products: products,\n    }\n    vm.state = &IdleState{}\n    return vm\n}\n\nfunc (m *VendingMachine) SetState(state State) {\n    m.state = state\n    fmt.Printf(\"State changed to: %T\\n\", state)\n}\n\nfunc (m *VendingMachine) InsertCoin() {\n    m.state.InsertCoin(m)\n}\n\nfunc (m *VendingMachine) SelectProduct() {\n    m.state.SelectProduct(m)\n}\n\nfunc (m *VendingMachine) Dispense() {\n    m.state.Dispense(m)\n}\n\nfunc (m *VendingMachine) Cancel() {\n    m.state.Cancel(m)\n}\n\n// Concrete states\ntype IdleState struct{}\n\nfunc (s *IdleState) InsertCoin(m *VendingMachine) {\n    fmt.Println(\"Coin inserted\")\n    m.coins++\n    m.SetState(&HasCoinState{})\n}\n\nfunc (s *IdleState) SelectProduct(m *VendingMachine) {\n    fmt.Println(\"Please insert coin first\")\n}\n\nfunc (s *IdleState) Dispense(m *VendingMachine) {\n    fmt.Println(\"Please insert coin and select product\")\n}\n\nfunc (s *IdleState) Cancel(m *VendingMachine) {\n    fmt.Println(\"Nothing to cancel\")\n}\n\ntype HasCoinState struct{}\n\nfunc (s *HasCoinState) InsertCoin(m *VendingMachine) {\n    fmt.Println(\"Coin already inserted\")\n}\n\nfunc (s *HasCoinState) SelectProduct(m *VendingMachine) {\n    if m.products > 0 {\n        fmt.Println(\"Product selected\")\n        m.SetState(&DispensingState{})\n        m.Dispense()\n    } else {\n        fmt.Println(\"Out of products\")\n        m.Cancel()\n    }\n}\n\nfunc (s *HasCoinState) Dispense(m *VendingMachine) {\n    fmt.Println(\"Please select product first\")\n}\n\nfunc (s *HasCoinState) Cancel(m *VendingMachine) {\n    fmt.Println(\"Returning coin\")\n    m.coins--\n    m.SetState(&IdleState{})\n}\n\ntype DispensingState struct{}\n\nfunc (s *DispensingState) InsertCoin(m *VendingMachine) {\n    fmt.Println(\"Please wait, dispensing product\")\n}\n\nfunc (s *DispensingState) SelectProduct(m *VendingMachine) {\n    fmt.Println(\"Please wait, dispensing product\")\n}\n\nfunc (s *DispensingState) Dispense(m *VendingMachine) {\n    fmt.Println(\"Dispensing product\")\n    m.products--\n    m.coins--\n    m.SetState(&IdleState{})\n}\n\nfunc (s *DispensingState) Cancel(m *VendingMachine) {\n    fmt.Println(\"Cannot cancel, already dispensing\")\n}\n\n// Usage\nfunc main() {\n    machine := NewVendingMachine(2)\n    \n    machine.SelectProduct() // Error: need coin\n    machine.InsertCoin()\n    machine.SelectProduct() // OK, dispenses\n    \n    machine.InsertCoin()\n    machine.Cancel() // Returns coin\n}\n```\n\n### Strategy\nStrategy defines a family of algorithms and makes them interchangeable.\n\n```go\n// Strategy interface\ntype PaymentStrategy interface {\n    Pay(amount float64) error\n    GetName() string\n}\n\n// Concrete strategies\ntype CreditCardStrategy struct {\n    number string\n    cvv    string\n}\n\nfunc (c *CreditCardStrategy) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with credit card %s\\n\", amount, c.number)\n    // Payment logic\n    return nil\n}\n\nfunc (c *CreditCardStrategy) GetName() string {\n    return \"Credit Card\"\n}\n\ntype PayPalStrategy struct {\n    email string\n}\n\nfunc (p *PayPalStrategy) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with PayPal account %s\\n\", amount, p.email)\n    // Payment logic\n    return nil\n}\n\nfunc (p *PayPalStrategy) GetName() string {\n    return \"PayPal\"\n}\n\ntype CryptoStrategy struct {\n    walletAddress string\n}\n\nfunc (c *CryptoStrategy) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with crypto wallet %s\\n\", amount, c.walletAddress)\n    // Payment logic\n    return nil\n}\n\nfunc (c *CryptoStrategy) GetName() string {\n    return \"Cryptocurrency\"\n}\n\n// Context\ntype ShoppingCart struct {\n    items    []string\n    total    float64\n    strategy PaymentStrategy\n}\n\nfunc (s *ShoppingCart) AddItem(item string, price float64) {\n    s.items = append(s.items, item)\n    s.total += price\n}\n\nfunc (s *ShoppingCart) SetPaymentStrategy(strategy PaymentStrategy) {\n    s.strategy = strategy\n    fmt.Printf(\"Payment method set to: %s\\n\", strategy.GetName())\n}\n\nfunc (s *ShoppingCart) Checkout() error {\n    if s.strategy == nil {\n        return fmt.Errorf(\"no payment method selected\")\n    }\n    \n    fmt.Printf(\"Total: $%.2f\\n\", s.total)\n    return s.strategy.Pay(s.total)\n}\n\n// Usage\nfunc main() {\n    cart := &ShoppingCart{}\n    cart.AddItem(\"Laptop\", 999.99)\n    cart.AddItem(\"Mouse\", 29.99)\n    \n    // Pay with credit card\n    cart.SetPaymentStrategy(&CreditCardStrategy{\n        number: \"1234-5678-9012-3456\",\n        cvv:    \"123\",\n    })\n    cart.Checkout()\n    \n    // Change to PayPal\n    cart.SetPaymentStrategy(&PayPalStrategy{\n        email: \"user@example.com\",\n    })\n    cart.Checkout()\n}\n```\n\n### Template Method\nTemplate Method defines the skeleton of an algorithm in a base class, letting subclasses override specific steps.\n\n```go\n// Abstract class (using struct embedding in Go)\ntype DataProcessor struct {\n    // Define the interface that subclasses must implement\n    processor DataProcessorInterface\n}\n\ntype DataProcessorInterface interface {\n    Extract() ([]byte, error)\n    Transform(data []byte) ([]byte, error)\n    Load(data []byte) error\n}\n\n// Template method\nfunc (d *DataProcessor) Process() error {\n    // Extract\n    data, err := d.processor.Extract()\n    if err != nil {\n        return fmt.Errorf(\"extraction failed: %w\", err)\n    }\n    \n    // Transform\n    transformed, err := d.processor.Transform(data)\n    if err != nil {\n        return fmt.Errorf(\"transformation failed: %w\", err)\n    }\n    \n    // Load\n    if err := d.processor.Load(transformed); err != nil {\n        return fmt.Errorf(\"loading failed: %w\", err)\n    }\n    \n    return nil\n}\n\n// Concrete implementation - CSV Processor\ntype CSVProcessor struct {\n    DataProcessor\n    filename string\n}\n\nfunc NewCSVProcessor(filename string) *CSVProcessor {\n    p := &CSVProcessor{filename: filename}\n    p.DataProcessor.processor = p\n    return p\n}\n\nfunc (c *CSVProcessor) Extract() ([]byte, error) {\n    fmt.Printf(\"Extracting data from CSV file: %s\\n\", c.filename)\n    // Read CSV file\n    return []byte(\"csv,data,here\"), nil\n}\n\nfunc (c *CSVProcessor) Transform(data []byte) ([]byte, error) {\n    fmt.Println(\"Transforming CSV data\")\n    // Transform CSV data\n    return []byte(\"transformed csv data\"), nil\n}\n\nfunc (c *CSVProcessor) Load(data []byte) error {\n    fmt.Println(\"Loading CSV data to database\")\n    // Load to database\n    return nil\n}\n\n// Concrete implementation - JSON Processor\ntype JSONProcessor struct {\n    DataProcessor\n    url string\n}\n\nfunc NewJSONProcessor(url string) *JSONProcessor {\n    p := &JSONProcessor{url: url}\n    p.DataProcessor.processor = p\n    return p\n}\n\nfunc (j *JSONProcessor) Extract() ([]byte, error) {\n    fmt.Printf(\"Fetching JSON from API: %s\\n\", j.url)\n    // Fetch from API\n    return []byte(`{\"data\": \"value\"}`), nil\n}\n\nfunc (j *JSONProcessor) Transform(data []byte) ([]byte, error) {\n    fmt.Println(\"Transforming JSON data\")\n    // Transform JSON\n    return []byte(\"transformed json\"), nil\n}\n\nfunc (j *JSONProcessor) Load(data []byte) error {\n    fmt.Println(\"Loading JSON data to cache\")\n    // Load to cache\n    return nil\n}\n\n// Usage\nfunc main() {\n    csvProcessor := NewCSVProcessor(\"data.csv\")\n    if err := csvProcessor.Process(); err != nil {\n        fmt.Printf(\"CSV processing failed: %v\\n\", err)\n    }\n    \n    fmt.Println()\n    \n    jsonProcessor := NewJSONProcessor(\"https://api.example.com/data\")\n    if err := jsonProcessor.Process(); err != nil {\n        fmt.Printf(\"JSON processing failed: %v\\n\", err)\n    }\n}\n```\n\n### Visitor\nVisitor lets you define new operations without changing the classes of elements on which it operates.\n\n```go\n// Element interface\ntype Shape interface {\n    Accept(visitor Visitor)\n}\n\n// Visitor interface\ntype Visitor interface {\n    VisitCircle(c *Circle)\n    VisitRectangle(r *Rectangle)\n    VisitTriangle(t *Triangle)\n}\n\n// Concrete elements\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c *Circle) Accept(visitor Visitor) {\n    visitor.VisitCircle(c)\n}\n\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r *Rectangle) Accept(visitor Visitor) {\n    visitor.VisitRectangle(r)\n}\n\ntype Triangle struct {\n    Base, Height float64\n}\n\nfunc (t *Triangle) Accept(visitor Visitor) {\n    visitor.VisitTriangle(t)\n}\n\n// Concrete visitors\ntype AreaCalculator struct {\n    totalArea float64\n}\n\nfunc (a *AreaCalculator) VisitCircle(c *Circle) {\n    area := 3.14159 * c.Radius * c.Radius\n    fmt.Printf(\"Circle area: %.2f\\n\", area)\n    a.totalArea += area\n}\n\nfunc (a *AreaCalculator) VisitRectangle(r *Rectangle) {\n    area := r.Width * r.Height\n    fmt.Printf(\"Rectangle area: %.2f\\n\", area)\n    a.totalArea += area\n}\n\nfunc (a *AreaCalculator) VisitTriangle(t *Triangle) {\n    area := 0.5 * t.Base * t.Height\n    fmt.Printf(\"Triangle area: %.2f\\n\", area)\n    a.totalArea += area\n}\n\ntype PerimeterCalculator struct {\n    totalPerimeter float64\n}\n\nfunc (p *PerimeterCalculator) VisitCircle(c *Circle) {\n    perimeter := 2 * 3.14159 * c.Radius\n    fmt.Printf(\"Circle perimeter: %.2f\\n\", perimeter)\n    p.totalPerimeter += perimeter\n}\n\nfunc (p *PerimeterCalculator) VisitRectangle(r *Rectangle) {\n    perimeter := 2 * (r.Width + r.Height)\n    fmt.Printf(\"Rectangle perimeter: %.2f\\n\", perimeter)\n    p.totalPerimeter += perimeter\n}\n\nfunc (p *PerimeterCalculator) VisitTriangle(t *Triangle) {\n    // Simplified: assuming equilateral triangle\n    perimeter := 3 * t.Base\n    fmt.Printf(\"Triangle perimeter: %.2f\\n\", perimeter)\n    p.totalPerimeter += perimeter\n}\n\n// Usage\nfunc main() {\n    shapes := []Shape{\n        &Circle{Radius: 5},\n        &Rectangle{Width: 10, Height: 5},\n        &Triangle{Base: 6, Height: 4},\n    }\n    \n    areaCalc := &AreaCalculator{}\n    for _, shape := range shapes {\n        shape.Accept(areaCalc)\n    }\n    fmt.Printf(\"Total area: %.2f\\n\\n\", areaCalc.totalArea)\n    \n    perimCalc := &PerimeterCalculator{}\n    for _, shape := range shapes {\n        shape.Accept(perimCalc)\n    }\n    fmt.Printf(\"Total perimeter: %.2f\\n\", perimCalc.totalPerimeter)\n}\n```\n\n## Architectural Patterns\n\n### Repository Pattern\nRepository encapsulates data access logic and provides a more object-oriented view of the persistence layer.\n\n```go\n// Domain model\ntype User struct {\n    ID        string\n    Email     string\n    FirstName string\n    LastName  string\n    CreatedAt time.Time\n}\n\n// Repository interface\ntype UserRepository interface {\n    Create(ctx context.Context, user *User) error\n    GetByID(ctx context.Context, id string) (*User, error)\n    GetByEmail(ctx context.Context, email string) (*User, error)\n    Update(ctx context.Context, user *User) error\n    Delete(ctx context.Context, id string) error\n    List(ctx context.Context, offset, limit int) ([]*User, error)\n}\n\n// PostgreSQL implementation\ntype PostgresUserRepository struct {\n    db *sql.DB\n}\n\nfunc NewPostgresUserRepository(db *sql.DB) *PostgresUserRepository {\n    return &PostgresUserRepository{db: db}\n}\n\nfunc (r *PostgresUserRepository) Create(ctx context.Context, user *User) error {\n    query := `\n        INSERT INTO users (id, email, first_name, last_name, created_at)\n        VALUES ($1, $2, $3, $4, $5)\n    `\n    _, err := r.db.ExecContext(ctx, query,\n        user.ID, user.Email, user.FirstName, user.LastName, user.CreatedAt)\n    return err\n}\n\nfunc (r *PostgresUserRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    query := `\n        SELECT id, email, first_name, last_name, created_at\n        FROM users WHERE id = $1\n    `\n    user := &User{}\n    err := r.db.QueryRowContext(ctx, query, id).Scan(\n        &user.ID, &user.Email, &user.FirstName, &user.LastName, &user.CreatedAt)\n    if err == sql.ErrNoRows {\n        return nil, fmt.Errorf(\"user not found\")\n    }\n    return user, err\n}\n\n// In-memory implementation for testing\ntype InMemoryUserRepository struct {\n    mu    sync.RWMutex\n    users map[string]*User\n}\n\nfunc NewInMemoryUserRepository() *InMemoryUserRepository {\n    return &InMemoryUserRepository{\n        users: make(map[string]*User),\n    }\n}\n\nfunc (r *InMemoryUserRepository) Create(ctx context.Context, user *User) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    \n    if _, exists := r.users[user.ID]; exists {\n        return fmt.Errorf(\"user already exists\")\n    }\n    r.users[user.ID] = user\n    return nil\n}\n\nfunc (r *InMemoryUserRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    \n    if user, exists := r.users[id]; exists {\n        return user, nil\n    }\n    return nil, fmt.Errorf(\"user not found\")\n}\n```\n\n### Unit of Work Pattern\nUnit of Work maintains a list of objects affected by a business transaction and coordinates writing out changes.\n\n```go\n// Unit of Work interface\ntype UnitOfWork interface {\n    UserRepository() UserRepository\n    OrderRepository() OrderRepository\n    Commit() error\n    Rollback() error\n}\n\n// PostgreSQL Unit of Work\ntype PostgresUnitOfWork struct {\n    tx    *sql.Tx\n    users *PostgresUserRepository\n    orders *PostgresOrderRepository\n}\n\nfunc NewPostgresUnitOfWork(db *sql.DB) (*PostgresUnitOfWork, error) {\n    tx, err := db.Begin()\n    if err != nil {\n        return nil, err\n    }\n    \n    return &PostgresUnitOfWork{\n        tx:     tx,\n        users:  &PostgresUserRepository{db: db},\n        orders: &PostgresOrderRepository{db: db},\n    }, nil\n}\n\nfunc (u *PostgresUnitOfWork) UserRepository() UserRepository {\n    return u.users\n}\n\nfunc (u *PostgresUnitOfWork) OrderRepository() OrderRepository {\n    return u.orders\n}\n\nfunc (u *PostgresUnitOfWork) Commit() error {\n    return u.tx.Commit()\n}\n\nfunc (u *PostgresUnitOfWork) Rollback() error {\n    return u.tx.Rollback()\n}\n\n// Service using Unit of Work\ntype OrderService struct {\n    uowFactory func() (UnitOfWork, error)\n}\n\nfunc (s *OrderService) CreateOrder(userID string, items []OrderItem) error {\n    uow, err := s.uowFactory()\n    if err != nil {\n        return err\n    }\n    defer uow.Rollback()\n    \n    // Check user exists\n    user, err := uow.UserRepository().GetByID(context.Background(), userID)\n    if err != nil {\n        return err\n    }\n    \n    // Create order\n    order := &Order{\n        UserID: user.ID,\n        Items:  items,\n        Total:  calculateTotal(items),\n    }\n    \n    if err := uow.OrderRepository().Create(context.Background(), order); err != nil {\n        return err\n    }\n    \n    // Update user stats\n    user.TotalOrders++\n    if err := uow.UserRepository().Update(context.Background(), user); err != nil {\n        return err\n    }\n    \n    // Commit transaction\n    return uow.Commit()\n}\n```\n\n## Domain-Driven Design Patterns\n\n### Value Object\nValue Objects are immutable objects that represent a descriptive aspect of the domain.\n\n```go\n// Value Object - immutable\ntype Money struct {\n    amount   decimal.Decimal\n    currency string\n}\n\nfunc NewMoney(amount decimal.Decimal, currency string) (Money, error) {\n    if currency == \"\" {\n        return Money{}, fmt.Errorf(\"currency is required\")\n    }\n    if amount.IsNegative() {\n        return Money{}, fmt.Errorf(\"amount cannot be negative\")\n    }\n    return Money{amount: amount, currency: currency}, nil\n}\n\nfunc (m Money) Amount() decimal.Decimal {\n    return m.amount\n}\n\nfunc (m Money) Currency() string {\n    return m.currency\n}\n\nfunc (m Money) Add(other Money) (Money, error) {\n    if m.currency != other.currency {\n        return Money{}, fmt.Errorf(\"cannot add different currencies\")\n    }\n    return Money{\n        amount:   m.amount.Add(other.amount),\n        currency: m.currency,\n    }, nil\n}\n\nfunc (m Money) Equals(other Money) bool {\n    return m.amount.Equal(other.amount) && m.currency == other.currency\n}\n\n// Another Value Object example\ntype Email struct {\n    value string\n}\n\nfunc NewEmail(value string) (Email, error) {\n    if !isValidEmail(value) {\n        return Email{}, fmt.Errorf(\"invalid email format\")\n    }\n    return Email{value: strings.ToLower(value)}, nil\n}\n\nfunc (e Email) String() string {\n    return e.value\n}\n\nfunc (e Email) Domain() string {\n    parts := strings.Split(e.value, \"@\")\n    if len(parts) == 2 {\n        return parts[1]\n    }\n    return \"\"\n}\n```\n\n### Entity\nEntities have identity and lifecycle.\n\n```go\n// Entity with identity\ntype Product struct {\n    id          ProductID // Value object as ID\n    name        string\n    description string\n    price       Money\n    stock       int\n    version     int // For optimistic locking\n}\n\ntype ProductID struct {\n    value string\n}\n\nfunc NewProductID(value string) (ProductID, error) {\n    if value == \"\" {\n        return ProductID{}, fmt.Errorf(\"product ID cannot be empty\")\n    }\n    return ProductID{value: value}, nil\n}\n\nfunc (p ProductID) String() string {\n    return p.value\n}\n\nfunc NewProduct(id ProductID, name string, price Money) (*Product, error) {\n    if name == \"\" {\n        return nil, fmt.Errorf(\"product name is required\")\n    }\n    \n    return &Product{\n        id:    id,\n        name:  name,\n        price: price,\n        stock: 0,\n    }, nil\n}\n\nfunc (p *Product) ID() ProductID {\n    return p.id\n}\n\nfunc (p *Product) UpdatePrice(newPrice Money) error {\n    if newPrice.Amount().IsZero() {\n        return fmt.Errorf(\"price cannot be zero\")\n    }\n    p.price = newPrice\n    p.version++\n    return nil\n}\n\nfunc (p *Product) AddStock(quantity int) error {\n    if quantity <= 0 {\n        return fmt.Errorf(\"quantity must be positive\")\n    }\n    p.stock += quantity\n    p.version++\n    return nil\n}\n\nfunc (p *Product) CanFulfillOrder(quantity int) bool {\n    return p.stock >= quantity\n}\n```\n\n### Aggregate\nAggregates are clusters of domain objects that are treated as a single unit.\n\n```go\n// Aggregate root\ntype Order struct {\n    id         OrderID\n    customerID CustomerID\n    items      []OrderItem\n    status     OrderStatus\n    totalAmount Money\n    placedAt   time.Time\n    version    int\n}\n\n// Part of the aggregate\ntype OrderItem struct {\n    productID ProductID\n    quantity  int\n    unitPrice Money\n}\n\ntype OrderStatus string\n\nconst (\n    OrderStatusPending   OrderStatus = \"PENDING\"\n    OrderStatusConfirmed OrderStatus = \"CONFIRMED\"\n    OrderStatusShipped   OrderStatus = \"SHIPPED\"\n    OrderStatusDelivered OrderStatus = \"DELIVERED\"\n    OrderStatusCancelled OrderStatus = \"CANCELLED\"\n)\n\nfunc NewOrder(customerID CustomerID) *Order {\n    return &Order{\n        id:         NewOrderID(),\n        customerID: customerID,\n        items:      []OrderItem{},\n        status:     OrderStatusPending,\n        placedAt:   time.Now(),\n    }\n}\n\nfunc (o *Order) AddItem(productID ProductID, quantity int, unitPrice Money) error {\n    if o.status != OrderStatusPending {\n        return fmt.Errorf(\"cannot modify confirmed order\")\n    }\n    \n    if quantity <= 0 {\n        return fmt.Errorf(\"quantity must be positive\")\n    }\n    \n    // Check if item already exists\n    for i, item := range o.items {\n        if item.productID == productID {\n            o.items[i].quantity += quantity\n            o.recalculateTotal()\n            return nil\n        }\n    }\n    \n    // Add new item\n    o.items = append(o.items, OrderItem{\n        productID: productID,\n        quantity:  quantity,\n        unitPrice: unitPrice,\n    })\n    \n    o.recalculateTotal()\n    return nil\n}\n\nfunc (o *Order) RemoveItem(productID ProductID) error {\n    if o.status != OrderStatusPending {\n        return fmt.Errorf(\"cannot modify confirmed order\")\n    }\n    \n    for i, item := range o.items {\n        if item.productID == productID {\n            o.items = append(o.items[:i], o.items[i+1:]...)\n            o.recalculateTotal()\n            return nil\n        }\n    }\n    \n    return fmt.Errorf(\"item not found\")\n}\n\nfunc (o *Order) Confirm() error {\n    if o.status != OrderStatusPending {\n        return fmt.Errorf(\"order is not pending\")\n    }\n    \n    if len(o.items) == 0 {\n        return fmt.Errorf(\"order has no items\")\n    }\n    \n    o.status = OrderStatusConfirmed\n    o.version++\n    return nil\n}\n\nfunc (o *Order) recalculateTotal() {\n    total := decimal.Zero\n    currency := \"\"\n    \n    for _, item := range o.items {\n        itemTotal := item.unitPrice.Amount().Mul(decimal.NewFromInt(int64(item.quantity)))\n        total = total.Add(itemTotal)\n        if currency == \"\" {\n            currency = item.unitPrice.Currency()\n        }\n    }\n    \n    o.totalAmount, _ = NewMoney(total, currency)\n}\n\n// Aggregate repository\ntype OrderRepository interface {\n    Save(ctx context.Context, order *Order) error\n    GetByID(ctx context.Context, id OrderID) (*Order, error)\n    // Never expose internal parts of aggregate\n    // Bad: GetOrderItems(orderID) []OrderItem\n}\n```\n\n### Domain Service\nDomain Services encapsulate domain logic that doesn't naturally fit within an entity or value object.\n\n```go\n// Domain service for complex business logic\ntype PricingService struct {\n    taxCalculator TaxCalculator\n    discountRepo  DiscountRepository\n}\n\nfunc NewPricingService(tax TaxCalculator, discounts DiscountRepository) *PricingService {\n    return &PricingService{\n        taxCalculator: tax,\n        discountRepo:  discounts,\n    }\n}\n\nfunc (s *PricingService) CalculateOrderTotal(order *Order, customerType CustomerType) (Money, error) {\n    subtotal := order.totalAmount\n    \n    // Apply customer discount\n    discount := s.getCustomerDiscount(customerType)\n    discountAmount := subtotal.Amount().Mul(discount)\n    afterDiscount := subtotal.Amount().Sub(discountAmount)\n    \n    // Calculate tax\n    tax := s.taxCalculator.CalculateTax(afterDiscount, order.ShippingAddress())\n    \n    // Final total\n    total := afterDiscount.Add(tax)\n    \n    return NewMoney(total, subtotal.Currency())\n}\n\nfunc (s *PricingService) getCustomerDiscount(customerType CustomerType) decimal.Decimal {\n    switch customerType {\n    case CustomerTypePremium:\n        return decimal.NewFromFloat(0.15) // 15% discount\n    case CustomerTypeRegular:\n        return decimal.NewFromFloat(0.05) // 5% discount\n    default:\n        return decimal.Zero\n    }\n}\n\n// Another domain service example\ntype TransferService struct {\n    accountRepo AccountRepository\n}\n\nfunc (s *TransferService) Transfer(ctx context.Context, fromID, toID AccountID, amount Money) error {\n    // This logic doesn't belong to either account\n    // It's a domain service coordinating between aggregates\n    \n    from, err := s.accountRepo.GetByID(ctx, fromID)\n    if err != nil {\n        return err\n    }\n    \n    to, err := s.accountRepo.GetByID(ctx, toID)\n    if err != nil {\n        return err\n    }\n    \n    if err := from.Withdraw(amount); err != nil {\n        return err\n    }\n    \n    if err := to.Deposit(amount); err != nil {\n        // Compensate\n        from.Deposit(amount)\n        return err\n    }\n    \n    // Save both accounts\n    if err := s.accountRepo.Save(ctx, from); err != nil {\n        return err\n    }\n    \n    return s.accountRepo.Save(ctx, to)\n}\n```\n\n### Specification Pattern\nSpecification pattern encapsulates business rules in a reusable way.\n\n```go\n// Specification interface\ntype Specification[T any] interface {\n    IsSatisfiedBy(T) bool\n    And(Specification[T]) Specification[T]\n    Or(Specification[T]) Specification[T]\n    Not() Specification[T]\n}\n\n// Base specification\ntype BaseSpecification[T any] struct {\n    predicate func(T) bool\n}\n\nfunc NewSpecification[T any](predicate func(T) bool) Specification[T] {\n    return &BaseSpecification[T]{predicate: predicate}\n}\n\nfunc (s *BaseSpecification[T]) IsSatisfiedBy(item T) bool {\n    return s.predicate(item)\n}\n\nfunc (s *BaseSpecification[T]) And(other Specification[T]) Specification[T] {\n    return &BaseSpecification[T]{\n        predicate: func(item T) bool {\n            return s.IsSatisfiedBy(item) && other.IsSatisfiedBy(item)\n        },\n    }\n}\n\nfunc (s *BaseSpecification[T]) Or(other Specification[T]) Specification[T] {\n    return &BaseSpecification[T]{\n        predicate: func(item T) bool {\n            return s.IsSatisfiedBy(item) || other.IsSatisfiedBy(item)\n        },\n    }\n}\n\nfunc (s *BaseSpecification[T]) Not() Specification[T] {\n    return &BaseSpecification[T]{\n        predicate: func(item T) bool {\n            return !s.IsSatisfiedBy(item)\n        },\n    }\n}\n\n// Concrete specifications\ntype Product struct {\n    Name     string\n    Price    decimal.Decimal\n    Category string\n    InStock  bool\n}\n\nvar PremiumProductSpec = NewSpecification(func(p Product) bool {\n    return p.Price.GreaterThan(decimal.NewFromInt(100))\n})\n\nvar InStockSpec = NewSpecification(func(p Product) bool {\n    return p.InStock\n})\n\nvar ElectronicsSpec = NewSpecification(func(p Product) bool {\n    return p.Category == \"Electronics\"\n})\n\n// Usage\nfunc FilterProducts(products []Product, spec Specification[Product]) []Product {\n    var result []Product\n    for _, p := range products {\n        if spec.IsSatisfiedBy(p) {\n            result = append(result, p)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    products := []Product{\n        {Name: \"Laptop\", Price: decimal.NewFromInt(1200), Category: \"Electronics\", InStock: true},\n        {Name: \"Mouse\", Price: decimal.NewFromInt(25), Category: \"Electronics\", InStock: true},\n        {Name: \"Book\", Price: decimal.NewFromInt(15), Category: \"Books\", InStock: false},\n    }\n    \n    // Premium electronics in stock\n    spec := PremiumProductSpec.And(ElectronicsSpec).And(InStockSpec)\n    \n    filtered := FilterProducts(products, spec)\n    fmt.Printf(\"Found %d products\\n\", len(filtered))\n}\n```\n\n## Summary\n\nThis comprehensive guide covers the major design patterns adapted for Go:\n\n1. **Creational Patterns**: Control object creation mechanisms\n2. **Structural Patterns**: Compose objects to form larger structures\n3. **Behavioral Patterns**: Define communication between objects\n4. **Architectural Patterns**: Organize high-level application structure\n5. **Domain-Driven Design Patterns**: Model complex business domains\n\nEach pattern includes practical Go implementations with proper error handling, concurrency considerations, and idiomatic Go practices. Choose patterns based on your specific needs, keeping in mind Go's philosophy of simplicity and clarity."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":77328,"cache_read_input_tokens":11551,"output_tokens":18851,"service_tier":"standard"}},"requestId":"req_011CS5PgLqH2vXDhw1zRaE1m","type":"assistant","uuid":"c09f5e78-9118-419f-b318-dfd1cccc9485","timestamp":"2025-08-13T08:32:51.473Z"}
{"parentUuid":"c09f5e78-9118-419f-b318-dfd1cccc9485","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Br5EVyPtBJMcY7chynPt3d","type":"tool_result","content":"File created successfully at: /home/aural/Code/bigmeanie/back/.docs/code/design-patterns.md"}]},"uuid":"f19c2f73-4dbb-4300-82dd-a9a8b074145f","timestamp":"2025-08-13T08:32:51.518Z","toolUseResult":{"type":"create","filePath":"/home/aural/Code/bigmeanie/back/.docs/code/design-patterns.md","content":"# Design Patterns in Go\n\n## Overview\nThis document covers classic design patterns (Gang of Four) and architectural patterns as they apply to Go. For Go-specific idioms and conventions, see `practices-patterns.md`.\n\n## Table of Contents\n1. [Creational Patterns](#creational-patterns)\n2. [Structural Patterns](#structural-patterns)\n3. [Behavioral Patterns](#behavioral-patterns)\n4. [Architectural Patterns](#architectural-patterns)\n5. [Domain-Driven Design Patterns](#domain-driven-design-patterns)\n\n## Creational Patterns\n\n### Singleton\nThe singleton pattern ensures only one instance of a type exists. In Go, use `sync.Once` for thread-safe initialization.\n\n```go\npackage database\n\nimport (\n    \"database/sql\"\n    \"sync\"\n)\n\ntype DB struct {\n    conn *sql.DB\n}\n\nvar (\n    instance *DB\n    once     sync.Once\n)\n\n// GetInstance returns the singleton database instance\nfunc GetInstance() *DB {\n    once.Do(func() {\n        conn, _ := sql.Open(\"postgres\", \"connection-string\")\n        instance = &DB{conn: conn}\n    })\n    return instance\n}\n\n// Alternative: Package-level initialization (simpler for most cases)\nvar defaultDB = initDB()\n\nfunc initDB() *DB {\n    conn, _ := sql.Open(\"postgres\", \"connection-string\")\n    return &DB{conn: conn}\n}\n```\n\n### Factory Method\nFactory method defines an interface for creating objects but lets subclasses decide which class to instantiate.\n\n```go\n// Product interface\ntype Transport interface {\n    Deliver() string\n    Cost() float64\n}\n\n// Concrete products\ntype Truck struct {\n    capacity int\n}\n\nfunc (t *Truck) Deliver() string {\n    return \"Delivering by land\"\n}\n\nfunc (t *Truck) Cost() float64 {\n    return 100.0\n}\n\ntype Ship struct {\n    tonnage int\n}\n\nfunc (s *Ship) Deliver() string {\n    return \"Delivering by sea\"\n}\n\nfunc (s *Ship) Cost() float64 {\n    return 500.0\n}\n\n// Factory\ntype LogisticsFactory interface {\n    CreateTransport() Transport\n}\n\ntype RoadLogistics struct{}\n\nfunc (r *RoadLogistics) CreateTransport() Transport {\n    return &Truck{capacity: 1000}\n}\n\ntype SeaLogistics struct{}\n\nfunc (s *SeaLogistics) CreateTransport() Transport {\n    return &Ship{tonnage: 10000}\n}\n\n// Usage\nfunc planDelivery(factory LogisticsFactory) {\n    transport := factory.CreateTransport()\n    fmt.Println(transport.Deliver())\n    fmt.Printf(\"Cost: $%.2f\\n\", transport.Cost())\n}\n```\n\n### Abstract Factory\nAbstract factory provides an interface for creating families of related objects.\n\n```go\n// Abstract products\ntype Button interface {\n    Paint()\n}\n\ntype Checkbox interface {\n    Check()\n}\n\n// Concrete products - Windows family\ntype WindowsButton struct{}\n\nfunc (w *WindowsButton) Paint() {\n    fmt.Println(\"Rendering Windows button\")\n}\n\ntype WindowsCheckbox struct{}\n\nfunc (w *WindowsCheckbox) Check() {\n    fmt.Println(\"Checking Windows checkbox\")\n}\n\n// Concrete products - Mac family\ntype MacButton struct{}\n\nfunc (m *MacButton) Paint() {\n    fmt.Println(\"Rendering Mac button\")\n}\n\ntype MacCheckbox struct{}\n\nfunc (m *MacCheckbox) Check() {\n    fmt.Println(\"Checking Mac checkbox\")\n}\n\n// Abstract factory\ntype GUIFactory interface {\n    CreateButton() Button\n    CreateCheckbox() Checkbox\n}\n\n// Concrete factories\ntype WindowsFactory struct{}\n\nfunc (w *WindowsFactory) CreateButton() Button {\n    return &WindowsButton{}\n}\n\nfunc (w *WindowsFactory) CreateCheckbox() Checkbox {\n    return &WindowsCheckbox{}\n}\n\ntype MacFactory struct{}\n\nfunc (m *MacFactory) CreateButton() Button {\n    return &MacButton{}\n}\n\nfunc (m *MacFactory) CreateCheckbox() Checkbox {\n    return &MacCheckbox{}\n}\n\n// Application\ntype Application struct {\n    factory GUIFactory\n    button  Button\n    checkbox Checkbox\n}\n\nfunc NewApplication(factory GUIFactory) *Application {\n    return &Application{\n        factory:  factory,\n        button:   factory.CreateButton(),\n        checkbox: factory.CreateCheckbox(),\n    }\n}\n\nfunc (a *Application) Paint() {\n    a.button.Paint()\n    a.checkbox.Check()\n}\n```\n\n### Builder\nBuilder pattern separates the construction of complex objects from their representation.\n\n```go\n// Product\ntype House struct {\n    Foundation string\n    Structure  string\n    Roof       string\n    Interior   string\n    Garden     bool\n    Pool       bool\n}\n\n// Builder interface\ntype HouseBuilder interface {\n    SetFoundation() HouseBuilder\n    SetStructure() HouseBuilder\n    SetRoof() HouseBuilder\n    SetInterior() HouseBuilder\n    SetGarden() HouseBuilder\n    SetPool() HouseBuilder\n    Build() *House\n}\n\n// Concrete builder\ntype ModernHouseBuilder struct {\n    house *House\n}\n\nfunc NewModernHouseBuilder() *ModernHouseBuilder {\n    return &ModernHouseBuilder{\n        house: &House{},\n    }\n}\n\nfunc (b *ModernHouseBuilder) SetFoundation() HouseBuilder {\n    b.house.Foundation = \"Concrete, brick, and stone\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetStructure() HouseBuilder {\n    b.house.Structure = \"Steel and glass\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetRoof() HouseBuilder {\n    b.house.Roof = \"Flat concrete\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetInterior() HouseBuilder {\n    b.house.Interior = \"Modern minimalist\"\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetGarden() HouseBuilder {\n    b.house.Garden = true\n    return b\n}\n\nfunc (b *ModernHouseBuilder) SetPool() HouseBuilder {\n    b.house.Pool = true\n    return b\n}\n\nfunc (b *ModernHouseBuilder) Build() *House {\n    return b.house\n}\n\n// Director (optional)\ntype ConstructionDirector struct {\n    builder HouseBuilder\n}\n\nfunc (d *ConstructionDirector) ConstructLuxuryHouse() *House {\n    return d.builder.\n        SetFoundation().\n        SetStructure().\n        SetRoof().\n        SetInterior().\n        SetGarden().\n        SetPool().\n        Build()\n}\n\n// Usage\nfunc main() {\n    builder := NewModernHouseBuilder()\n    \n    // Direct use\n    house := builder.\n        SetFoundation().\n        SetStructure().\n        SetRoof().\n        Build()\n    \n    // Using director\n    director := &ConstructionDirector{builder: builder}\n    luxuryHouse := director.ConstructLuxuryHouse()\n}\n```\n\n### Prototype\nPrototype pattern creates objects by cloning existing instances.\n\n```go\n// Prototype interface\ntype Prototype interface {\n    Clone() Prototype\n}\n\n// Concrete prototype\ntype Document struct {\n    Title    string\n    Content  string\n    Images   []string\n    Metadata map[string]string\n}\n\nfunc (d *Document) Clone() Prototype {\n    // Deep copy\n    newDoc := &Document{\n        Title:   d.Title,\n        Content: d.Content,\n        Images:  make([]string, len(d.Images)),\n        Metadata: make(map[string]string),\n    }\n    \n    copy(newDoc.Images, d.Images)\n    \n    for k, v := range d.Metadata {\n        newDoc.Metadata[k] = v\n    }\n    \n    return newDoc\n}\n\n// Prototype registry\ntype DocumentRegistry struct {\n    prototypes map[string]Prototype\n}\n\nfunc NewDocumentRegistry() *DocumentRegistry {\n    return &DocumentRegistry{\n        prototypes: make(map[string]Prototype),\n    }\n}\n\nfunc (r *DocumentRegistry) Register(name string, prototype Prototype) {\n    r.prototypes[name] = prototype\n}\n\nfunc (r *DocumentRegistry) Create(name string) Prototype {\n    if prototype, exists := r.prototypes[name]; exists {\n        return prototype.Clone()\n    }\n    return nil\n}\n\n// Usage\nfunc main() {\n    registry := NewDocumentRegistry()\n    \n    // Register prototypes\n    registry.Register(\"report\", &Document{\n        Title:    \"Monthly Report Template\",\n        Content:  \"...\",\n        Metadata: map[string]string{\"type\": \"report\"},\n    })\n    \n    registry.Register(\"letter\", &Document{\n        Title:    \"Business Letter Template\",\n        Content:  \"...\",\n        Metadata: map[string]string{\"type\": \"letter\"},\n    })\n    \n    // Create new documents from prototypes\n    report := registry.Create(\"report\").(*Document)\n    report.Title = \"January Report\"\n}\n```\n\n## Structural Patterns\n\n### Adapter\nAdapter allows incompatible interfaces to work together.\n\n```go\n// Target interface (what client expects)\ntype PaymentProcessor interface {\n    ProcessPayment(amount float64) error\n}\n\n// Adaptee (incompatible interface)\ntype LegacyPaymentSystem struct{}\n\nfunc (l *LegacyPaymentSystem) MakePayment(sum float64, currency string) string {\n    return fmt.Sprintf(\"Payment of %.2f %s processed\", sum, currency)\n}\n\n// Adapter\ntype PaymentAdapter struct {\n    legacy   *LegacyPaymentSystem\n    currency string\n}\n\nfunc NewPaymentAdapter(legacy *LegacyPaymentSystem, currency string) *PaymentAdapter {\n    return &PaymentAdapter{\n        legacy:   legacy,\n        currency: currency,\n    }\n}\n\nfunc (a *PaymentAdapter) ProcessPayment(amount float64) error {\n    result := a.legacy.MakePayment(amount, a.currency)\n    if result != \"\" {\n        return nil\n    }\n    return fmt.Errorf(\"payment failed\")\n}\n\n// Client code\nfunc processOrder(processor PaymentProcessor, amount float64) {\n    if err := processor.ProcessPayment(amount); err != nil {\n        fmt.Printf(\"Payment failed: %v\\n\", err)\n    } else {\n        fmt.Println(\"Payment successful\")\n    }\n}\n\n// Usage\nfunc main() {\n    legacy := &LegacyPaymentSystem{}\n    adapter := NewPaymentAdapter(legacy, \"USD\")\n    processOrder(adapter, 100.00)\n}\n```\n\n### Bridge\nBridge decouples abstraction from implementation so both can vary independently.\n\n```go\n// Implementation interface\ntype MessageSender interface {\n    Send(title, body string) error\n}\n\n// Concrete implementations\ntype EmailSender struct {\n    emailAddress string\n}\n\nfunc (e *EmailSender) Send(title, body string) error {\n    fmt.Printf(\"Email to %s: %s - %s\\n\", e.emailAddress, title, body)\n    return nil\n}\n\ntype SMSSender struct {\n    phoneNumber string\n}\n\nfunc (s *SMSSender) Send(title, body string) error {\n    fmt.Printf(\"SMS to %s: %s\\n\", s.phoneNumber, body)\n    return nil\n}\n\n// Abstraction\ntype Message struct {\n    sender MessageSender\n}\n\nfunc NewMessage(sender MessageSender) *Message {\n    return &Message{sender: sender}\n}\n\nfunc (m *Message) Send(title, body string) error {\n    return m.sender.Send(title, body)\n}\n\n// Refined abstraction\ntype UrgentMessage struct {\n    Message\n}\n\nfunc NewUrgentMessage(sender MessageSender) *UrgentMessage {\n    return &UrgentMessage{\n        Message: Message{sender: sender},\n    }\n}\n\nfunc (u *UrgentMessage) Send(title, body string) error {\n    title = \"URGENT: \" + title\n    return u.sender.Send(title, body)\n}\n\n// Usage\nfunc main() {\n    // Regular email\n    email := NewMessage(&EmailSender{emailAddress: \"user@example.com\"})\n    email.Send(\"Hello\", \"This is a test message\")\n    \n    // Urgent SMS\n    sms := NewUrgentMessage(&SMSSender{phoneNumber: \"+1234567890\"})\n    sms.Send(\"Alert\", \"Server is down\")\n}\n```\n\n### Composite\nComposite lets you compose objects into tree structures to represent part-whole hierarchies.\n\n```go\n// Component interface\ntype FileSystemNode interface {\n    GetName() string\n    GetSize() int64\n    Print(indent string)\n}\n\n// Leaf\ntype File struct {\n    name string\n    size int64\n}\n\nfunc (f *File) GetName() string {\n    return f.name\n}\n\nfunc (f *File) GetSize() int64 {\n    return f.size\n}\n\nfunc (f *File) Print(indent string) {\n    fmt.Printf(\"%sFile: %s (%d bytes)\\n\", indent, f.name, f.size)\n}\n\n// Composite\ntype Directory struct {\n    name     string\n    children []FileSystemNode\n}\n\nfunc (d *Directory) GetName() string {\n    return d.name\n}\n\nfunc (d *Directory) GetSize() int64 {\n    var total int64\n    for _, child := range d.children {\n        total += child.GetSize()\n    }\n    return total\n}\n\nfunc (d *Directory) Add(node FileSystemNode) {\n    d.children = append(d.children, node)\n}\n\nfunc (d *Directory) Remove(node FileSystemNode) {\n    for i, child := range d.children {\n        if child == node {\n            d.children = append(d.children[:i], d.children[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (d *Directory) Print(indent string) {\n    fmt.Printf(\"%sDirectory: %s (%d bytes)\\n\", indent, d.name, d.GetSize())\n    for _, child := range d.children {\n        child.Print(indent + \"  \")\n    }\n}\n\n// Usage\nfunc main() {\n    root := &Directory{name: \"root\"}\n    \n    home := &Directory{name: \"home\"}\n    root.Add(home)\n    \n    documents := &Directory{name: \"documents\"}\n    home.Add(documents)\n    \n    documents.Add(&File{name: \"report.pdf\", size: 1024000})\n    documents.Add(&File{name: \"presentation.pptx\", size: 2048000})\n    \n    home.Add(&File{name: \"notes.txt\", size: 1024})\n    \n    root.Print(\"\")\n}\n```\n\n### Decorator\nDecorator adds new functionality to objects without altering their structure.\n\n```go\n// Component interface\ntype Coffee interface {\n    GetCost() float64\n    GetDescription() string\n}\n\n// Concrete component\ntype SimpleCoffee struct{}\n\nfunc (c *SimpleCoffee) GetCost() float64 {\n    return 2.0\n}\n\nfunc (c *SimpleCoffee) GetDescription() string {\n    return \"Simple coffee\"\n}\n\n// Base decorator\ntype CoffeeDecorator struct {\n    coffee Coffee\n}\n\nfunc (d *CoffeeDecorator) GetCost() float64 {\n    return d.coffee.GetCost()\n}\n\nfunc (d *CoffeeDecorator) GetDescription() string {\n    return d.coffee.GetDescription()\n}\n\n// Concrete decorators\ntype MilkDecorator struct {\n    CoffeeDecorator\n}\n\nfunc NewMilkDecorator(coffee Coffee) *MilkDecorator {\n    return &MilkDecorator{\n        CoffeeDecorator: CoffeeDecorator{coffee: coffee},\n    }\n}\n\nfunc (m *MilkDecorator) GetCost() float64 {\n    return m.coffee.GetCost() + 0.5\n}\n\nfunc (m *MilkDecorator) GetDescription() string {\n    return m.coffee.GetDescription() + \", milk\"\n}\n\ntype SugarDecorator struct {\n    CoffeeDecorator\n}\n\nfunc NewSugarDecorator(coffee Coffee) *SugarDecorator {\n    return &SugarDecorator{\n        CoffeeDecorator: CoffeeDecorator{coffee: coffee},\n    }\n}\n\nfunc (s *SugarDecorator) GetCost() float64 {\n    return s.coffee.GetCost() + 0.2\n}\n\nfunc (s *SugarDecorator) GetDescription() string {\n    return s.coffee.GetDescription() + \", sugar\"\n}\n\n// Usage\nfunc main() {\n    coffee := &SimpleCoffee{}\n    fmt.Printf(\"%s: $%.2f\\n\", coffee.GetDescription(), coffee.GetCost())\n    \n    coffeeWithMilk := NewMilkDecorator(coffee)\n    fmt.Printf(\"%s: $%.2f\\n\", coffeeWithMilk.GetDescription(), coffeeWithMilk.GetCost())\n    \n    coffeeWithMilkAndSugar := NewSugarDecorator(coffeeWithMilk)\n    fmt.Printf(\"%s: $%.2f\\n\", coffeeWithMilkAndSugar.GetDescription(), coffeeWithMilkAndSugar.GetCost())\n}\n```\n\n### Facade\nFacade provides a simplified interface to a complex subsystem.\n\n```go\n// Complex subsystem components\ntype AccountService struct{}\n\nfunc (a *AccountService) GetAccount(id string) string {\n    return fmt.Sprintf(\"Account %s\", id)\n}\n\nfunc (a *AccountService) CheckBalance(id string) float64 {\n    return 1000.00\n}\n\ntype SecurityService struct{}\n\nfunc (s *SecurityService) Authenticate(token string) bool {\n    return token == \"valid-token\"\n}\n\nfunc (s *SecurityService) Authorize(user, action string) bool {\n    return true\n}\n\ntype TransactionService struct{}\n\nfunc (t *TransactionService) CreateTransaction(from, to string, amount float64) string {\n    return fmt.Sprintf(\"Transaction: %s -> %s: %.2f\", from, to, amount)\n}\n\nfunc (t *TransactionService) ValidateTransaction(id string) bool {\n    return true\n}\n\ntype NotificationService struct{}\n\nfunc (n *NotificationService) SendEmail(to, message string) {\n    fmt.Printf(\"Email to %s: %s\\n\", to, message)\n}\n\nfunc (n *NotificationService) SendSMS(to, message string) {\n    fmt.Printf(\"SMS to %s: %s\\n\", to, message)\n}\n\n// Facade\ntype BankingFacade struct {\n    account      *AccountService\n    security     *SecurityService\n    transaction  *TransactionService\n    notification *NotificationService\n}\n\nfunc NewBankingFacade() *BankingFacade {\n    return &BankingFacade{\n        account:      &AccountService{},\n        security:     &SecurityService{},\n        transaction:  &TransactionService{},\n        notification: &NotificationService{},\n    }\n}\n\nfunc (b *BankingFacade) Transfer(token, from, to string, amount float64) error {\n    // Authenticate\n    if !b.security.Authenticate(token) {\n        return fmt.Errorf(\"authentication failed\")\n    }\n    \n    // Check authorization\n    if !b.security.Authorize(from, \"transfer\") {\n        return fmt.Errorf(\"not authorized\")\n    }\n    \n    // Check balance\n    if b.account.CheckBalance(from) < amount {\n        return fmt.Errorf(\"insufficient funds\")\n    }\n    \n    // Create transaction\n    txID := b.transaction.CreateTransaction(from, to, amount)\n    \n    // Validate\n    if !b.transaction.ValidateTransaction(txID) {\n        return fmt.Errorf(\"transaction validation failed\")\n    }\n    \n    // Notify\n    b.notification.SendEmail(from, fmt.Sprintf(\"Transfer of %.2f completed\", amount))\n    b.notification.SendSMS(to, fmt.Sprintf(\"Received %.2f\", amount))\n    \n    return nil\n}\n\n// Usage\nfunc main() {\n    banking := NewBankingFacade()\n    \n    err := banking.Transfer(\"valid-token\", \"account1\", \"account2\", 100.00)\n    if err != nil {\n        fmt.Printf(\"Transfer failed: %v\\n\", err)\n    } else {\n        fmt.Println(\"Transfer successful\")\n    }\n}\n```\n\n### Flyweight\nFlyweight minimizes memory usage by sharing efficiently large numbers of fine-grained objects.\n\n```go\n// Flyweight interface\ntype Character interface {\n    Display(font string, size int, color string)\n}\n\n// Concrete flyweight\ntype ConcreteCharacter struct {\n    symbol rune // Intrinsic state (shared)\n}\n\nfunc (c *ConcreteCharacter) Display(font string, size int, color string) {\n    // Extrinsic state (passed in)\n    fmt.Printf(\"Character: %c, Font: %s, Size: %d, Color: %s\\n\", \n        c.symbol, font, size, color)\n}\n\n// Flyweight factory\ntype CharacterFactory struct {\n    characters map[rune]*ConcreteCharacter\n}\n\nfunc NewCharacterFactory() *CharacterFactory {\n    return &CharacterFactory{\n        characters: make(map[rune]*ConcreteCharacter),\n    }\n}\n\nfunc (f *CharacterFactory) GetCharacter(symbol rune) Character {\n    if char, exists := f.characters[symbol]; exists {\n        return char\n    }\n    \n    char := &ConcreteCharacter{symbol: symbol}\n    f.characters[symbol] = char\n    return char\n}\n\n// Context that uses flyweights\ntype TextDocument struct {\n    characters []Character\n    fonts      []string\n    sizes      []int\n    colors     []string\n}\n\nfunc (d *TextDocument) AddCharacter(char Character, font string, size int, color string) {\n    d.characters = append(d.characters, char)\n    d.fonts = append(d.fonts, font)\n    d.sizes = append(d.sizes, size)\n    d.colors = append(d.colors, color)\n}\n\nfunc (d *TextDocument) Display() {\n    for i, char := range d.characters {\n        char.Display(d.fonts[i], d.sizes[i], d.colors[i])\n    }\n}\n\n// Usage\nfunc main() {\n    factory := NewCharacterFactory()\n    doc := &TextDocument{}\n    \n    text := \"Hello World\"\n    for _, r := range text {\n        char := factory.GetCharacter(r)\n        doc.AddCharacter(char, \"Arial\", 12, \"black\")\n    }\n    \n    doc.Display()\n    \n    // Characters 'l' and 'o' are reused (shared instances)\n    fmt.Printf(\"Total unique characters created: %d\\n\", len(factory.characters))\n}\n```\n\n### Proxy\nProxy provides a placeholder or surrogate for another object to control access to it.\n\n```go\n// Subject interface\ntype Database interface {\n    Query(sql string) ([]string, error)\n}\n\n// Real subject\ntype RealDatabase struct {\n    connectionString string\n}\n\nfunc (d *RealDatabase) Query(sql string) ([]string, error) {\n    fmt.Printf(\"Executing query: %s\\n\", sql)\n    // Simulate database query\n    return []string{\"result1\", \"result2\"}, nil\n}\n\n// Proxy with caching\ntype CachingDatabaseProxy struct {\n    database *RealDatabase\n    cache    map[string][]string\n}\n\nfunc NewCachingDatabaseProxy(connString string) *CachingDatabaseProxy {\n    return &CachingDatabaseProxy{\n        database: &RealDatabase{connectionString: connString},\n        cache:    make(map[string][]string),\n    }\n}\n\nfunc (p *CachingDatabaseProxy) Query(sql string) ([]string, error) {\n    // Check cache\n    if results, exists := p.cache[sql]; exists {\n        fmt.Printf(\"Returning cached results for: %s\\n\", sql)\n        return results, nil\n    }\n    \n    // Query real database\n    results, err := p.database.Query(sql)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Cache results\n    p.cache[sql] = results\n    return results, nil\n}\n\n// Security proxy\ntype SecureDatabaseProxy struct {\n    database Database\n    userRole string\n}\n\nfunc NewSecureDatabaseProxy(db Database, role string) *SecureDatabaseProxy {\n    return &SecureDatabaseProxy{\n        database: db,\n        userRole: role,\n    }\n}\n\nfunc (p *SecureDatabaseProxy) Query(sql string) ([]string, error) {\n    // Check permissions\n    if strings.Contains(strings.ToLower(sql), \"delete\") && p.userRole != \"admin\" {\n        return nil, fmt.Errorf(\"permission denied: only admin can delete\")\n    }\n    \n    return p.database.Query(sql)\n}\n\n// Usage\nfunc main() {\n    // Caching proxy\n    db := NewCachingDatabaseProxy(\"connection-string\")\n    \n    // First query hits the database\n    results, _ := db.Query(\"SELECT * FROM users\")\n    fmt.Println(\"Results:\", results)\n    \n    // Second identical query uses cache\n    results, _ = db.Query(\"SELECT * FROM users\")\n    fmt.Println(\"Results:\", results)\n    \n    // Security proxy\n    secureDB := NewSecureDatabaseProxy(db, \"user\")\n    _, err := secureDB.Query(\"DELETE FROM users\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n```\n\n## Behavioral Patterns\n\n### Chain of Responsibility\nChain of Responsibility passes requests along a chain of handlers until one handles it.\n\n```go\n// Handler interface\ntype Handler interface {\n    SetNext(Handler) Handler\n    Handle(request string) string\n}\n\n// Base handler\ntype BaseHandler struct {\n    next Handler\n}\n\nfunc (h *BaseHandler) SetNext(next Handler) Handler {\n    h.next = next\n    return next\n}\n\nfunc (h *BaseHandler) Handle(request string) string {\n    if h.next != nil {\n        return h.next.Handle(request)\n    }\n    return \"\"\n}\n\n// Concrete handlers\ntype AuthenticationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthenticationHandler) Handle(request string) string {\n    if request == \"auth\" {\n        return \"Authentication successful\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\ntype AuthorizationHandler struct {\n    BaseHandler\n}\n\nfunc (h *AuthorizationHandler) Handle(request string) string {\n    if request == \"authz\" {\n        return \"Authorization granted\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\ntype ValidationHandler struct {\n    BaseHandler\n}\n\nfunc (h *ValidationHandler) Handle(request string) string {\n    if request == \"validate\" {\n        return \"Validation passed\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\n// Usage\nfunc main() {\n    auth := &AuthenticationHandler{}\n    authz := &AuthorizationHandler{}\n    valid := &ValidationHandler{}\n    \n    // Build chain\n    auth.SetNext(authz).SetNext(valid)\n    \n    // Process requests\n    fmt.Println(auth.Handle(\"auth\"))     // Handled by auth\n    fmt.Println(auth.Handle(\"authz\"))    // Handled by authz\n    fmt.Println(auth.Handle(\"validate\")) // Handled by valid\n    fmt.Println(auth.Handle(\"unknown\"))  // Not handled\n}\n```\n\n### Command\nCommand encapsulates a request as an object, letting you parameterize clients with different requests.\n\n```go\n// Command interface\ntype Command interface {\n    Execute() error\n    Undo() error\n}\n\n// Receiver\ntype Light struct {\n    isOn bool\n}\n\nfunc (l *Light) TurnOn() {\n    l.isOn = true\n    fmt.Println(\"Light is on\")\n}\n\nfunc (l *Light) TurnOff() {\n    l.isOn = false\n    fmt.Println(\"Light is off\")\n}\n\n// Concrete commands\ntype TurnOnCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOnCommand) Execute() error {\n    c.light.TurnOn()\n    return nil\n}\n\nfunc (c *TurnOnCommand) Undo() error {\n    c.light.TurnOff()\n    return nil\n}\n\ntype TurnOffCommand struct {\n    light *Light\n}\n\nfunc (c *TurnOffCommand) Execute() error {\n    c.light.TurnOff()\n    return nil\n}\n\nfunc (c *TurnOffCommand) Undo() error {\n    c.light.TurnOn()\n    return nil\n}\n\n// Invoker\ntype RemoteControl struct {\n    commands []Command\n    history  []Command\n}\n\nfunc (r *RemoteControl) SetCommand(slot int, cmd Command) {\n    if slot >= len(r.commands) {\n        r.commands = append(r.commands, make([]Command, slot-len(r.commands)+1)...)\n    }\n    r.commands[slot] = cmd\n}\n\nfunc (r *RemoteControl) PressButton(slot int) {\n    if slot < len(r.commands) && r.commands[slot] != nil {\n        r.commands[slot].Execute()\n        r.history = append(r.history, r.commands[slot])\n    }\n}\n\nfunc (r *RemoteControl) PressUndo() {\n    if len(r.history) > 0 {\n        lastCommand := r.history[len(r.history)-1]\n        lastCommand.Undo()\n        r.history = r.history[:len(r.history)-1]\n    }\n}\n\n// Macro command\ntype MacroCommand struct {\n    commands []Command\n}\n\nfunc (m *MacroCommand) Execute() error {\n    for _, cmd := range m.commands {\n        if err := cmd.Execute(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc (m *MacroCommand) Undo() error {\n    // Undo in reverse order\n    for i := len(m.commands) - 1; i >= 0; i-- {\n        if err := m.commands[i].Undo(); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\n// Usage\nfunc main() {\n    light := &Light{}\n    remote := &RemoteControl{}\n    \n    turnOn := &TurnOnCommand{light: light}\n    turnOff := &TurnOffCommand{light: light}\n    \n    remote.SetCommand(0, turnOn)\n    remote.SetCommand(1, turnOff)\n    \n    remote.PressButton(0) // Turn on\n    remote.PressButton(1) // Turn off\n    remote.PressUndo()    // Turn on again\n}\n```\n\n### Iterator\nIterator provides a way to access elements of a collection sequentially without exposing its underlying representation.\n\n```go\n// Iterator interface\ntype Iterator[T any] interface {\n    HasNext() bool\n    Next() T\n}\n\n// Collection interface\ntype Collection[T any] interface {\n    CreateIterator() Iterator[T]\n}\n\n// Concrete collection\ntype BookCollection struct {\n    books []string\n}\n\nfunc (c *BookCollection) Add(book string) {\n    c.books = append(c.books, book)\n}\n\nfunc (c *BookCollection) CreateIterator() Iterator[string] {\n    return &BookIterator{\n        collection: c,\n        index:      0,\n    }\n}\n\n// Concrete iterator\ntype BookIterator struct {\n    collection *BookCollection\n    index      int\n}\n\nfunc (i *BookIterator) HasNext() bool {\n    return i.index < len(i.collection.books)\n}\n\nfunc (i *BookIterator) Next() string {\n    if i.HasNext() {\n        book := i.collection.books[i.index]\n        i.index++\n        return book\n    }\n    return \"\"\n}\n\n// Usage with channels (Go idiomatic)\ntype ChannelIterator[T any] struct {\n    ch <-chan T\n    current T\n    hasNext bool\n}\n\nfunc NewChannelIterator[T any](items []T) *ChannelIterator[T] {\n    ch := make(chan T)\n    go func() {\n        for _, item := range items {\n            ch <- item\n        }\n        close(ch)\n    }()\n    \n    iter := &ChannelIterator[T]{ch: ch}\n    iter.advance()\n    return iter\n}\n\nfunc (i *ChannelIterator[T]) advance() {\n    i.current, i.hasNext = <-i.ch\n}\n\nfunc (i *ChannelIterator[T]) HasNext() bool {\n    return i.hasNext\n}\n\nfunc (i *ChannelIterator[T]) Next() T {\n    current := i.current\n    i.advance()\n    return current\n}\n\n// Usage\nfunc main() {\n    // Traditional iterator\n    collection := &BookCollection{}\n    collection.Add(\"Design Patterns\")\n    collection.Add(\"Clean Code\")\n    collection.Add(\"The Pragmatic Programmer\")\n    \n    iterator := collection.CreateIterator()\n    for iterator.HasNext() {\n        fmt.Println(iterator.Next())\n    }\n    \n    // Channel-based iterator\n    numbers := []int{1, 2, 3, 4, 5}\n    numIter := NewChannelIterator(numbers)\n    for numIter.HasNext() {\n        fmt.Println(numIter.Next())\n    }\n}\n```\n\n### Mediator\nMediator defines how a set of objects interact, promoting loose coupling.\n\n```go\n// Mediator interface\ntype ChatRoomMediator interface {\n    SendMessage(msg string, user User)\n    AddUser(user User)\n}\n\n// Colleague interface\ntype User interface {\n    Send(msg string)\n    Receive(msg string)\n    SetMediator(mediator ChatRoomMediator)\n}\n\n// Concrete mediator\ntype ChatRoom struct {\n    users []User\n}\n\nfunc (c *ChatRoom) SendMessage(msg string, sender User) {\n    for _, user := range c.users {\n        // Don't send message back to sender\n        if user != sender {\n            user.Receive(msg)\n        }\n    }\n}\n\nfunc (c *ChatRoom) AddUser(user User) {\n    c.users = append(c.users, user)\n    user.SetMediator(c)\n}\n\n// Concrete colleague\ntype ChatUser struct {\n    name     string\n    mediator ChatRoomMediator\n}\n\nfunc NewChatUser(name string) *ChatUser {\n    return &ChatUser{name: name}\n}\n\nfunc (u *ChatUser) Send(msg string) {\n    fmt.Printf(\"%s sends: %s\\n\", u.name, msg)\n    if u.mediator != nil {\n        u.mediator.SendMessage(msg, u)\n    }\n}\n\nfunc (u *ChatUser) Receive(msg string) {\n    fmt.Printf(\"%s receives: %s\\n\", u.name, msg)\n}\n\nfunc (u *ChatUser) SetMediator(mediator ChatRoomMediator) {\n    u.mediator = mediator\n}\n\n// Usage\nfunc main() {\n    chatRoom := &ChatRoom{}\n    \n    alice := NewChatUser(\"Alice\")\n    bob := NewChatUser(\"Bob\")\n    charlie := NewChatUser(\"Charlie\")\n    \n    chatRoom.AddUser(alice)\n    chatRoom.AddUser(bob)\n    chatRoom.AddUser(charlie)\n    \n    alice.Send(\"Hello everyone!\")\n    bob.Send(\"Hey Alice!\")\n}\n```\n\n### Memento\nMemento captures and externalizes an object's internal state for later restoration.\n\n```go\n// Memento\ntype EditorMemento struct {\n    content string\n    cursor  int\n}\n\n// Originator\ntype TextEditor struct {\n    content string\n    cursor  int\n}\n\nfunc (e *TextEditor) Type(text string) {\n    e.content = e.content[:e.cursor] + text + e.content[e.cursor:]\n    e.cursor += len(text)\n}\n\nfunc (e *TextEditor) Delete(length int) {\n    if e.cursor >= length {\n        e.content = e.content[:e.cursor-length] + e.content[e.cursor:]\n        e.cursor -= length\n    }\n}\n\nfunc (e *TextEditor) Save() *EditorMemento {\n    return &EditorMemento{\n        content: e.content,\n        cursor:  e.cursor,\n    }\n}\n\nfunc (e *TextEditor) Restore(memento *EditorMemento) {\n    e.content = memento.content\n    e.cursor = memento.cursor\n}\n\nfunc (e *TextEditor) String() string {\n    return fmt.Sprintf(\"Content: %s (cursor at %d)\", e.content, e.cursor)\n}\n\n// Caretaker\ntype History struct {\n    mementos []*EditorMemento\n    current  int\n}\n\nfunc (h *History) Push(memento *EditorMemento) {\n    // Remove any states after current position\n    h.mementos = h.mementos[:h.current+1]\n    h.mementos = append(h.mementos, memento)\n    h.current++\n}\n\nfunc (h *History) Undo() *EditorMemento {\n    if h.current > 0 {\n        h.current--\n        return h.mementos[h.current]\n    }\n    return nil\n}\n\nfunc (h *History) Redo() *EditorMemento {\n    if h.current < len(h.mementos)-1 {\n        h.current++\n        return h.mementos[h.current]\n    }\n    return nil\n}\n\n// Usage\nfunc main() {\n    editor := &TextEditor{}\n    history := &History{}\n    \n    // Initial state\n    history.Push(editor.Save())\n    \n    editor.Type(\"Hello \")\n    history.Push(editor.Save())\n    \n    editor.Type(\"World\")\n    history.Push(editor.Save())\n    \n    editor.Type(\"!\")\n    history.Push(editor.Save())\n    \n    fmt.Println(editor)\n    \n    // Undo\n    if memento := history.Undo(); memento != nil {\n        editor.Restore(memento)\n        fmt.Println(\"After undo:\", editor)\n    }\n    \n    // Undo again\n    if memento := history.Undo(); memento != nil {\n        editor.Restore(memento)\n        fmt.Println(\"After undo:\", editor)\n    }\n    \n    // Redo\n    if memento := history.Redo(); memento != nil {\n        editor.Restore(memento)\n        fmt.Println(\"After redo:\", editor)\n    }\n}\n```\n\n### Observer\nObserver defines a one-to-many dependency between objects where state changes are automatically notified.\n\n```go\n// Observer interface\ntype Observer interface {\n    Update(event string, data interface{})\n}\n\n// Subject interface\ntype Subject interface {\n    Attach(observer Observer)\n    Detach(observer Observer)\n    Notify(event string, data interface{})\n}\n\n// Concrete subject\ntype StockPrice struct {\n    observers map[Observer]bool\n    symbol    string\n    price     float64\n}\n\nfunc NewStockPrice(symbol string) *StockPrice {\n    return &StockPrice{\n        observers: make(map[Observer]bool),\n        symbol:    symbol,\n    }\n}\n\nfunc (s *StockPrice) Attach(observer Observer) {\n    s.observers[observer] = true\n}\n\nfunc (s *StockPrice) Detach(observer Observer) {\n    delete(s.observers, observer)\n}\n\nfunc (s *StockPrice) Notify(event string, data interface{}) {\n    for observer := range s.observers {\n        observer.Update(event, data)\n    }\n}\n\nfunc (s *StockPrice) SetPrice(price float64) {\n    oldPrice := s.price\n    s.price = price\n    \n    change := ((price - oldPrice) / oldPrice) * 100\n    s.Notify(\"price_changed\", map[string]interface{}{\n        \"symbol\":    s.symbol,\n        \"old_price\": oldPrice,\n        \"new_price\": price,\n        \"change\":    change,\n    })\n}\n\n// Concrete observers\ntype InvestorAlert struct {\n    name string\n}\n\nfunc (i *InvestorAlert) Update(event string, data interface{}) {\n    if event == \"price_changed\" {\n        priceData := data.(map[string]interface{})\n        fmt.Printf(\"[%s] Price alert: %s changed from %.2f to %.2f (%.2f%%)\\n\",\n            i.name,\n            priceData[\"symbol\"],\n            priceData[\"old_price\"],\n            priceData[\"new_price\"],\n            priceData[\"change\"])\n    }\n}\n\ntype TradingBot struct {\n    threshold float64\n}\n\nfunc (t *TradingBot) Update(event string, data interface{}) {\n    if event == \"price_changed\" {\n        priceData := data.(map[string]interface{})\n        change := priceData[\"change\"].(float64)\n        \n        if change > t.threshold {\n            fmt.Printf(\"[Bot] BUY signal: price increased by %.2f%%\\n\", change)\n        } else if change < -t.threshold {\n            fmt.Printf(\"[Bot] SELL signal: price decreased by %.2f%%\\n\", change)\n        }\n    }\n}\n\n// Usage\nfunc main() {\n    stock := NewStockPrice(\"AAPL\")\n    \n    investor := &InvestorAlert{name: \"John\"}\n    bot := &TradingBot{threshold: 5.0}\n    \n    stock.Attach(investor)\n    stock.Attach(bot)\n    \n    stock.SetPrice(100.00)\n    stock.SetPrice(105.50)\n    stock.SetPrice(98.00)\n}\n```\n\n### State\nState allows an object to alter its behavior when its internal state changes.\n\n```go\n// State interface\ntype State interface {\n    InsertCoin(m *VendingMachine)\n    SelectProduct(m *VendingMachine)\n    Dispense(m *VendingMachine)\n    Cancel(m *VendingMachine)\n}\n\n// Context\ntype VendingMachine struct {\n    state    State\n    coins    int\n    products int\n}\n\nfunc NewVendingMachine(products int) *VendingMachine {\n    vm := &VendingMachine{\n        products: products,\n    }\n    vm.state = &IdleState{}\n    return vm\n}\n\nfunc (m *VendingMachine) SetState(state State) {\n    m.state = state\n    fmt.Printf(\"State changed to: %T\\n\", state)\n}\n\nfunc (m *VendingMachine) InsertCoin() {\n    m.state.InsertCoin(m)\n}\n\nfunc (m *VendingMachine) SelectProduct() {\n    m.state.SelectProduct(m)\n}\n\nfunc (m *VendingMachine) Dispense() {\n    m.state.Dispense(m)\n}\n\nfunc (m *VendingMachine) Cancel() {\n    m.state.Cancel(m)\n}\n\n// Concrete states\ntype IdleState struct{}\n\nfunc (s *IdleState) InsertCoin(m *VendingMachine) {\n    fmt.Println(\"Coin inserted\")\n    m.coins++\n    m.SetState(&HasCoinState{})\n}\n\nfunc (s *IdleState) SelectProduct(m *VendingMachine) {\n    fmt.Println(\"Please insert coin first\")\n}\n\nfunc (s *IdleState) Dispense(m *VendingMachine) {\n    fmt.Println(\"Please insert coin and select product\")\n}\n\nfunc (s *IdleState) Cancel(m *VendingMachine) {\n    fmt.Println(\"Nothing to cancel\")\n}\n\ntype HasCoinState struct{}\n\nfunc (s *HasCoinState) InsertCoin(m *VendingMachine) {\n    fmt.Println(\"Coin already inserted\")\n}\n\nfunc (s *HasCoinState) SelectProduct(m *VendingMachine) {\n    if m.products > 0 {\n        fmt.Println(\"Product selected\")\n        m.SetState(&DispensingState{})\n        m.Dispense()\n    } else {\n        fmt.Println(\"Out of products\")\n        m.Cancel()\n    }\n}\n\nfunc (s *HasCoinState) Dispense(m *VendingMachine) {\n    fmt.Println(\"Please select product first\")\n}\n\nfunc (s *HasCoinState) Cancel(m *VendingMachine) {\n    fmt.Println(\"Returning coin\")\n    m.coins--\n    m.SetState(&IdleState{})\n}\n\ntype DispensingState struct{}\n\nfunc (s *DispensingState) InsertCoin(m *VendingMachine) {\n    fmt.Println(\"Please wait, dispensing product\")\n}\n\nfunc (s *DispensingState) SelectProduct(m *VendingMachine) {\n    fmt.Println(\"Please wait, dispensing product\")\n}\n\nfunc (s *DispensingState) Dispense(m *VendingMachine) {\n    fmt.Println(\"Dispensing product\")\n    m.products--\n    m.coins--\n    m.SetState(&IdleState{})\n}\n\nfunc (s *DispensingState) Cancel(m *VendingMachine) {\n    fmt.Println(\"Cannot cancel, already dispensing\")\n}\n\n// Usage\nfunc main() {\n    machine := NewVendingMachine(2)\n    \n    machine.SelectProduct() // Error: need coin\n    machine.InsertCoin()\n    machine.SelectProduct() // OK, dispenses\n    \n    machine.InsertCoin()\n    machine.Cancel() // Returns coin\n}\n```\n\n### Strategy\nStrategy defines a family of algorithms and makes them interchangeable.\n\n```go\n// Strategy interface\ntype PaymentStrategy interface {\n    Pay(amount float64) error\n    GetName() string\n}\n\n// Concrete strategies\ntype CreditCardStrategy struct {\n    number string\n    cvv    string\n}\n\nfunc (c *CreditCardStrategy) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with credit card %s\\n\", amount, c.number)\n    // Payment logic\n    return nil\n}\n\nfunc (c *CreditCardStrategy) GetName() string {\n    return \"Credit Card\"\n}\n\ntype PayPalStrategy struct {\n    email string\n}\n\nfunc (p *PayPalStrategy) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with PayPal account %s\\n\", amount, p.email)\n    // Payment logic\n    return nil\n}\n\nfunc (p *PayPalStrategy) GetName() string {\n    return \"PayPal\"\n}\n\ntype CryptoStrategy struct {\n    walletAddress string\n}\n\nfunc (c *CryptoStrategy) Pay(amount float64) error {\n    fmt.Printf(\"Paying $%.2f with crypto wallet %s\\n\", amount, c.walletAddress)\n    // Payment logic\n    return nil\n}\n\nfunc (c *CryptoStrategy) GetName() string {\n    return \"Cryptocurrency\"\n}\n\n// Context\ntype ShoppingCart struct {\n    items    []string\n    total    float64\n    strategy PaymentStrategy\n}\n\nfunc (s *ShoppingCart) AddItem(item string, price float64) {\n    s.items = append(s.items, item)\n    s.total += price\n}\n\nfunc (s *ShoppingCart) SetPaymentStrategy(strategy PaymentStrategy) {\n    s.strategy = strategy\n    fmt.Printf(\"Payment method set to: %s\\n\", strategy.GetName())\n}\n\nfunc (s *ShoppingCart) Checkout() error {\n    if s.strategy == nil {\n        return fmt.Errorf(\"no payment method selected\")\n    }\n    \n    fmt.Printf(\"Total: $%.2f\\n\", s.total)\n    return s.strategy.Pay(s.total)\n}\n\n// Usage\nfunc main() {\n    cart := &ShoppingCart{}\n    cart.AddItem(\"Laptop\", 999.99)\n    cart.AddItem(\"Mouse\", 29.99)\n    \n    // Pay with credit card\n    cart.SetPaymentStrategy(&CreditCardStrategy{\n        number: \"1234-5678-9012-3456\",\n        cvv:    \"123\",\n    })\n    cart.Checkout()\n    \n    // Change to PayPal\n    cart.SetPaymentStrategy(&PayPalStrategy{\n        email: \"user@example.com\",\n    })\n    cart.Checkout()\n}\n```\n\n### Template Method\nTemplate Method defines the skeleton of an algorithm in a base class, letting subclasses override specific steps.\n\n```go\n// Abstract class (using struct embedding in Go)\ntype DataProcessor struct {\n    // Define the interface that subclasses must implement\n    processor DataProcessorInterface\n}\n\ntype DataProcessorInterface interface {\n    Extract() ([]byte, error)\n    Transform(data []byte) ([]byte, error)\n    Load(data []byte) error\n}\n\n// Template method\nfunc (d *DataProcessor) Process() error {\n    // Extract\n    data, err := d.processor.Extract()\n    if err != nil {\n        return fmt.Errorf(\"extraction failed: %w\", err)\n    }\n    \n    // Transform\n    transformed, err := d.processor.Transform(data)\n    if err != nil {\n        return fmt.Errorf(\"transformation failed: %w\", err)\n    }\n    \n    // Load\n    if err := d.processor.Load(transformed); err != nil {\n        return fmt.Errorf(\"loading failed: %w\", err)\n    }\n    \n    return nil\n}\n\n// Concrete implementation - CSV Processor\ntype CSVProcessor struct {\n    DataProcessor\n    filename string\n}\n\nfunc NewCSVProcessor(filename string) *CSVProcessor {\n    p := &CSVProcessor{filename: filename}\n    p.DataProcessor.processor = p\n    return p\n}\n\nfunc (c *CSVProcessor) Extract() ([]byte, error) {\n    fmt.Printf(\"Extracting data from CSV file: %s\\n\", c.filename)\n    // Read CSV file\n    return []byte(\"csv,data,here\"), nil\n}\n\nfunc (c *CSVProcessor) Transform(data []byte) ([]byte, error) {\n    fmt.Println(\"Transforming CSV data\")\n    // Transform CSV data\n    return []byte(\"transformed csv data\"), nil\n}\n\nfunc (c *CSVProcessor) Load(data []byte) error {\n    fmt.Println(\"Loading CSV data to database\")\n    // Load to database\n    return nil\n}\n\n// Concrete implementation - JSON Processor\ntype JSONProcessor struct {\n    DataProcessor\n    url string\n}\n\nfunc NewJSONProcessor(url string) *JSONProcessor {\n    p := &JSONProcessor{url: url}\n    p.DataProcessor.processor = p\n    return p\n}\n\nfunc (j *JSONProcessor) Extract() ([]byte, error) {\n    fmt.Printf(\"Fetching JSON from API: %s\\n\", j.url)\n    // Fetch from API\n    return []byte(`{\"data\": \"value\"}`), nil\n}\n\nfunc (j *JSONProcessor) Transform(data []byte) ([]byte, error) {\n    fmt.Println(\"Transforming JSON data\")\n    // Transform JSON\n    return []byte(\"transformed json\"), nil\n}\n\nfunc (j *JSONProcessor) Load(data []byte) error {\n    fmt.Println(\"Loading JSON data to cache\")\n    // Load to cache\n    return nil\n}\n\n// Usage\nfunc main() {\n    csvProcessor := NewCSVProcessor(\"data.csv\")\n    if err := csvProcessor.Process(); err != nil {\n        fmt.Printf(\"CSV processing failed: %v\\n\", err)\n    }\n    \n    fmt.Println()\n    \n    jsonProcessor := NewJSONProcessor(\"https://api.example.com/data\")\n    if err := jsonProcessor.Process(); err != nil {\n        fmt.Printf(\"JSON processing failed: %v\\n\", err)\n    }\n}\n```\n\n### Visitor\nVisitor lets you define new operations without changing the classes of elements on which it operates.\n\n```go\n// Element interface\ntype Shape interface {\n    Accept(visitor Visitor)\n}\n\n// Visitor interface\ntype Visitor interface {\n    VisitCircle(c *Circle)\n    VisitRectangle(r *Rectangle)\n    VisitTriangle(t *Triangle)\n}\n\n// Concrete elements\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c *Circle) Accept(visitor Visitor) {\n    visitor.VisitCircle(c)\n}\n\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r *Rectangle) Accept(visitor Visitor) {\n    visitor.VisitRectangle(r)\n}\n\ntype Triangle struct {\n    Base, Height float64\n}\n\nfunc (t *Triangle) Accept(visitor Visitor) {\n    visitor.VisitTriangle(t)\n}\n\n// Concrete visitors\ntype AreaCalculator struct {\n    totalArea float64\n}\n\nfunc (a *AreaCalculator) VisitCircle(c *Circle) {\n    area := 3.14159 * c.Radius * c.Radius\n    fmt.Printf(\"Circle area: %.2f\\n\", area)\n    a.totalArea += area\n}\n\nfunc (a *AreaCalculator) VisitRectangle(r *Rectangle) {\n    area := r.Width * r.Height\n    fmt.Printf(\"Rectangle area: %.2f\\n\", area)\n    a.totalArea += area\n}\n\nfunc (a *AreaCalculator) VisitTriangle(t *Triangle) {\n    area := 0.5 * t.Base * t.Height\n    fmt.Printf(\"Triangle area: %.2f\\n\", area)\n    a.totalArea += area\n}\n\ntype PerimeterCalculator struct {\n    totalPerimeter float64\n}\n\nfunc (p *PerimeterCalculator) VisitCircle(c *Circle) {\n    perimeter := 2 * 3.14159 * c.Radius\n    fmt.Printf(\"Circle perimeter: %.2f\\n\", perimeter)\n    p.totalPerimeter += perimeter\n}\n\nfunc (p *PerimeterCalculator) VisitRectangle(r *Rectangle) {\n    perimeter := 2 * (r.Width + r.Height)\n    fmt.Printf(\"Rectangle perimeter: %.2f\\n\", perimeter)\n    p.totalPerimeter += perimeter\n}\n\nfunc (p *PerimeterCalculator) VisitTriangle(t *Triangle) {\n    // Simplified: assuming equilateral triangle\n    perimeter := 3 * t.Base\n    fmt.Printf(\"Triangle perimeter: %.2f\\n\", perimeter)\n    p.totalPerimeter += perimeter\n}\n\n// Usage\nfunc main() {\n    shapes := []Shape{\n        &Circle{Radius: 5},\n        &Rectangle{Width: 10, Height: 5},\n        &Triangle{Base: 6, Height: 4},\n    }\n    \n    areaCalc := &AreaCalculator{}\n    for _, shape := range shapes {\n        shape.Accept(areaCalc)\n    }\n    fmt.Printf(\"Total area: %.2f\\n\\n\", areaCalc.totalArea)\n    \n    perimCalc := &PerimeterCalculator{}\n    for _, shape := range shapes {\n        shape.Accept(perimCalc)\n    }\n    fmt.Printf(\"Total perimeter: %.2f\\n\", perimCalc.totalPerimeter)\n}\n```\n\n## Architectural Patterns\n\n### Repository Pattern\nRepository encapsulates data access logic and provides a more object-oriented view of the persistence layer.\n\n```go\n// Domain model\ntype User struct {\n    ID        string\n    Email     string\n    FirstName string\n    LastName  string\n    CreatedAt time.Time\n}\n\n// Repository interface\ntype UserRepository interface {\n    Create(ctx context.Context, user *User) error\n    GetByID(ctx context.Context, id string) (*User, error)\n    GetByEmail(ctx context.Context, email string) (*User, error)\n    Update(ctx context.Context, user *User) error\n    Delete(ctx context.Context, id string) error\n    List(ctx context.Context, offset, limit int) ([]*User, error)\n}\n\n// PostgreSQL implementation\ntype PostgresUserRepository struct {\n    db *sql.DB\n}\n\nfunc NewPostgresUserRepository(db *sql.DB) *PostgresUserRepository {\n    return &PostgresUserRepository{db: db}\n}\n\nfunc (r *PostgresUserRepository) Create(ctx context.Context, user *User) error {\n    query := `\n        INSERT INTO users (id, email, first_name, last_name, created_at)\n        VALUES ($1, $2, $3, $4, $5)\n    `\n    _, err := r.db.ExecContext(ctx, query,\n        user.ID, user.Email, user.FirstName, user.LastName, user.CreatedAt)\n    return err\n}\n\nfunc (r *PostgresUserRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    query := `\n        SELECT id, email, first_name, last_name, created_at\n        FROM users WHERE id = $1\n    `\n    user := &User{}\n    err := r.db.QueryRowContext(ctx, query, id).Scan(\n        &user.ID, &user.Email, &user.FirstName, &user.LastName, &user.CreatedAt)\n    if err == sql.ErrNoRows {\n        return nil, fmt.Errorf(\"user not found\")\n    }\n    return user, err\n}\n\n// In-memory implementation for testing\ntype InMemoryUserRepository struct {\n    mu    sync.RWMutex\n    users map[string]*User\n}\n\nfunc NewInMemoryUserRepository() *InMemoryUserRepository {\n    return &InMemoryUserRepository{\n        users: make(map[string]*User),\n    }\n}\n\nfunc (r *InMemoryUserRepository) Create(ctx context.Context, user *User) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    \n    if _, exists := r.users[user.ID]; exists {\n        return fmt.Errorf(\"user already exists\")\n    }\n    r.users[user.ID] = user\n    return nil\n}\n\nfunc (r *InMemoryUserRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    \n    if user, exists := r.users[id]; exists {\n        return user, nil\n    }\n    return nil, fmt.Errorf(\"user not found\")\n}\n```\n\n### Unit of Work Pattern\nUnit of Work maintains a list of objects affected by a business transaction and coordinates writing out changes.\n\n```go\n// Unit of Work interface\ntype UnitOfWork interface {\n    UserRepository() UserRepository\n    OrderRepository() OrderRepository\n    Commit() error\n    Rollback() error\n}\n\n// PostgreSQL Unit of Work\ntype PostgresUnitOfWork struct {\n    tx    *sql.Tx\n    users *PostgresUserRepository\n    orders *PostgresOrderRepository\n}\n\nfunc NewPostgresUnitOfWork(db *sql.DB) (*PostgresUnitOfWork, error) {\n    tx, err := db.Begin()\n    if err != nil {\n        return nil, err\n    }\n    \n    return &PostgresUnitOfWork{\n        tx:     tx,\n        users:  &PostgresUserRepository{db: db},\n        orders: &PostgresOrderRepository{db: db},\n    }, nil\n}\n\nfunc (u *PostgresUnitOfWork) UserRepository() UserRepository {\n    return u.users\n}\n\nfunc (u *PostgresUnitOfWork) OrderRepository() OrderRepository {\n    return u.orders\n}\n\nfunc (u *PostgresUnitOfWork) Commit() error {\n    return u.tx.Commit()\n}\n\nfunc (u *PostgresUnitOfWork) Rollback() error {\n    return u.tx.Rollback()\n}\n\n// Service using Unit of Work\ntype OrderService struct {\n    uowFactory func() (UnitOfWork, error)\n}\n\nfunc (s *OrderService) CreateOrder(userID string, items []OrderItem) error {\n    uow, err := s.uowFactory()\n    if err != nil {\n        return err\n    }\n    defer uow.Rollback()\n    \n    // Check user exists\n    user, err := uow.UserRepository().GetByID(context.Background(), userID)\n    if err != nil {\n        return err\n    }\n    \n    // Create order\n    order := &Order{\n        UserID: user.ID,\n        Items:  items,\n        Total:  calculateTotal(items),\n    }\n    \n    if err := uow.OrderRepository().Create(context.Background(), order); err != nil {\n        return err\n    }\n    \n    // Update user stats\n    user.TotalOrders++\n    if err := uow.UserRepository().Update(context.Background(), user); err != nil {\n        return err\n    }\n    \n    // Commit transaction\n    return uow.Commit()\n}\n```\n\n## Domain-Driven Design Patterns\n\n### Value Object\nValue Objects are immutable objects that represent a descriptive aspect of the domain.\n\n```go\n// Value Object - immutable\ntype Money struct {\n    amount   decimal.Decimal\n    currency string\n}\n\nfunc NewMoney(amount decimal.Decimal, currency string) (Money, error) {\n    if currency == \"\" {\n        return Money{}, fmt.Errorf(\"currency is required\")\n    }\n    if amount.IsNegative() {\n        return Money{}, fmt.Errorf(\"amount cannot be negative\")\n    }\n    return Money{amount: amount, currency: currency}, nil\n}\n\nfunc (m Money) Amount() decimal.Decimal {\n    return m.amount\n}\n\nfunc (m Money) Currency() string {\n    return m.currency\n}\n\nfunc (m Money) Add(other Money) (Money, error) {\n    if m.currency != other.currency {\n        return Money{}, fmt.Errorf(\"cannot add different currencies\")\n    }\n    return Money{\n        amount:   m.amount.Add(other.amount),\n        currency: m.currency,\n    }, nil\n}\n\nfunc (m Money) Equals(other Money) bool {\n    return m.amount.Equal(other.amount) && m.currency == other.currency\n}\n\n// Another Value Object example\ntype Email struct {\n    value string\n}\n\nfunc NewEmail(value string) (Email, error) {\n    if !isValidEmail(value) {\n        return Email{}, fmt.Errorf(\"invalid email format\")\n    }\n    return Email{value: strings.ToLower(value)}, nil\n}\n\nfunc (e Email) String() string {\n    return e.value\n}\n\nfunc (e Email) Domain() string {\n    parts := strings.Split(e.value, \"@\")\n    if len(parts) == 2 {\n        return parts[1]\n    }\n    return \"\"\n}\n```\n\n### Entity\nEntities have identity and lifecycle.\n\n```go\n// Entity with identity\ntype Product struct {\n    id          ProductID // Value object as ID\n    name        string\n    description string\n    price       Money\n    stock       int\n    version     int // For optimistic locking\n}\n\ntype ProductID struct {\n    value string\n}\n\nfunc NewProductID(value string) (ProductID, error) {\n    if value == \"\" {\n        return ProductID{}, fmt.Errorf(\"product ID cannot be empty\")\n    }\n    return ProductID{value: value}, nil\n}\n\nfunc (p ProductID) String() string {\n    return p.value\n}\n\nfunc NewProduct(id ProductID, name string, price Money) (*Product, error) {\n    if name == \"\" {\n        return nil, fmt.Errorf(\"product name is required\")\n    }\n    \n    return &Product{\n        id:    id,\n        name:  name,\n        price: price,\n        stock: 0,\n    }, nil\n}\n\nfunc (p *Product) ID() ProductID {\n    return p.id\n}\n\nfunc (p *Product) UpdatePrice(newPrice Money) error {\n    if newPrice.Amount().IsZero() {\n        return fmt.Errorf(\"price cannot be zero\")\n    }\n    p.price = newPrice\n    p.version++\n    return nil\n}\n\nfunc (p *Product) AddStock(quantity int) error {\n    if quantity <= 0 {\n        return fmt.Errorf(\"quantity must be positive\")\n    }\n    p.stock += quantity\n    p.version++\n    return nil\n}\n\nfunc (p *Product) CanFulfillOrder(quantity int) bool {\n    return p.stock >= quantity\n}\n```\n\n### Aggregate\nAggregates are clusters of domain objects that are treated as a single unit.\n\n```go\n// Aggregate root\ntype Order struct {\n    id         OrderID\n    customerID CustomerID\n    items      []OrderItem\n    status     OrderStatus\n    totalAmount Money\n    placedAt   time.Time\n    version    int\n}\n\n// Part of the aggregate\ntype OrderItem struct {\n    productID ProductID\n    quantity  int\n    unitPrice Money\n}\n\ntype OrderStatus string\n\nconst (\n    OrderStatusPending   OrderStatus = \"PENDING\"\n    OrderStatusConfirmed OrderStatus = \"CONFIRMED\"\n    OrderStatusShipped   OrderStatus = \"SHIPPED\"\n    OrderStatusDelivered OrderStatus = \"DELIVERED\"\n    OrderStatusCancelled OrderStatus = \"CANCELLED\"\n)\n\nfunc NewOrder(customerID CustomerID) *Order {\n    return &Order{\n        id:         NewOrderID(),\n        customerID: customerID,\n        items:      []OrderItem{},\n        status:     OrderStatusPending,\n        placedAt:   time.Now(),\n    }\n}\n\nfunc (o *Order) AddItem(productID ProductID, quantity int, unitPrice Money) error {\n    if o.status != OrderStatusPending {\n        return fmt.Errorf(\"cannot modify confirmed order\")\n    }\n    \n    if quantity <= 0 {\n        return fmt.Errorf(\"quantity must be positive\")\n    }\n    \n    // Check if item already exists\n    for i, item := range o.items {\n        if item.productID == productID {\n            o.items[i].quantity += quantity\n            o.recalculateTotal()\n            return nil\n        }\n    }\n    \n    // Add new item\n    o.items = append(o.items, OrderItem{\n        productID: productID,\n        quantity:  quantity,\n        unitPrice: unitPrice,\n    })\n    \n    o.recalculateTotal()\n    return nil\n}\n\nfunc (o *Order) RemoveItem(productID ProductID) error {\n    if o.status != OrderStatusPending {\n        return fmt.Errorf(\"cannot modify confirmed order\")\n    }\n    \n    for i, item := range o.items {\n        if item.productID == productID {\n            o.items = append(o.items[:i], o.items[i+1:]...)\n            o.recalculateTotal()\n            return nil\n        }\n    }\n    \n    return fmt.Errorf(\"item not found\")\n}\n\nfunc (o *Order) Confirm() error {\n    if o.status != OrderStatusPending {\n        return fmt.Errorf(\"order is not pending\")\n    }\n    \n    if len(o.items) == 0 {\n        return fmt.Errorf(\"order has no items\")\n    }\n    \n    o.status = OrderStatusConfirmed\n    o.version++\n    return nil\n}\n\nfunc (o *Order) recalculateTotal() {\n    total := decimal.Zero\n    currency := \"\"\n    \n    for _, item := range o.items {\n        itemTotal := item.unitPrice.Amount().Mul(decimal.NewFromInt(int64(item.quantity)))\n        total = total.Add(itemTotal)\n        if currency == \"\" {\n            currency = item.unitPrice.Currency()\n        }\n    }\n    \n    o.totalAmount, _ = NewMoney(total, currency)\n}\n\n// Aggregate repository\ntype OrderRepository interface {\n    Save(ctx context.Context, order *Order) error\n    GetByID(ctx context.Context, id OrderID) (*Order, error)\n    // Never expose internal parts of aggregate\n    // Bad: GetOrderItems(orderID) []OrderItem\n}\n```\n\n### Domain Service\nDomain Services encapsulate domain logic that doesn't naturally fit within an entity or value object.\n\n```go\n// Domain service for complex business logic\ntype PricingService struct {\n    taxCalculator TaxCalculator\n    discountRepo  DiscountRepository\n}\n\nfunc NewPricingService(tax TaxCalculator, discounts DiscountRepository) *PricingService {\n    return &PricingService{\n        taxCalculator: tax,\n        discountRepo:  discounts,\n    }\n}\n\nfunc (s *PricingService) CalculateOrderTotal(order *Order, customerType CustomerType) (Money, error) {\n    subtotal := order.totalAmount\n    \n    // Apply customer discount\n    discount := s.getCustomerDiscount(customerType)\n    discountAmount := subtotal.Amount().Mul(discount)\n    afterDiscount := subtotal.Amount().Sub(discountAmount)\n    \n    // Calculate tax\n    tax := s.taxCalculator.CalculateTax(afterDiscount, order.ShippingAddress())\n    \n    // Final total\n    total := afterDiscount.Add(tax)\n    \n    return NewMoney(total, subtotal.Currency())\n}\n\nfunc (s *PricingService) getCustomerDiscount(customerType CustomerType) decimal.Decimal {\n    switch customerType {\n    case CustomerTypePremium:\n        return decimal.NewFromFloat(0.15) // 15% discount\n    case CustomerTypeRegular:\n        return decimal.NewFromFloat(0.05) // 5% discount\n    default:\n        return decimal.Zero\n    }\n}\n\n// Another domain service example\ntype TransferService struct {\n    accountRepo AccountRepository\n}\n\nfunc (s *TransferService) Transfer(ctx context.Context, fromID, toID AccountID, amount Money) error {\n    // This logic doesn't belong to either account\n    // It's a domain service coordinating between aggregates\n    \n    from, err := s.accountRepo.GetByID(ctx, fromID)\n    if err != nil {\n        return err\n    }\n    \n    to, err := s.accountRepo.GetByID(ctx, toID)\n    if err != nil {\n        return err\n    }\n    \n    if err := from.Withdraw(amount); err != nil {\n        return err\n    }\n    \n    if err := to.Deposit(amount); err != nil {\n        // Compensate\n        from.Deposit(amount)\n        return err\n    }\n    \n    // Save both accounts\n    if err := s.accountRepo.Save(ctx, from); err != nil {\n        return err\n    }\n    \n    return s.accountRepo.Save(ctx, to)\n}\n```\n\n### Specification Pattern\nSpecification pattern encapsulates business rules in a reusable way.\n\n```go\n// Specification interface\ntype Specification[T any] interface {\n    IsSatisfiedBy(T) bool\n    And(Specification[T]) Specification[T]\n    Or(Specification[T]) Specification[T]\n    Not() Specification[T]\n}\n\n// Base specification\ntype BaseSpecification[T any] struct {\n    predicate func(T) bool\n}\n\nfunc NewSpecification[T any](predicate func(T) bool) Specification[T] {\n    return &BaseSpecification[T]{predicate: predicate}\n}\n\nfunc (s *BaseSpecification[T]) IsSatisfiedBy(item T) bool {\n    return s.predicate(item)\n}\n\nfunc (s *BaseSpecification[T]) And(other Specification[T]) Specification[T] {\n    return &BaseSpecification[T]{\n        predicate: func(item T) bool {\n            return s.IsSatisfiedBy(item) && other.IsSatisfiedBy(item)\n        },\n    }\n}\n\nfunc (s *BaseSpecification[T]) Or(other Specification[T]) Specification[T] {\n    return &BaseSpecification[T]{\n        predicate: func(item T) bool {\n            return s.IsSatisfiedBy(item) || other.IsSatisfiedBy(item)\n        },\n    }\n}\n\nfunc (s *BaseSpecification[T]) Not() Specification[T] {\n    return &BaseSpecification[T]{\n        predicate: func(item T) bool {\n            return !s.IsSatisfiedBy(item)\n        },\n    }\n}\n\n// Concrete specifications\ntype Product struct {\n    Name     string\n    Price    decimal.Decimal\n    Category string\n    InStock  bool\n}\n\nvar PremiumProductSpec = NewSpecification(func(p Product) bool {\n    return p.Price.GreaterThan(decimal.NewFromInt(100))\n})\n\nvar InStockSpec = NewSpecification(func(p Product) bool {\n    return p.InStock\n})\n\nvar ElectronicsSpec = NewSpecification(func(p Product) bool {\n    return p.Category == \"Electronics\"\n})\n\n// Usage\nfunc FilterProducts(products []Product, spec Specification[Product]) []Product {\n    var result []Product\n    for _, p := range products {\n        if spec.IsSatisfiedBy(p) {\n            result = append(result, p)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    products := []Product{\n        {Name: \"Laptop\", Price: decimal.NewFromInt(1200), Category: \"Electronics\", InStock: true},\n        {Name: \"Mouse\", Price: decimal.NewFromInt(25), Category: \"Electronics\", InStock: true},\n        {Name: \"Book\", Price: decimal.NewFromInt(15), Category: \"Books\", InStock: false},\n    }\n    \n    // Premium electronics in stock\n    spec := PremiumProductSpec.And(ElectronicsSpec).And(InStockSpec)\n    \n    filtered := FilterProducts(products, spec)\n    fmt.Printf(\"Found %d products\\n\", len(filtered))\n}\n```\n\n## Summary\n\nThis comprehensive guide covers the major design patterns adapted for Go:\n\n1. **Creational Patterns**: Control object creation mechanisms\n2. **Structural Patterns**: Compose objects to form larger structures\n3. **Behavioral Patterns**: Define communication between objects\n4. **Architectural Patterns**: Organize high-level application structure\n5. **Domain-Driven Design Patterns**: Model complex business domains\n\nEach pattern includes practical Go implementations with proper error handling, concurrency considerations, and idiomatic Go practices. Choose patterns based on your specific needs, keeping in mind Go's philosophy of simplicity and clarity.","structuredPatch":[]}}
{"parentUuid":"f19c2f73-4dbb-4300-82dd-a9a8b074145f","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01SSsFtbfdBjkipLpuDTKead","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Now let me update the todo list:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":96220,"cache_read_input_tokens":11551,"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CS5Q7NbPdFGbZm5CSX5C7","type":"assistant","uuid":"5a9a6608-003d-483b-9030-5df8df04ee13","timestamp":"2025-08-13T08:32:57.160Z"}
{"parentUuid":"5a9a6608-003d-483b-9030-5df8df04ee13","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01SSsFtbfdBjkipLpuDTKead","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01HUpR1Gqx45PphBoGucM9ZA","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed"},{"id":"2","content":"Create comprehensive Go language fundamentals documentation","status":"completed"},{"id":"3","content":"Reorganize and differentiate pattern documentation files","status":"completed"},{"id":"4","content":"Create advanced Go concurrency documentation","status":"pending"},{"id":"5","content":"Document Go testing and benchmarking practices","status":"pending"},{"id":"6","content":"Create Go performance optimization guide","status":"pending"},{"id":"7","content":"Document Go security best practices","status":"pending"},{"id":"8","content":"Create Go tooling and ecosystem documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":96220,"cache_read_input_tokens":11551,"output_tokens":266,"service_tier":"standard"}},"requestId":"req_011CS5Q7NbPdFGbZm5CSX5C7","type":"assistant","uuid":"9a41e32e-2d73-47ae-b2b9-df03dfa76889","timestamp":"2025-08-13T08:33:01.583Z"}
{"parentUuid":"9a41e32e-2d73-47ae-b2b9-df03dfa76889","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HUpR1Gqx45PphBoGucM9ZA","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"601ad2a1-b458-4fb9-8552-8f3c8429d1cc","timestamp":"2025-08-13T08:33:01.615Z","toolUseResult":{"oldTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"completed","id":"2"},{"content":"Reorganize and differentiate pattern documentation files","status":"in_progress","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}],"newTodos":[{"content":"Examine existing /back/.docs/code/practices-patterns file","status":"completed","id":"1"},{"content":"Create comprehensive Go language fundamentals documentation","status":"completed","id":"2"},{"content":"Reorganize and differentiate pattern documentation files","status":"completed","id":"3"},{"content":"Create advanced Go concurrency documentation","status":"pending","id":"4"},{"content":"Document Go testing and benchmarking practices","status":"pending","id":"5"},{"content":"Create Go performance optimization guide","status":"pending","id":"6"},{"content":"Document Go security best practices","status":"pending","id":"7"},{"content":"Create Go tooling and ecosystem documentation","status":"pending","id":"8"}]}}
{"parentUuid":"601ad2a1-b458-4fb9-8552-8f3c8429d1cc","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01THF9EnSroovcQxt5553qkH","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"tool_use","id":"toolu_01AKc9ACtjHiGAdoCyZUjgEP","name":"Edit","input":{"file_path":"/home/aural/Code/bigmeanie/back/.docs/todo.md","old_string":"## High Priority  \n- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)\n- [ ] Create advanced Go concurrency documentation (go-concurrency.md)","new_string":"## High Priority  \n- [x] Reorganize and differentiate pattern documentation (completed - design-patterns.md for GoF patterns, practices-patterns.md for Go idioms)\n- [ ] Create advanced Go concurrency documentation (concurrency.md)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":516,"cache_read_input_tokens":107771,"output_tokens":205,"service_tier":"standard"}},"requestId":"req_011CS5Q87nw7JWwYhuSmCsbu","type":"assistant","uuid":"74493962-49d7-4919-9e88-763981b69572","timestamp":"2025-08-13T08:33:08.231Z"}
{"parentUuid":"74493962-49d7-4919-9e88-763981b69572","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AKc9ACtjHiGAdoCyZUjgEP","type":"tool_result","content":"The file /home/aural/Code/bigmeanie/back/.docs/todo.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     2→\n     3→## Critical Priority\n     4→None\n     5→\n     6→## High Priority  \n     7→- [x] Reorganize and differentiate pattern documentation (completed - design-patterns.md for GoF patterns, practices-patterns.md for Go idioms)\n     8→- [ ] Create advanced Go concurrency documentation (concurrency.md)\n     9→- [ ] Document Go testing and benchmarking practices (go-testing.md)\n    10→- [ ] Create Go performance optimization guide (go-performance.md)\n    11→- [ ] Document Go security best practices (go-security.md)\n    12→- [ ] Create Go tooling and ecosystem documentation (go-tools.md)"}]},"uuid":"73e53461-bd30-4363-a1b1-6cdaa11aa8fe","timestamp":"2025-08-13T08:33:08.258Z","toolUseResult":{"filePath":"/home/aural/Code/bigmeanie/back/.docs/todo.md","oldString":"## High Priority  \n- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)\n- [ ] Create advanced Go concurrency documentation (go-concurrency.md)","newString":"## High Priority  \n- [x] Reorganize and differentiate pattern documentation (completed - design-patterns.md for GoF patterns, practices-patterns.md for Go idioms)\n- [ ] Create advanced Go concurrency documentation (concurrency.md)","originalFile":"# TODO List\n\n## Critical Priority\nNone\n\n## High Priority  \n- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)\n- [ ] Create advanced Go concurrency documentation (go-concurrency.md)\n- [ ] Document Go testing and benchmarking practices (go-testing.md)\n- [ ] Create Go performance optimization guide (go-performance.md)\n- [ ] Document Go security best practices (go-security.md)\n- [ ] Create Go tooling and ecosystem documentation (go-tools.md)\n\n## Medium Priority\nNone\n\n## Low Priority\nNone\n\n## Completed\n- [x] Examine existing /back/.docs/code/practices-patterns file\n- [x] Create comprehensive Go language fundamentals documentation (go-fundamentals.md created)\n- [x] Resolve conflicting indicators interface definitions (no conflict found - interfaces match implementation)\n- [x] Clarify thread safety claims in decimal_math README (added clear section on thread safety)\n- [x] Update import paths with module prefix (updated to github.com/dominicnunez/bigmeanie)\n- [x] Add thread-safe MockClock implementation example (added SafeMockClock wrapper with mutex)\n- [x] Document error handling in indicators (added comprehensive error handling section)\n- [x] Update goroutine package documented features (added TrackedGo, ListActive, StopAll to API docs)\n- [x] Fix naming inconsistencies (changed misc → pinescript to match actual directory)\n- [x] Add benchmarks or qualify performance claims (added environment notes and benchmark commands)\n- [x] Add external error wrapping examples (added comprehensive examples for stdlib and third-party)\n- [x] Fix package declaration in fees.go\n- [x] Remove verbose type names (CheckpointWorker → Worker, GracefulShutdown → Shutdown, CrashDetector → Monitor)\n- [x] Remove Get prefixes and verbose method names (GetCandles → Candles, NewSlidingWindow → NewWindow)\n- [x] Restructure fees.go with nested structs (Spot.Maker/Taker, Perp.Maker/Taker)\n- [x] Simplify function names in context.go (ProcessWithPeriodicCheck → Process, OperationWithTimeout → DoTimeout, ProcessItemsWithTimeouts → ProcessBatch, WorkerWithGracefulShutdown → Worker)\n- [x] Rename generator types in paramsgen (DynamicGenerator → Generator, GeneratorConfig → Config, ParameterSweep → Sweep)\n- [x] Update decimal cache constants (OnePercent → Pct1, FivePercent → Pct5, TenPercent → Pct10, etc.)\n- [x] Rename interfaces and helper functions (SignalGenerator → Strategy, RunSafeWorker → RunSafe, OptimalWorkerCount → WorkerCount, OptimizedWorker → Worker)","structuredPatch":[{"oldStart":4,"oldLines":8,"newStart":4,"newLines":8,"lines":[" None"," "," ## High Priority  ","-- [ ] Document all Go design patterns and idioms (in progress - go-patterns.md)","-- [ ] Create advanced Go concurrency documentation (go-concurrency.md)","+- [x] Reorganize and differentiate pattern documentation (completed - design-patterns.md for GoF patterns, practices-patterns.md for Go idioms)","+- [ ] Create advanced Go concurrency documentation (concurrency.md)"," - [ ] Document Go testing and benchmarking practices (go-testing.md)"," - [ ] Create Go performance optimization guide (go-performance.md)"," - [ ] Document Go security best practices (go-security.md)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"73e53461-bd30-4363-a1b1-6cdaa11aa8fe","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","message":{"id":"msg_01BKyLqhAf3uGLGJGSXBgGHm","type":"message","role":"assistant","model":"claude-opus-4-1-20250805","content":[{"type":"text","text":"Reorganized documentation to eliminate redundancy:\n\n1. **Removed duplicate files**: Deleted numbered files (01-core-language.md, 02-design-patterns.md) and redundant go-patterns.md\n\n2. **Created clear differentiation**:\n   - `design-patterns.md` - Classic Gang of Four patterns, architectural patterns, and DDD patterns\n   - `practices-patterns.md` - Go-specific idioms, conventions, and best practices  \n   - `fundamentals.md` - Core language features and syntax\n\n3. **Remaining specialized docs** maintain focus on specific areas without overlap\n\nThe documentation is now properly organized without redundant prefixes or overlapping content."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":427,"cache_read_input_tokens":108287,"output_tokens":156,"service_tier":"standard"}},"requestId":"req_011CS5Q8c4HuD9DkMq13dRGB","type":"assistant","uuid":"2c0c302d-ee35-4892-8675-c06d0746b928","timestamp":"2025-08-13T08:33:15.562Z"}
{"parentUuid":"2c0c302d-ee35-4892-8675-c06d0746b928","isSidechain":false,"userType":"external","cwd":"/home/aural/Code/bigmeanie/back/.docs/code","sessionId":"f69c6a1e-2c8c-45b3-b737-1352be79250b","version":"1.0.69","gitBranch":"dev","type":"system","content":"\u001b[1mStop\u001b[22m [paplay /run/current-system/sw/share/sounds/freedesktop/stereo/bell.oga] completed successfully","isMeta":false,"timestamp":"2025-08-13T08:33:15.833Z","uuid":"904be015-bf27-4d8a-8cfe-24017565e6d5","toolUseID":"f2772863-9cb1-490e-87da-5f3ecb007763","level":"info"}
